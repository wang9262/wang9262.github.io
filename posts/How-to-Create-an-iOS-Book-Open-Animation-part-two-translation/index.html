<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Vong"/><link rel="canonical" href="https://wang9262.github.io/posts/How-to-Create-an-iOS-Book-Open-Animation-part-two-translation"/><meta name="twitter:url" content="https://wang9262.github.io/posts/How-to-Create-an-iOS-Book-Open-Animation-part-two-translation"/><meta name="og:url" content="https://wang9262.github.io/posts/How-to-Create-an-iOS-Book-Open-Animation-part-two-translation"/><title>如何创建一个翻书动画(Part2)[译] | Vong</title><meta name="twitter:title" content="如何创建一个翻书动画(Part2)[译] | Vong"/><meta name="og:title" content="如何创建一个翻书动画(Part2)[译] | Vong"/><meta name="description"/><meta name="twitter:description"/><meta name="og:description"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Vong"/><meta name="twitter:image" content="https://wang9262.github.io/media"/><meta name="og:image" content="https://wang9262.github.io/media"/></head><body class="item-page"><header><div class="wrapper"><a href="/" class="site-name">Vong</a><nav><ul><li><a href="/index">Index</a></li><li><a href="/posts" class="selected">My posts</a></li><li><a href="/tags">Tags</a></li><li><a href="/about">About</a></li></ul></nav></div></header><div class="wrapper"><article><div class="content"><p>欢迎回到 iOS 翻书动画教程系列！在该系列的<a href="http://www.raywenderlich.com/94565/how-to-create-an-ios-book-open-animation-part-1">第一部分</a>(<a href="/posts/How-to-Create-an-iOS-Book-Open-Animation-part-one-translation">译文</a>，你已经知道如何创建自定义的 layout 以及如何在 app 中使用阴影效果来创建景深和模拟现实。在这篇教程中，你将学到如何创建一个自定义的转场以及如何使用 pinch 手势来打开书本。</p><!-- more --><blockquote><p>2019.11.21 update 本文中图片和资源相关链接可能已失效，如需查阅，请查看原文 感谢<a href="https://twitter.com/hegedus90">Attila Hegedüs</a>创建了这个棒棒哒示例工程。</p></blockquote><img src="/oldimages/BookOpening.gif"/><p>原文：<a href="http://www.raywenderlich.com/?p=97690">How to Create an iOS Book Open Animation: Part 2</a></p><h2>开始</h2><p>这篇教程基于<a href="/posts/How-to-Create-an-iOS-Book-Open-Animation-part-one-translation">第一部分</a>。如果你不了解第一部分或者想重新开始，可以下载上一教程的<a href="https://koenig-media.raywenderlich.com/uploads/2015/05/Part-1-Paper-Completed.zip">完整代码</a>。</p><img src="/oldimages/VN2_Start.gif"/><p>在 Xcode 中打开工程。现在你可以选择一本书，然后书本从右滑出(即 push)，这是 UINavigationController 的默认转场行为。但是在这片教程结束的时候，自定义转场看起来像这样：</p><img src="/oldimages/VN_BookOpening.gif"/><p>自定义转场将在书本打开和合上的状态转换中进行丝滑的动画过渡，这种方式非常自然，深得我心。 来吧，骚年，开撸！</p><h2>创建自定义导航控制器</h2><p>想要实现自定义转场必须创建一个自定义的导航控制器然后实现 UINavigationControllerDelegate 协议。 右键 App 分组创建一个继承自 UINavigationController 名为 CustomNavigationController 的类。语言设置为 Swift。</p><p>打开CustomNavigationController.swift，用下面代码替换其内容：</p><pre data-language="Swift"><code><span class="hljs-keyword">import</span> UIKit
 
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomNavigationController</span>: <span class="hljs-title">UINavigationController</span>, <span class="hljs-title">UINavigationControllerDelegate</span> </span>{
 
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">super</span>.viewDidLoad()
    <span class="hljs-comment">//1</span>
    delegate = <span class="hljs-keyword">self</span>
  }
 
  <span class="hljs-comment">//2</span>
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">navigationController</span><span class="hljs-params">(navigationController: UINavigationController, animationControllerForOperation operation: UINavigationControllerOperation, fromViewController fromVC: UIViewController, toViewController toVC: UIViewController)</span></span> -&gt; <span class="hljs-type">UIViewControllerAnimatedTransitioning?</span> {
    <span class="hljs-keyword">if</span> operation == .<span class="hljs-type">Push</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
    }
 
    <span class="hljs-keyword">if</span> operation == .<span class="hljs-type">Pop</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
    }
 
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
  }
}
</code></pre><p>上面代码主要做了两件事：</p><ul><li>1.在 viewDidLoad 方法中将代理设置为自身</li><li>2.navigationController(_:animationControllerForOperation:fromViewController:toViewController:) 方法是协议方法中的一个。这个方法在每次 push 或者 pop 的时候被调用，你可以在此返回对应的转场类型动画。现在这个方法返回 nil 使得其使用默认的标准转场。马上你就会用你自定义的转场类来替换它。</li></ul><p>既然导航控制器已经准备就绪，那么让我们开始来替换 storyboard 中默认的导航控制器</p><p>设置如下图所示：</p><img src="/oldimages/VN_storyboard2.png"/><p>运行一下，确保能正常运行，一切正常，因为你在代理方法中返回 nil，导致控制器使用默认转场行为。</p><h2>创建自定义转场</h2><p>终于来到重头戏环节————撸一个自定义转场！ 在自定义转场类中，必须遵循 UIViewControllerAnimatedTransitioning 协议，特别是需要实现下面几个方法：</p><ul><li>transitionDuration：必须实现。返回转场动画时间，以及同步交互转场动画</li><li>animateTransition：必须实现。提供转场过程中的源控制器和目的控制器。自定义转场的工作重心主要是在这个方法中完成</li><li>animationEnded：可选实现。在转场结束时调用。可以在该方法中还原之前的设置</li></ul><h2>设置你的转场</h2><p>右键 App 分组新建一个继承自 NSObject 名为 BookOpeningTransition 的类，设置语言为 Swift。</p><p>打开它，然后用下面代码来替换其所有内容：</p><pre data-language="Swift"><code><span class="hljs-keyword">import</span> UIKit
 
<span class="hljs-comment">//1</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookOpeningTransition</span>: <span class="hljs-title">NSObject</span>, <span class="hljs-title">UIViewControllerAnimatedTransitioning</span> </span>{
 
  <span class="hljs-comment">// MARK: Stored properties</span>
  <span class="hljs-keyword">var</span> transforms = [<span class="hljs-type">UICollectionViewCell</span>: <span class="hljs-type">CATransform3D</span>]() <span class="hljs-comment">//2</span>
  <span class="hljs-keyword">var</span> toViewBackgroundColor: <span class="hljs-type">UIColor?</span> <span class="hljs-comment">//3</span>
  <span class="hljs-keyword">var</span> isPush = <span class="hljs-literal">true</span> <span class="hljs-comment">//4</span>
 
  <span class="hljs-comment">//5</span>
  <span class="hljs-comment">// MARK: UIViewControllerAnimatedTransitioning</span>
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">transitionDuration</span><span class="hljs-params">(transitionContext: UIViewControllerContextTransitioning)</span></span> -&gt; <span class="hljs-type">NSTimeInterval</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
  }
 
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">animateTransition</span><span class="hljs-params">(transitionContext: UIViewControllerContextTransitioning)</span></span> {
 
  }
}
</code></pre><p>每个数字标号注释的解释：</p><ul><li>1.BookOpeningTransition 实现了 UIViewControllerAnimatedTransitioning 协议</li><li>2.字典 transforms 存储了键为 UICollectionViewCell 值为 CATransform3D类型的键值对。当书本打开时，它存储了每个 cell 的 transform</li><li>3.定义了目的控制器的背景色，使得渐变看起来更加清爽</li><li>4.isPush 决定了转场为 push 还是 pop</li><li>5.添加了协议中必须实现的方法避免编译器报错。紧接着就是要实现这些方法</li></ul><p>一切变量设置就绪，是时候来实现协议方法了。</p><p>用下面代码来替换 transitionDuration(_:) 中的内容：</p><pre data-language="Swift"><code><span class="hljs-keyword">if</span> isPush {
  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
} <span class="hljs-keyword">else</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
}
</code></pre><p>该方法返回了转场动画持续的时间，这里 pop 和 push都返回1秒。这个方法可以轻松改变转场动画的持续时间。 接下来需要实现第二个必须是闲的方法——animateTransition，这个方法让一切变得皆有可能。你将分两部分来实现：</p><p>写两个工具方法来分别实现 push 和 pop 的animateTransition。</p><h2>创建 push 转场</h2><p>回想一下实际生活中，你翻书的场景：</p><img src="/oldimages/VN_PushStage.png"/><p>看起来很复杂，但是你只需要关心动画的两种状态，然后让 UIView 的 animateWithDuration 方法来实现两种状态之间的过渡：</p><ul><li>1.第一阶段：书被合上</li><li>2.第二阶段：书被打开</li></ul><p>在实现 animateTransition(_:) 前，首先写一个工具方法来处理两种状态。还是在 BookOpeningTransition.swift 中，在最后添加：</p><pre data-language="Swift"><code><span class="hljs-comment">// MARK: Helper Methods</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makePerspectiveTransform</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">CATransform3D</span> {
  <span class="hljs-keyword">var</span> transform = <span class="hljs-type">CATransform3DIdentity</span>
  transform.m34 = <span class="hljs-number">1.0</span> / -<span class="hljs-number">2000</span>
  <span class="hljs-keyword">return</span> transform
}
</code></pre><p>该方法返回一个 transform，以及添加一个 z 轴上的透视。后面动画过程中你将会用到它来改变 view。</p><h3>第一阶段——书本合起</h3><p>接着在上述方法后面添加：</p><pre data-language="Swift"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">closePageCell</span><span class="hljs-params">(cell : BookPageCell)</span></span> {
  <span class="hljs-comment">// 1</span>
  <span class="hljs-keyword">var</span> transform = <span class="hljs-keyword">self</span>.makePerspectiveTransform()
  <span class="hljs-comment">// 2</span>
  <span class="hljs-keyword">if</span> cell.layer.anchorPoint.x == <span class="hljs-number">0</span> {
    <span class="hljs-comment">// 3</span>
    transform = <span class="hljs-type">CATransform3DRotate</span>(transform, <span class="hljs-type">CGFloat</span>(<span class="hljs-number">0</span>), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)
    <span class="hljs-comment">// 4</span>
    transform = <span class="hljs-type">CATransform3DTranslate</span>(transform, -<span class="hljs-number">0.7</span> * cell.layer.bounds.width / <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)
    <span class="hljs-comment">// 5</span>
    transform = <span class="hljs-type">CATransform3DScale</span>(transform, <span class="hljs-number">0.7</span>, <span class="hljs-number">0.7</span>, <span class="hljs-number">1</span>)
   }
   <span class="hljs-comment">// 6</span>
   <span class="hljs-keyword">else</span> {
     <span class="hljs-comment">// 7</span>
     transform = <span class="hljs-type">CATransform3DRotate</span>(transform, <span class="hljs-type">CGFloat</span>(-<span class="hljs-type">M_PI</span>), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)
     <span class="hljs-comment">// 8</span>
     transform = <span class="hljs-type">CATransform3DTranslate</span>(transform, <span class="hljs-number">0.7</span> * cell.layer.bounds.width / <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)
     <span class="hljs-comment">// 9</span>
     transform = <span class="hljs-type">CATransform3DScale</span>(transform, <span class="hljs-number">0.7</span>, <span class="hljs-number">0.7</span>, <span class="hljs-number">1</span>)
    }
 
    <span class="hljs-comment">//10</span>
    cell.layer.transform = transform
}
</code></pre><p>我们对每一个页面做了转换使其与书脊对齐，然后翻页时围绕着个轴做旋转来达到真实的翻阅效果。首先你想要书本是合上状态。这个方法使得每个页面平铺在封面的底部。如下图所示：</p><img src="/oldimages/VN2_ClosedState.png"/><p>我们来解释一下上面的代码：</p><ul><li>1.使用之前创建的工具方法初始化一个新的 transform</li><li>2.判断页面是否在书脊右侧</li><li>3.如果是右侧页面，设其角度为0，使其呈平铺状态</li><li>4.将页面居中并位于封面之下</li><li>5.使页面的x，y 均乘以0.7.如果你不知道为什么要乘以0.7，回想上一篇教程中你曾将封面缩小到0.7。</li><li>6.如果不是右侧页面，那就是左侧页面</li><li>7.设置左侧页面角度为180度。</li><li>8.使其位于封面之下，并居中</li><li>9.同5</li><li>10.设置 cell 的 transform</li></ul><p>现在添加如下代码到上面方法之前：</p><pre data-language="Swift"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setStartPositionForPush</span><span class="hljs-params">(fromVC: BooksViewController, toVC: BookViewController)</span></span> {
  <span class="hljs-comment">// 1</span>
  toViewBackgroundColor = fromVC.collectionView?.backgroundColor
  toVC.collectionView?.backgroundColor = <span class="hljs-literal">nil</span>
 
  <span class="hljs-comment">//2</span>
  fromVC.selectedCell()?.alpha = <span class="hljs-number">0</span>
 
  <span class="hljs-comment">//3</span>
  <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> toVC.collectionView!.visibleCells() <span class="hljs-keyword">as</span>! [<span class="hljs-type">BookPageCell</span>] {
    <span class="hljs-comment">//4</span>
    transforms[cell] = cell.layer.transform
    <span class="hljs-comment">//5</span>
    closePageCell(cell)
    cell.updateShadowLayer()
    <span class="hljs-comment">//6</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> indexPath = toVC.collectionView?.indexPathForCell(cell) {
      <span class="hljs-keyword">if</span> indexPath.row == <span class="hljs-number">0</span> {
        cell.shadowLayer.opacity = <span class="hljs-number">0</span>
      }
    }
  }
}
</code></pre><p>该方法设置了第一阶段的转场。它同时使用两个 VC 来做动画：</p><ul><li>fromVC：即书单 VC</li><li>toVC：书页 VC</li></ul><p>相关解释：</p><ul><li>1.存储 BooksViewController 的 collectionView 的背景色，设置 BookViewController 中 collectionView 的背景色为 nil</li><li>2.隐藏选中书籍的封面，toVC 将会处理封面图片的呈现</li><li>3.遍历书本页面</li><li>4.保存每个 cell 打开状态下的transform</li><li>5.因为书本一开始是合上的，所以需要合上所有页面然后更新阴影层</li><li>6.最后忽略封面的阴影</li></ul><h3>第二阶端——打开书籍</h3><p>我们已经完成第一阶段的过渡转场，是时候撸一撸第二阶段的了。第二阶段是有闭合到打开的状态。</p><p>在 setStartPositionForPush(_:toVC:)) 方法下添加如下代码：</p><pre data-language="Swift"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setEndPositionForPush</span><span class="hljs-params">(fromVC: BooksViewController, toVC: BookViewController)</span></span> {
  <span class="hljs-comment">//1</span>
  <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> fromVC.collectionView!.visibleCells() <span class="hljs-keyword">as</span>! [<span class="hljs-type">BookCoverCell</span>] {
    cell.alpha = <span class="hljs-number">0</span>
  }
 
  <span class="hljs-comment">//2</span>
  <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> toVC.collectionView!.visibleCells() <span class="hljs-keyword">as</span>! [<span class="hljs-type">BookPageCell</span>] {
    cell.layer.transform = transforms[cell]!
    cell.updateShadowLayer(animated: <span class="hljs-literal">true</span>)
  }
}
</code></pre><p>分析一下上面的代码：</p><ul><li>1.隐藏所有书的封面，因为我们将展示选中书籍的页面。</li><li>2.遍历所有页面然后加载之前保存的打开状态下的 transform</li></ul><p>当你从 BooksViewController push 到 BookViewController 之后，还原之前的一些设置。</p><p>加入以下代码：</p><pre data-language="Swift"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cleanupPush</span><span class="hljs-params">(fromVC: BooksViewController, toVC: BookViewController)</span></span> {
  <span class="hljs-comment">// Add background back to pushed view controller</span>
  toVC.collectionView?.backgroundColor = toViewBackgroundColor
}
</code></pre><p>push 完成后将 BookViewController 的背景色设置为你之前保存的背景色，将下面所有东西都隐藏起来。</p><h2>实现开书转场</h2><p>上面所有工具方法已经整装待发，接着我们来实现 push 动画。将下面代码加到 animateTransition(_:) 中：</p><pre data-language="Swift"><code><span class="hljs-comment">//1</span>
<span class="hljs-keyword">let</span> container = transitionContext.containerView()
<span class="hljs-comment">//2</span>
<span class="hljs-keyword">if</span> isPush {
  <span class="hljs-comment">//3</span>
  <span class="hljs-keyword">let</span> fromVC = transitionContext.viewControllerForKey(<span class="hljs-type">UITransitionContextFromViewControllerKey</span>) <span class="hljs-keyword">as</span>! <span class="hljs-type">BooksViewController</span>
  <span class="hljs-keyword">let</span> toVC = transitionContext.viewControllerForKey(<span class="hljs-type">UITransitionContextToViewControllerKey</span>) <span class="hljs-keyword">as</span>! <span class="hljs-type">BookViewController</span>
  <span class="hljs-comment">//4</span>
  container.addSubview(toVC.view)
 
  <span class="hljs-comment">// Perform transition</span>
  <span class="hljs-comment">//5</span>
  <span class="hljs-keyword">self</span>.setStartPositionForPush(fromVC, toVC: toVC)
 
  <span class="hljs-type">UIView</span>.animateWithDuration(<span class="hljs-keyword">self</span>.transitionDuration(transitionContext), delay: <span class="hljs-number">0.0</span>, usingSpringWithDamping: <span class="hljs-number">0.7</span>, initialSpringVelocity: <span class="hljs-number">0.7</span>, options: <span class="hljs-literal">nil</span>, animations: {
    <span class="hljs-comment">//6</span>
    <span class="hljs-keyword">self</span>.setEndPositionForPush(fromVC, toVC: toVC)
    }, completion: { finished <span class="hljs-keyword">in</span>
      <span class="hljs-comment">//7</span>
      <span class="hljs-keyword">self</span>.cleanupPush(fromVC, toVC: toVC)
      <span class="hljs-comment">//8</span>
      transitionContext.completeTransition(finished)
  })
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">//POP</span>
}
</code></pre><p>下面解释一下上面代码做了哪些事：</p><ul><li>1.获取容器视图，它在转场过程中充当父视图角色。</li><li>2.判断当前是执行 push 操作</li><li>3.获取 fromVC 和 toVC</li><li>4.将 toVC 加入到当前容器视图</li><li>5.设置闭合状态下 toVC 和 fromVC 的起始位置</li><li>6.从起始位置做动画，直到终点位置</li><li>7.还原设置</li><li>8.告知系统转场已完成</li></ul><h2>在导航控制器中使用 push 转场</h2><p>上面我们已经实现了 push 转场动画，是时候来使用它了。打开 BooksViewController.swift 将下面属性添加到类声明之后：</p><pre data-language="Swift"><code><span class="hljs-keyword">var</span> transition: <span class="hljs-type">BookOpeningTransition?</span>
</code></pre><p>这个属性是转场类实例，它帮助你判断当前转场是 push 还是 pop。添加如下扩展：</p><pre data-language="Swift"><code><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">BooksViewController</span> </span>{
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">animationControllerForPresentController</span><span class="hljs-params">(vc: UIViewController)</span></span> -&gt; <span class="hljs-type">UIViewControllerAnimatedTransitioning?</span> {
  <span class="hljs-comment">// 1</span>
  <span class="hljs-keyword">var</span> transition = <span class="hljs-type">BookOpeningTransition</span>()
  <span class="hljs-comment">// 2</span>
  transition.isPush = <span class="hljs-literal">true</span>
  <span class="hljs-comment">// 3</span>
  <span class="hljs-keyword">self</span>.transition = transition
  <span class="hljs-comment">// 4</span>
  <span class="hljs-keyword">return</span> transition
  }
}
</code></pre><ul><li>1.创建一个 transition</li><li>2.设置 isPush 为 true</li><li>3&amp;4.保存当前 transition，返回 transition</li></ul><p>接着打开 CustomNavigationController.swift 用下面代码替换 push 的 if 判断</p><pre data-language="Swift"><code><span class="hljs-keyword">if</span> operation == .<span class="hljs-type">Push</span> {
  <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> vc = fromVC <span class="hljs-keyword">as</span>? <span class="hljs-type">BooksViewController</span> {
    <span class="hljs-keyword">return</span> vc.animationControllerForPresentController(toVC)
  }
}
</code></pre><p>这一步判断判断是否从 BooksViewController 中 push 过来的，然后用你创建的 BookOpeningTransition 来做转场展示你的 BookViewController。</p><p>运行，选中某本书你会看到，书本在开、合之间的动画非常顺畅。</p><img src="/oldimages/VN_PushGlitch.gif"/><p>WTF...这货看起来没有动画？！</p><img src="/oldimages/angry-desk-flip.png"/><p>它直接从闭合状态跳转到打开状态，不要慌，这是因为你还没有加载页面 cell。 导航控制器从 BooksViewController 过渡到 BookViewController，他们两个都是继承自 UICollectionViewController。UICollectionViewCell 没有在主线程中加载，所以没有动画过程。 你需要给 collectionView 足够的时间让它来加载所有的 cell。 打开 BooksViewController.swift 然后使用下面代码替换 openBook(_:)：</p><pre data-language="ObjectiveC"><code>func openBook(book: Book?) {
  let vc = storyboard?.instantiateViewControllerWithIdentifier(<span class="hljs-string">"BookViewController"</span>) as! BookViewController
  vc.book = selectedCell()?.book
  <span class="hljs-comment">//1</span>
  vc.view.snapshotViewAfterScreenUpdates(<span class="hljs-literal">true</span>)
  <span class="hljs-comment">//2</span>
  <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), { () -&gt; Void <span class="hljs-keyword">in</span>
    <span class="hljs-keyword">self</span>.navigationController?.pushViewController(vc, animated: <span class="hljs-literal">true</span>)
    <span class="hljs-keyword">return</span>
  })
}
</code></pre><p>下面说下是如何解决这个问题的：</p><ul><li>1.当转场要发生时告诉 BookViewController 去截取当前视图</li><li>2.确定是在主线程中 push，来给 cell 足够的时间进行加载</li></ul><p>运行程序，应该和下图类似：</p><img src="/oldimages/VN_PushGlitchAnimate.gif"/><p>看起来更完美了。至此 push 的转场已经完成，继续撸 pop 的转场。</p><h2>实现 Pop 转场的工具方法</h2><p>pop 的过程和 push 过程刚好相反。第一阶段是书打开状态，第二阶段是书本闭合状态。</p><img src="/oldimages/VN_PopState.png"/><p>打开 BookOpeningTransition.swift 添加如下代码：</p><pre data-language="Swift"><code><span class="hljs-comment">// MARK: Pop methods</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setStartPositionForPop</span><span class="hljs-params">(fromVC: BookViewController, toVC: BooksViewController)</span></span> {
  <span class="hljs-comment">// Remove background from the pushed view controller</span>
  toViewBackgroundColor = fromVC.collectionView?.backgroundColor
  fromVC.collectionView?.backgroundColor = <span class="hljs-literal">nil</span>
}
</code></pre><p>该方法存储了 BookViewController 的背景色然后移除了 BooksViewController 中 collectionView 的背景色。我们不需要设置任何的 transform，因为书本当前状态就是打开状态。 接下来添加如下代码到上述代码之后：</p><pre data-language="Swift"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setEndPositionForPop</span><span class="hljs-params">(fromVC: BookViewController, toVC: BooksViewController)</span></span> {
  <span class="hljs-comment">//1</span>
  <span class="hljs-keyword">let</span> coverCell = toVC.selectedCell()
  <span class="hljs-comment">//2</span>
  <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> toVC.collectionView!.visibleCells() <span class="hljs-keyword">as</span>! [<span class="hljs-type">BookCoverCell</span>] {
    <span class="hljs-keyword">if</span> cell != coverCell {
      cell.alpha = <span class="hljs-number">1</span>
    }
  }      
  <span class="hljs-comment">//3</span>
  <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> fromVC.collectionView!.visibleCells() <span class="hljs-keyword">as</span>! [<span class="hljs-type">BookPageCell</span>] {
    closePageCell(cell)
  }
}
</code></pre><p>该方法设置 pop 转场的最终状态：</p><ul><li>1.获取当前选中书本的封面</li><li>2.在书本闭合状态，遍历 BooksViewController 所有书本封面，然后渐显</li><li>3.遍历 BookViewController 中所有的 cell，然后将它们转换成闭合态</li></ul><p>然后加入以下代码：</p><pre data-language="Swift"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cleanupPop</span><span class="hljs-params">(fromVC: BookViewController, toVC: BooksViewController)</span></span> {
  <span class="hljs-comment">// Add background back to pushed view controller</span>
  fromVC.collectionView?.backgroundColor = <span class="hljs-keyword">self</span>.toViewBackgroundColor
  <span class="hljs-comment">// Unhide the original book cover</span>
  toVC.selectedCell()?.alpha = <span class="hljs-number">1</span>
}
</code></pre><p>该方法在 pop 转场结束后做了一些还原工作。主要是将 BooksViewController 的 collectionView 的背景色还原成之前的状态，以及展示之前的书本封面。 把下面代码加到代理方法 animateTransition(_:) 中的 带有 <code>//POP</code> 注释的 else 大括号内。</p><pre data-language="Swift"><code><span class="hljs-comment">//1</span>
<span class="hljs-keyword">let</span> fromVC = transitionContext.viewControllerForKey(<span class="hljs-type">UITransitionContextFromViewControllerKey</span>) <span class="hljs-keyword">as</span>! <span class="hljs-type">BookViewController</span>
<span class="hljs-keyword">let</span> toVC = transitionContext.viewControllerForKey(<span class="hljs-type">UITransitionContextToViewControllerKey</span>) <span class="hljs-keyword">as</span>! <span class="hljs-type">BooksViewController</span>
 
<span class="hljs-comment">//2</span>
container.insertSubview(toVC.view, belowSubview: fromVC.view)
 
<span class="hljs-comment">//3</span>
setStartPositionForPop(fromVC, toVC: toVC)
<span class="hljs-type">UIView</span>.animateWithDuration(<span class="hljs-keyword">self</span>.transitionDuration(transitionContext), animations: {
  <span class="hljs-comment">//4</span>
  <span class="hljs-keyword">self</span>.setEndPositionForPop(fromVC, toVC: toVC)
}, completion: { finished <span class="hljs-keyword">in</span>
  <span class="hljs-comment">//5</span>
  <span class="hljs-keyword">self</span>.cleanupPop(fromVC, toVC: toVC)
  <span class="hljs-comment">//6</span>
  transitionContext.completeTransition(finished)
})
</code></pre><p>下面解释下 pop 转场动画的工作原理：</p><ul><li>1.获取转场过程中的控制器。fromVC 现在变成了 BookViewController，toVC 变成了 BooksViewController。</li><li>2.在 containerView 中把 BooksViewController 的视图放置到 BookViewController 视图下面。</li><li>3.setStartPositionForPop(_:toVC) 方法存储了背景色</li><li>4.用动画形式将书本有打开状态转换到闭合状态</li><li>5.动画完成则做还原设置，将背景色设置为之前保存的，然后显示书本封面</li><li>6.通知转场完成</li></ul><h2>在导航控制器中使用 pop 转场</h2><p>现在让我们像之前添加自定义 push 动画那样将 pop 动画也加入到代理方法中去。 打开 BooksViewController.swift 然后在 animationControllerForPresentController(_:) 方法后添加如下代码：</p><pre data-language="Swift"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">animationControllerForDismissController</span><span class="hljs-params">(vc: UIViewController)</span></span> -&gt; <span class="hljs-type">UIViewControllerAnimatedTransitioning?</span> {
  <span class="hljs-keyword">var</span> transition = <span class="hljs-type">BookOpeningTransition</span>()
  transition.isPush = <span class="hljs-literal">false</span>
  <span class="hljs-keyword">self</span>.transition = transition
  <span class="hljs-keyword">return</span> transition
}
</code></pre><p>这个方法同样创建一个 BookOpeningTransition 实例，唯一不同的是其 transition 设置为 pop。 打开 CustomNavigationController.swift 用下面代码替换之前的 if 逻辑：</p><pre data-language="Swift"><code><span class="hljs-keyword">if</span> operation == .<span class="hljs-type">Pop</span> {
  <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> vc = toVC <span class="hljs-keyword">as</span>? <span class="hljs-type">BooksViewController</span> {
    <span class="hljs-keyword">return</span> vc.animationControllerForDismissController(vc)
  }
}
</code></pre><p>它返回一个 transition，然后执行 pop 动画来把书合上。 运行程序，选中一本书，看下它的打开和闭合状态，应该和下图类似：</p><img src="/oldimages/VN_OpenAndClose.gif"/><h2>创建一个可交互的导航控制器</h2><p>打开和关闭转场动画看起来非常屌，但是你可以做得更好。你可以使用 pinch 手势来控制书的开、合。 首先打开 BookOpeningTransition.swift 添加如下属性：</p><pre data-language="Swift"><code><span class="hljs-comment">// MARK: Interaction Controller</span>
<span class="hljs-keyword">var</span> interactionController: <span class="hljs-type">UIPercentDrivenInteractiveTransition?</span>
</code></pre><p>接着打开 CustomNavigationController.swift 然后添加如下代码：</p><pre data-language="Swift"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">navigationController</span><span class="hljs-params">(navigationController: UINavigationController, interactionControllerForAnimationController animationController: UIViewControllerAnimatedTransitioning)</span></span> -&gt; <span class="hljs-type">UIViewControllerInteractiveTransitioning?</span> {
  <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> animationController = animationController <span class="hljs-keyword">as</span>? <span class="hljs-type">BookOpeningTransition</span> {
    <span class="hljs-keyword">return</span> animationController.interactionController
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}
</code></pre><p>上述方法返回一个可交互的动画对象。它使得导航控制器控制着整个动画过程，这样用户就可以使用 pinch 手势来控制书本的开、合。 打开 BooksViewController.swift 在transition 变量下添加如下属性：</p><pre data-language="Swift"><code><span class="hljs-comment">//1</span>
<span class="hljs-keyword">var</span> interactionController: <span class="hljs-type">UIPercentDrivenInteractiveTransition?</span>
<span class="hljs-comment">//2</span>
<span class="hljs-keyword">var</span> recognizer: <span class="hljs-type">UIGestureRecognizer?</span> {
  <span class="hljs-keyword">didSet</span> {
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> recognizer = recognizer {
      collectionView?.addGestureRecognizer(recognizer)
    }
  }
}
</code></pre><p>下面解释为什么要添加这几个变量：</p><ul><li>1.interactionController 是一个 UIPercentDrivenInteractiveTransition 实例，它管理 VC 转场过程中自定义动画的出现和消失。这个可交互控制器同样依赖一个 transition animator。这个 animator 实现了 UIViewControllerAnimatorTransitioning 协议，你刚才创建的 BookOpeningTransition 就是干这件事的。iteractionController 可以控制 push 和 pop 的过程，如果想要了解更多细节可以参考<a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIPercentDrivenInteractiveTransition_class/index.html#//apple_ref/occ/instm/UIPercentDrivenInteractiveTransition/cancelInteractiveTransition">苹果官方文档</a>。</li><li>2.recognizer 是一个 UIGestureRecognizer 实例。你可以使用它来控制书本的开、合。</li></ul><p>在 BooksViewController 扩展中的 animationControllerForPresentController(_:) 方法中添加如下代码，将其放在 transition.isPush = true 这一行之后：</p><pre data-language="Swift"><code>transition.interactionController = interactionController
</code></pre><p>这行代码让自定义导航控制器知道使用那一个交互控制器。 同样把上面在添加到 animationControllerForDismissController(_:) 方法中 transition.isPush = false 之后。 紧接着在 viewDidLoad() 中加入下面一行代码：</p><pre data-language="Swift"><code>recognizer = <span class="hljs-type">UIPinchGestureRecognizer</span>(target: <span class="hljs-keyword">self</span>, action: <span class="hljs-string">"handlePinch:"</span>)
</code></pre><p>它初始化了一个 UIPinchGestureRecognizer 实例，这个 pinch 手势的 action 是 handlePinch(_:)。</p><p>现在我们来实现 handlePinch(_:) 这个方法：</p><pre data-language="Swift"><code><span class="hljs-comment">// MARK: Gesture recognizer action</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handlePinch</span><span class="hljs-params">(recognizer: UIPinchGestureRecognizer)</span></span> {
  <span class="hljs-keyword">switch</span> recognizer.state {
    <span class="hljs-keyword">case</span> .<span class="hljs-type">Began</span>:
      <span class="hljs-comment">//1</span>
      interactionController = <span class="hljs-type">UIPercentDrivenInteractiveTransition</span>()
      <span class="hljs-comment">//2</span>
      <span class="hljs-keyword">if</span> recognizer.scale &gt;= <span class="hljs-number">1</span> {
        <span class="hljs-comment">//3</span>
        <span class="hljs-keyword">if</span> recognizer.view == collectionView {
          <span class="hljs-comment">//4</span>
          <span class="hljs-keyword">var</span> book = <span class="hljs-keyword">self</span>.selectedCell()?.book
          <span class="hljs-comment">//5</span>
          <span class="hljs-keyword">self</span>.openBook(book)
        }
      <span class="hljs-comment">//6</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//7</span>
        navigationController?.popViewControllerAnimated(<span class="hljs-literal">true</span>)
      }        
    <span class="hljs-keyword">case</span> .<span class="hljs-type">Changed</span>:
      <span class="hljs-comment">//8</span>
      <span class="hljs-keyword">if</span> transition!.isPush {
        <span class="hljs-comment">//9</span>
        <span class="hljs-keyword">var</span> progress = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">max</span>(<span class="hljs-built_in">abs</span>((recognizer.scale - <span class="hljs-number">1</span>)) / <span class="hljs-number">5</span>, <span class="hljs-number">0</span>), <span class="hljs-number">1</span>)
        <span class="hljs-comment">//10</span>
	interactionController?.updateInteractiveTransition(progress)
	<span class="hljs-comment">//11</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//12</span>
	<span class="hljs-keyword">var</span> progress = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">max</span>(<span class="hljs-built_in">abs</span>((<span class="hljs-number">1</span> - recognizer.scale)), <span class="hljs-number">0</span>), <span class="hljs-number">1</span>)
        <span class="hljs-comment">//13</span>
	interactionController?.updateInteractiveTransition(progress)
      } 
    <span class="hljs-keyword">case</span> .<span class="hljs-type">Ended</span>:
      <span class="hljs-comment">//14</span>
      interactionController?.finishInteractiveTransition()
      <span class="hljs-comment">//15</span>
      interactionController = <span class="hljs-literal">nil</span>
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>
  }
}
</code></pre><p>对于 UIPinchGestureRecognizer，我们关心三种不同的状态：began，changed，end。</p><p><strong>begin状态</strong></p><ul><li>1.初始化一个 UIPercentDrivenInteractiveTransition 对象</li><li>2.判断 scale， 也就是 pinch 手势移动的距离，看起是否大于等于1</li><li>3.如果是，确保手势发生在 colletionView 当中</li><li>4.获取当前手势所作用的书脊</li><li>5.执行 push 转场动画，显示书籍页面</li><li>6.如果小于1</li><li>7.执行 pop 动画来展示书本封面</li></ul><p><strong>changed 状态</strong></p><ul><li>8.判断当前转场是否为 push</li><li>9.如果正 push 到 BookViewController，获取用户 pinch 手势的百分比。将 pinch 手势缩小为其原始值的 1/5，这样用户更加容易控制转场过程</li><li>10.根据之前计算的白封闭更新 transition 完成状态的百分比。</li><li>11.如果当前转场不是 push，那肯定是 pop</li><li>12.当使用 pinch 手势控制书本关闭时，缩放比一定是从1变到0</li><li>13.最后更新 transition 的进度</li></ul><p><strong>end 状态</strong></p><ul><li>14.通知系统用户转场交互已完成</li><li>15.将交互 controller 置为 nil</li></ul><p>最后，你需要实现 pinch-to-closed 状态。因此你需要将手势传递给 BookViewController，这样他就能自发进行 pop。</p><pre data-language="Swift"><code><span class="hljs-keyword">var</span> recognizer: <span class="hljs-type">UIGestureRecognizer?</span> {
  <span class="hljs-keyword">didSet</span> {
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> recognizer = recognizer {
      collectionView?.addGestureRecognizer(recognizer)
    }
  }
}
</code></pre><p>当你在 BookViewController 中设置好手势时，它会马上被加到 collectionView 中区，这样我们就可以在用户合上书本的时候追踪 pinch 手势。 下面需要在 BooksViewController 和 BookViewController 之间进行手势的传递。 打开 BookOpeningTransition.swift 添加下面一行代码到 cleanUpPush(_:toVC) 方法中，并且将它放在设置背景色之后：</p><pre data-language="Swift"><code><span class="hljs-comment">// Pass the gesture recognizer</span>
toVC.recognizer = fromVC.recognizer
</code></pre><p>当从 BooksViewController push 到 BookViewController后，你需要将手势回传。 加入下面代码到 cleanUpPop(_:toVC) 方法中，同样是放在设置背景色之后：</p><pre data-language="Swift"><code><span class="hljs-comment">// Pass the gesture recognizer</span>
toVC.recognizer = fromVC.recognizer
</code></pre><p>运行程序，选中任意一本书然后使用 pinch 手势来控制书本的开、合。</p><img src="/oldimages/VN_Pinching.gif"/><p>用 pinch 收拾来控制书本的开合显得非常自然，同样可以让界面更加简洁，我们不再需要导航栏上的返回按钮，是时候来清理它了。</p><p>如下图设置即可：</p><img src="/oldimages/Screen-Shot-2015-03-14-at-1.16.36-PM.png"/><p>继续运行，可以看到导航栏不复存在画面变得更加简洁！:]</p><img src="/oldimages/VN_BookOpening.gif"/><h2>何去何从</h2><p>你可以在此下载<a href="https://koenig-media.raywenderlich.com/uploads/2015/05/Part-2-Paper-Completed_Final.zip">完整代码</a>。在这系列教程中，你学会了如何使用自定义布局、自定义转场、使用手势来控制转场交互。 我希望你喜欢这篇教程并从中受益，我想在此感谢<a href="https://twitter.com/hegedus90">Attila Hegedüs</a>创建了这个碉堡的项目。 如有任何疑问，请在下面留言指出。</p></div><span>Tagged with: </span><ul class="tag-list"><li><a href="/tags/uicollectionview">UICollectionView</a></li><li><a href="/tags/翻译">翻译</a></li></ul></article></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>