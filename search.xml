<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[全新后台任务框架及最佳实践]]></title>
    <url>%2F2019%2F10%2F20%2FBackgroundTask%2F</url>
    <content type="text"><![CDATA[WWDC 19 专栏文章目录WWDC 2019 Session 707: Advances in App Background Execution 2010年 iOS4 时代，iOS 的多任务系统面世，至今已经9个年头，期间后台模式及场景也逐渐增多，这为开发者和用户带来了很多可能性。随着 iOS 版本的迭代，慢慢的越来越多的后台运行场景被苹果所支持。与此同时为了改善用户体验以及延长电池寿命，苹果对于应用后台任务有着比较严苛的限制及审核规则，只有特定使用场景，应用才可能在后台持续运行，比如导航、音乐播放，VoIP 等。如果我们的应用恰好符合后台模式的场景，那么应该怎样利用好这一点来给用户好的体验呢？相信通过这一集 Session，你心中应该会有一个比较明确的答案~ 概览目前苹果支持9种后台模式，具体类型可使用 Xcode 的 Capabilities 来查看，如下图所示 通过上图对比可以看到 Xcode11 将 Newsstand downloads 这种后台模式移除，并新增了一个 Background processing(后面会具体说)。这些后台模式都有 API 与之对应，苹果在设计后台任务相关 API 时，将以下3点作为主要考虑因素来确保流畅的用户体验。 电池 电量几乎时刻都在被消耗，那么如何保证后台任务尽可能的减小电量的消耗呢？答案就是在后台任务完成时及时调用对应的 completion 通知系统任务已结束，以此来减小电量的消耗。 性能 在日常使用情况下，手机上通常同时运行着多个应用，某个应用在前台时，其它的应用在后台。在资源有限的情况下，为了保证设备尽可能的流畅，系统会为每个应用智能分配 CPU 及内存的阈值，一旦应用超过对应阈值，将会被系统终止。我们日常开发中发生的 OOM(Out Of Memory) 以及主线程长时间未响应而触发系统的“看门狗”，都是由于应用耗尽了系统分配的资源而被系统终止。 延展阅读触发“看门狗”通常会生成一份 Crash 日志，日志内容类似下面这样，经典的 0x8badf00dException Type: EXC_CRASH (SIGKILL)Exception Codes: 0x0000000000000000, 0x0000000000000000Exception Note: EXC_CORPSE_NOTIFYTermination Reason: Namespace SPRINGBOARD, Code 0x8badf00dTermination Description: SPRINGBOARD, process-launch watchdog transgression: com.xxxx exhausted real (wall clock) time allowance of 20.00 seconds | | ProcessVisibility: Unknown | ProcessState: Running | WatchdogEvent: process-launch | WatchdogVisibility: Foreground | WatchdogCPUStatistics: ( | “Elapsed total CPU time (seconds): 2.910 (user 2.910, system 0.000), 7% CPU”, | “Elapsed application CPU time (seconds): 0.000, 0% CPU” | )Triggered by Thread: 0如果对系统 Crash 日志感兴趣，可以看看我去年写的这篇文章 WWDC 2018：理解崩溃以及崩溃日志 大部分 OOM 的情况下一般会生成一份 JetsamEvent 开头的日志文件，可在设备的 设置-&gt;隐私-&gt;分析 中查看到，里面的内容会有崩溃现场的一些进程信息以及内存分配情况。更多关于 JetsamEvent 的介绍，可以查看这篇文章 iOS内存abort(Jetsam) 原理探究。 隐私 由于应用在执行后台任务时，用户是无感的，但是用户对于自己的隐私信息是敏感的，所以在相关 API 的设计时会告知用户，哪些数据会被使用。从今年的 WWDC 的动作来看，苹果对用户的隐私越来越重视，这点非常值得称赞，比如今年推出的 Sign In With Apple、地理位置权限的变更、后台地理位置访问的弹窗等。当然，这不是开始也不是结束，为苹果爸爸点赞👍。 最佳实践了解了后台任务相关 API 的设计初衷，是时候来看看如何实践才能保证流畅的用户体验以及延长电池寿命。 想象一下一个类似微信的即时通讯软件拥有的一些功能：即时消息、勿扰模式、VoIP、历史记录下载等，对于这些功能，结合系统提供的各种后台任务应用场景，该以何种姿势使用这些 API 呢？且往下看~ 即时消息即时消息肯定需要确保时效性，尽可能快的触达对方才能保证良好的用户体验。但是某些情况下（比如较差网络环境），不一定能马上将消息发送到对方，此时用户可能切回到桌面或者其它应用，那么如何才能保证发送消息这个操作完成呢？答案就是使用 Background Task Completion 相关 API。 123456789101112131415161718192021222324252627// Guarding Important Tasks While App is Still in the Foregroundfunc send(_ message: Message) &#123; let sendOperation = SendOperation(message: message) var identifier: UIBackgroundTaskIdentifier! // 1 identifier = UIApplication.shared.beginBackgroundTask(expirationHandler: &#123; // 2 sendOperation.cancel() postUserNotification("Message not sent, please resend") // Background task will be ended in the operation's completion block below &#125;) sendOperation.completionBlock = &#123; // 3 UIApplication.shared.endBackgroundTask(identifier) &#125; operationQueue.addOperation(sendOperation) &#125;``` 让我们依次看看上面标注的步骤：1. 应用在前台时通过对应 API 创建一个后台任务，此时即使 app 进入后台，也会获得一定的时间来处理消息发送。2. 在系统给出的时间内还没有处理完，应用即将被挂起，则取消发送，同时本地 push 通知用户。3. 如果发送成功，则通知系统该任务已结束，以此降低对电量的消耗。&gt; 如果是 `Extension`，可以使用 `ProcessInfo.performExpiringActivity(withReason:using:)`。相信这种方式大家或多或少都用过，有些应用甚至用这个接口去做所谓的“保活”。但是这里要提醒大家注意一个点（说多了都是泪），**就是 task 的 begin 和 end 的调用要对应**，你会踩到我踩过的坑：没有成对调用的 `task` 会触发 `0x8badf00d` 看门狗。但是这里的 `Crash` 堆栈和上面说的的主线程卡太久而被强杀的堆栈是不一样的，具体可以看看这篇文章的分析：[**iOS App 后台任务的坑**](http://mrpeak.cn/blog/ios-background-task/)。### 电话有些时候会觉得打字麻烦而直接打电话，系统同样也提供了对应的 API————VoIP 通知。它是一种特殊的通知类型，可以唤起应用，提醒用户有电话呼入，代码实现起来也比较简单```Swiftfunc registerForVoIPPushes() &#123; self.voipRegistry = PKPushRegistry(queue: nil) self.voipRegistry.delegate = self self.voipRegistry.desiredPushTypes = [.voIP]&#125; 同时必须在 didReceiveIncomingPush 回调中使用 CallKit 来处理 VoIP push 通知，否则系统会“杀”掉应用，并且系统可能在收到 VoIP 通知时不再唤起应用，示例代码如下： 123let provider = CXProvider(configuration: providerConfiguration) func pushRegistry(_ registry: PKPushRegistry, didReceiveIncomingPushWith payload: PKPushPayload, for type: PKPushType, completion: @escaping () -&gt; Void) &#123; if type == .voIP &#123; if let handle = payload.dictionaryPayload["handle"] as? String &#123; let callUpdate = CXCallUpdate() callUpdate.remoteHandle = CXHandle(type: .phoneNumber, value: handle) let callUUID = UUID() provider.reportNewIncomingCall(with: callUUID, update: callUpdate) &#123; _ in completion() &#125; establishConnection(for: callUUID) &#125; &#125; &#125; 同时以下几点也可以关注一下： payload 中填充尽可能多的信息，以便展示更加完善的 UI（当然不能超过其限制）。 因为电话的实时性很高，payload 中的 apns-expiration 的值尽可能小或者为0，以便通知能立即触发。 如果不想要类似系统电话的全屏 UI，也可以使用标准的推送 API 来触发 banner 样式。 如果想要自定义 push 内容，则可以使用 Notification Service Extension，比如想要做一些加密操作。 由于笔者没有实际使用过 VoIP 相关技术，所以这里推荐大家看看苹果的官方文档 VoIP 最佳实践 以及闲鱼技术团队写的这篇文章iOS VoIP电话：CallKit与PushKit的应用 勿扰模式聊完 VoIP，我们紧接着看看勿扰模式的最佳实践。微信中通常聊天列表里躺着几十个甚至上百个会话，有些活跃的群可能一天有上千条信息，如果一直收到 push，肯定会不胜其烦。所以一般都会对这个群开启消息免打扰模式，但是又不想错过重要信息（比如被别人@）。那么这种勿扰模式，在后台模式下该如何实现呢？使用静默推送！~ 静默推送可以在用户无感知的情况下，将数据推送到设备上。只需要将 push payload 里的 content-available 的值设置为 1，同时 payload 中不要包含 alert、sound、badge 字段，示例如下： 示例摘抄自 Creating the Remote Notification Payload Listing 7-1 1234567&#123; "aps" : &#123; "content-available" : 1 &#125;, "acme1" : "bar", "acme2" : 42&#125; 当收到静默推送后，系统出于对电池寿命和性能的保证，会智能地在后台唤起应用去下载相关内容。 下图还是以消息免打扰为例，用户在前台对某个会话开启了消息免打扰，然后回到后台，一段时间后该会话有新的内容，但是用户开了勿扰模式，所以我们需要“偷偷地”更新会话内容，但是用户却无感知。这里“偷偷地”就是系统在收到静默推送时，会在合适的时机在后台唤起应用去加载该会话的新内容（该后台任务可以持续30秒）。等用户回到前台，会发现免打扰的会话里的内容也有了更新，极大提高了用户体验。 关于静默推送的其它几点 tips： 必须将 apns-priority 设置为 5，否则系统不会唤起应用。 watchOS 应用必须（其它平台则强烈推荐）将 apns-push-type 设置为 background。 以上涉及到 payload 里的相关字段的设置，其实是在向 APNs 服务器发起请求时，请求体里的相关字段，更多内容可参考Sending Notification Requests to APNs关于最后一点需要稍微吐槽一下，这集 Session Keynote 上是说 watchOS 必须设置，其它平台强烈推荐设置。但是官方文档却说从 iOS13 和 watchOS6 起，这个 key 必须设置，建议还是以文档为准。 关于推送测试，推荐一下这个工具 Knuff 历史记录下载当我们在新设备上登录时，会同步历史聊天列表，对于一些比较久远的会话记录，我们可以使用后台下载任务（Background URL Session）将其延迟下载。其实不仅仅是会话列表可以延迟放到后台任务去同步，其他的一些任务也是可以的，比如数据统计、照片备份等。不过是否放在后台任务去执行，还是需要结合时效性以及性能稳定性来决定。 后台下载任务示例代码如下： 123456789// 配置任务let config = URLSessionConfiguration.background(withIdentifier: "com.app.attachments") let session = URLSession(configuration: config, delegate: ..., delegateQueue: ...) // 设置这个值为 true，告诉系统在合适的时机触发相应任务来保证良好的性能// 如果任务比较耗时，建议将这个值设为 trueconfig.discretionary = true// 设置超时时间 config.timeoutIntervalForResource = 24 * 60 * 60 config.timeoutIntervalForRequest = 60 // 创建请求 var request = URLRequest(url: url) request.addValue("...", forHTTPHeaderField: "...") let task = session.downloadTask(with: request)// 设置最早触发时间task.earliestBeginDate = Date(timeIntervalSinceNow: 2 * 60 * 60) // 设置期望的发送和接收的数据包大小 task.countOfBytesClientExpectsToSend = 160 task.countOfBytesClientExpectsToReceive = 4096 task.resume() 更多信息可以查看Downloading Files in the Background。这里值得注意的是，如果在后台任务下载过程中应用被系统终止，再次启动时，使用相同 identifier 创建的 session 系统将会从上一次终止的地方继续下载对应内容。但是如果用户手动通过多任务将应用终止的话，系统会取消所有后台下载任务，同时系统也不会自动在后台唤起应用。 通过上面的四种场景分析，系统分别为我们提供了不同场景下该使用的 API，以及对应的最佳实践。当然还有一些场景上面例子并没有涉及，比如 Background Fetch、Background Processing。某些特定的后台任务需要在 Xcode 的 Signing &amp; Capabilities（Xcode 10 为 Capabilities）中勾选才能生效，具体如下图所示。 而我们上面提到的 VoIP 电话和静默推送需要将 Voice over IP 和 Remote notifications 选项勾起来。 全新后台任务框架以上场景都有对应的 API 可用，但是对于其它场景呢？比如数据同步、照片备份、数据库清理等，有没有更便捷的方式呢？当然，且看 iOS13 推出的全新框架 BackgroundTasks.framework~ 如本文题图那样，BackgroundTasks.framework 是一个全新的后台任务调度框架，同时对iOS、iPadOS、watchOS、tvOS 以及 Mac 上的 iPad 应用都支持。同样 iOS13 新增了一种后台模式 Background processing，同时对现有的后台刷新相关 API 进行了改善。 进到这个框架的类 API，会发现这个框架十分简洁，两种后台任务分别对应的类为 BGProcessingTask 和 BGAppRefreshTask，这两个类都是继承自一个抽象类 BGTask，然后再配合对应的BGTaskRequest 以及 BGTaskScheduler，就可以满足大部分后台任务的需求。 相关 API 一览： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// task@available(iOS 13.0, *)open class BGTask : NSObject &#123; open var identifier: String &#123; get &#125; open var expirationHandler: (() -&gt; Void)? open func setTaskCompleted(success: Bool)&#125;@available(iOS 13.0, *)open class BGProcessingTask : BGTask &#123;&#125;@available(iOS 13.0, *)open class BGAppRefreshTask : BGTask &#123;&#125;// request@available(iOS 13.0, *)open class BGTaskRequest : NSObject, NSCopying &#123; open var identifier: String &#123; get &#125; open var earliestBeginDate: Date?&#125;@available(iOS 13.0, *)open class BGAppRefreshTaskRequest : BGTaskRequest &#123; public init(identifier: String)&#125;@available(iOS 13.0, *)open class BGProcessingTaskRequest : BGTaskRequest &#123; public init(identifier: String) open var requiresNetworkConnectivity: Bool open var requiresExternalPower: Bool&#125;// scheduler@available(iOS 13.0, *)open class BGTaskScheduler : NSObject &#123; open class var shared: BGTaskScheduler &#123; get &#125; open func register(forTaskWithIdentifier identifier: String, using queue: DispatchQueue?, launchHandler: @escaping (BGTask) -&gt; Void) -&gt; Bool open func submit(_ taskRequest: BGTaskRequest) throws open func cancel(taskRequestWithIdentifier identifier: String) open func cancelAllTaskRequests() open func getPendingTaskRequests(completionHandler: @escaping ([BGTaskRequest]) -&gt; Void)&#125; BGProcessingTask首先来看看今年新提供的后台模式————Background Processing Task。 这种后台模式会给应用几分钟的时间来处理相关任务，相比之前的几十秒有了比较大的提升。因此我们可以将一些可延迟到后台执行的任务放到这种模式下执行，也可以将一些 Core ML 的训练放到这种模式下执行。 最重要的一点是，新框架允许我们关掉 CPU 的检测，因为之前系统出于对电池寿命的考虑，会将后台 CPU 占用较高的应用“杀死”，所以新框架的这个特性对于那些 CPU 占用较高的后台任务可以说是及时雨了，而要做到这个，仅仅只需要设置 bgProcessingTaskRequest.requiresExternalPower = true 即可。 同时我们只要需应用在前台时提交了对应请求，系统就会在适当的时机触发相应的任务。 BGAppRefreshTask了解完 BGProcessingTask，我们继续看一看 BGAppRefreshTask。 虽然是新 API，但是规则和之前的 Background Fetch一样：有30秒的执行时间、让应用内容保持最新。 会根据用户使用应用的频次和时间段，来决定何时触发后台刷新任务。比如用户经常在早上 8 点和晚上 10 点会打开应用，系统则会在这两个时间点之前触发刷新任务，以保证用户总是看到最新的内容。这也就意味着如果应用使用的频次较低，系统触发的刷新任务的频次也就随之变低。同时下面两个 API 被废弃了，虽然在iOS、iPadOS、tvOS 任能使用，但是在 Mac 上将无法使用，所以尽快切到新的 API 吧~ 123- (void)setMinimumBackgroundFetchInterval:(NSTimeInterval)minimumBackgroundFetchInterval API_DEPRECATED("Use a BGAppRefreshTask in the BackgroundTasks framework instead", ios(7.0, 13.0), tvos(11.0, 13.0));- (void)application:(UIApplication *)application performFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler API_DEPRECATED("Use a BGAppRefreshTask in the BackgroundTasks framework instead", ios(7.0, 13.0), tvos(11.0, 13.0)); 在我们提交了相应后台任务后，系统会根据一些条件和规则（比如电量、应用使用频次、网络等）来适时地触发对应任务。我们和系统交互，主要是通过 BGTaskScheduler 这个类。 如图所示，当应用或者 Extension 在前台通过 BGTaskScheduler 向系统提交后台任务请求（BGRequest）后（图中 1、2 所示），系统在条件满足的情况下会在后台唤起应用，然后将对应的后台任务（BBGTask）传给应用（上图步骤 3 所示）。值得一提的是，系统后台唤起应用后，可能同时将多个后台任务传给应用，系统会给这些任务一定的时间去执行，但这里分配的时间不是针对每个任务，而是针对每次后台唤起，所以必须保证在有限时间内能够同时处理所有任务。还有一点要注意的是，Extension 提交的任务请求，也会被分发到宿主应用，因为系统只会唤起宿主应用而不是 Extension。 Demo Time通过上面我们对新的框架有了一个宏观上的了解，苹果爸爸也十分贴心的为这集 Session 提供了 Demo。这里就不再详细展开，只指出值得注意的地方，感兴趣的同学可以自行下载 Demo 感受一下。 想要新框架对应的特性，必须勾选对应的后台模式， BGProcessingTask 对应 Background processing，BGAppRefreshTask 对应 Background fetch。Xcode11 的开启步骤如图所示。 代码中用到的任务标识符必须和 Info.plist 中的一致，否则任务不生效，如图所示。Info.plist 中对应的 key 为 Permitted background task scheduler identifiers，同时标识符要确保全局唯一，推荐使用反域名的方式。 如果任务会占用较高 CPU，强烈推荐将 requiresExternalPower 设置为 true。 任务请求提交后，任意位置设置断点或者暂停应用进到断点模式，输入以下两条指令来模拟触发任务以及提前终止任务，输入完成后，点击继续，会发现任务被正常触发或终止。仅真机有效。 12345// 模拟触发任务，TASK_IDENTIFIER 替换为想要测试的任务对应的标识e -l objc -- (void)[[BGTaskScheduler sharedScheduler] _simulateLaunchForTaskWithIdentifier:@"TASK_IDENTIFIER"]// 模拟终止任务，TASK_IDENTIFIER 替换为想要测试的任务对应的标识 e -l objc -- (void)[[BGTaskScheduler sharedScheduler] _simulateExpirationForTaskWithIdentifier:@"TASK_IDENTIFIER"] 不要把任务的最早开始日期(earliestBeginDate)设的太大，推荐在一周内。 确保文件在锁屏下可访问，最好将文件访问等级设置成 FileProtectionType.completeUntilFirstUserAuthentication，当然这也是 iOS7 之后系统的默认行为，设备重启到用户首次解锁的这段时间，后台任务不会被触发。 支持分屏的应用需要在合适的时机调用 UIApplication.requestSceneSessionRefresh(_:) 来告诉系统来更新多任务窗口下的应用截图。 不要在主线程上提交任务请求，尽量放到后台线程，避免阻塞 UI 到此整个新框架以及一些最佳实践都已经介绍完毕，各位是不是迫不及待想动手试试？心动不如行动，赶紧动手试试吧。Enjoy~ 个人想到的一些新框架可能适用的点（Keynote 上提到的机器学习的模型训练之类的就不再说了） 使用 BGAppRefreshTask 提前拉取应用首屏需要的内容，减少用户启动后的等待时间（之前的 background fetch 也能实现） 数据同步，尤其是大文件，像谷歌相册、各种云盘之类的软件 日志上报，一些不需要那么实时的日志，可以考虑放到后台任务 PS: 期待谷歌相册能适配一波，避免同步时一直得保持应用在前台😂]]></content>
      <categories>
        <category>框架学习</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>WWDC</tag>
        <tag>后台任务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WWDC 2018：使用日志框架测量性能]]></title>
    <url>%2F2019%2F02%2F22%2FWWDC-2018-Signpost%2F</url>
    <content type="text"><![CDATA[本文是 WWDC 2018 Session 405 的观后感，原视频和 pdf 可以在这里看到。首发于小专栏。 众所周知，应用交互的流畅度决定了用户对这款用户的喜爱度，所以对于每个 iOS 工程师而言，应用的流畅程度是非常重要的。而这里所说的流畅度在工程师层面来理解就是应用的性能是否处于一个比较优的状态。那我们在发现页面卡顿时，如何去检测卡顿是哪一段代码引起的呢？目前业界的卡顿检测已经非常多了，比如 Instrument 的 Time Profile，各种基于 runloop 的卡顿率检测开源库。但是今天主要来说一说 iOS12 苹果为我们带来的一个新的检测方案，也就是基于 OSLog 的一套新 API。 好了，题外话讲完，我们正式进入正题。该 Seesion 主要有下面几部分组成： 集成 signposts 异步并行操作 添加原数据 控制 signposts 的启用和禁用 使用 Instruments 分析 首先先简单回顾一下 OSLog，苹果在2016年推出这个现代化的日志记录框架，用来获取系统调试信息，这个框架主要是为效率而生。可以看一个简单实例 12let logHandle = OSLog(subsystem: "com.example.widget", category: "Setup")os_log(.info, log: logHandle, "Hello, %&#123;public&#125;s!", world) PS: 更多内容可以参看 WWDC 2016 Session 721 Unified Logging and Activity Tracing 这里要介绍的 Signpost 对 OSLog 进行了一些扩展，新增了一些用于衡量性能的 API。首先我们来看看如何在代码中集成 Signpost。 集成 Signpost使用 signpost 计算耗时想象一下我们有这样一个应用，包含了一组图片的 feed 流，滑动过程中，我们会去加载 feed 流的封面，页面如下图所示。我们想要获取每张封面的加载耗时，如果使用 Signpost 相关 API 我们需要如何做呢？使用 Signpost 我们可以标记每个任务的开始和结束，然后将他们关联起来，调用的相关 API 也比较简单，我们只需要做一个简单的打点，通过两个关联的打点，我们就可以记录这个任务的具体耗时，如下图所示。 伪代码如下 123456789101112// 引入 os 框架import os.signpost// 使用自定义标识和分类创建一个 log，subsystem 建议使用 bundle id，category 主要用于对相关联的操作进行分类let refreshLog = OSLog(subsystem: "com.example.your-app", category: "RefreshOperations")for element in panel.elements &#123; // 任务开始前打点 os_signpost(.begin, log: refreshLog, name: "Fetch Asset") fetchAsset(for: element) // 任务结束打点，注意 log 和 name 要和开始前的匹配，这样才会自动关联 os_signpost(.end, log: refreshLog, name: "Fetch Asset")&#125; 如果想要统计所有任务的耗时，也非常简单，只需要在 for 循环前后埋点即可，不过需要注意的一点是 name 的值，如上所述因为想要计算的所有任务的耗时，所以新起了一个值，来进行关联。代码如下 12345678let refreshLog = OSLog(subsystem: "com.example.your-app", category: "RefreshOperations")os_signpost(.begin, log: refreshLog, name: "Refresh Panel")for element in panel.elements &#123; os_signpost(.begin, log: refreshLog, name: "Fetch Asset") fetchAsset(for: element) os_signpost(.end, log: refreshLog, name: "Fetch Asset")&#125;os_signpost(.end, log: refreshLog, name: "Refresh Panel") 整个时间轴看起来如下图所示 异步任务耗时的计算如果我们的任务是一步步循序渐进的，上面的方式是没问题的，但是实际应用场景中，大部分任务是异步同时进行的。因此上面的 name 唯一标识在异步并行的场景下，不再能满足我们的需求，因为各任务的起始时间是一样的，但是结束时间肯定不一样，如果都用相同的 name 来做唯一标识，时间轴肯定会存在重叠的情况，因此无法区分各个任务的耗时时间。 因此为了解决上述问题，我们可以使用另一个 Signpost 的 API，叫做 signpost ID。通过 signpost ID，可以区分同种类型操作中的不同任务。所以即使两个任务时间轴有重叠，但是由于 signpost ID 的存在，系统就可以区分出这是两个不同的时间间隔，所以只要 .begin 和 .end 打点时传入的 ID 一致，系统就会把二者自动关联起来，计算耗时。代码如下： 12345678910111213let refreshLog = OSLog(subsystem: "com.example.your-app", category: "RefreshOperations")let spidForRefresh = OSSignpostID(log: refreshLog)os_signpost(.begin, log: refreshLog, name: "Refresh Panel", signpostID: spidForRefresh)for element in panel.elements &#123; let spid = OSSignpostID(log: refreshLog, object: element) os_signpost(.begin, log: refreshLog, name: "Fetch Asset", signpostID: spid) fetchAssetAsync(for: element) &#123; os_signpost(.end, log: refreshLog, name: "Fetch Asset", signpostID: spid) &#125;&#125;notifyWhenDone &#123; os_signpost(.end, log: refreshLog, name: "Refresh Panel", signpostID: spidForRefresh)&#125; signpost ID 可以通过 OSSignpostID 构建函数传入一个 log handler，以及任意一个对象（可选）。后面的 object 参数非常有用，因为只要传入的 object 是一样的，那么生成的 ID 也是一样的（当然前提是 log handler 也要一致）。 从上面示例我们可以得知，只要 .begin 和 .end 的其它参数是一致的，系统就会自动将其匹配，这样就可以在任何地方去进行“打点”。 所以整个 API 总结一下，大概是下面这样一个层级。 参数 示例 含义 Log category “RefreshOperations” 相关操作 Signpost name “Fetch Asset” 想要计算的某类操作 Signpost ID spid 同一类操作下的某个任务 添加自定义 Metadata看完上面部分，你可能会有个疑问：是否可以在 signpost 中携带一些额外信息呢？答案是肯定的。os_signpost 函数为我们提供了一些可选参数，用于传递上下文。传入的参数得是 os_log 格式的字符串，可以传入不同类型的参数以及动态字符串，最终这些字符串都会显示在 Instrument 中。 添加独立事件除了上面提到的自定义元数据，我们可能还想在 .begin 和 .end 之间记录一些特定的“点”，因此苹果给了我们一种新的类型，OSSignpostType.event。我们可以使用它来记录一些过程中的特定点，比如上面提到的图片加载的某个特定进度，或者记录加载过程中的用户点击行为等等。 12os_signpost(.event, log: log, name: "Fetch Asset", "Fetched first chunk, size %u", size)os_signpost(.event, log: log, name: "Swipe", "For action 0x%x", actionCode) Signpost 禁用及启用默认情况下，Signpost 是启用的，但是某些情况下，我们并不想开启它，比如 Release 模式下包或者提交到 Appstore 的包。苹果工程师一再强调 Signpost 本身非常轻量，同时在它被触发的时候也做了很多优化，同时在编译器层面也做了一些优化来确保它作用于运行时之前，把很多工作推迟到 Instrument 的处理时期，所以当它被触发时几乎不会消耗系统资源。所以为了可以根据条件来启/禁用 Signpost，系统提供了一个默认的 OSLog.disabled 的 log handler，使用此 log handler 创建的 Signpost，都会被禁用，所以只需几行代码就可以搞定是否需要开启 Signpost 的需求，亦即只需要根据条件修改 log handler 初始化方式即可。 123456let refreshLog: OSLogif ProcessInfo.processInfo.environment.keys.contains("SIGNPOSTS_FOR_REFRESH") &#123; refreshLog = OSLog(subsystem: "com.example.your-app", category: "RefreshOperations")&#125; else &#123; refreshLog = .disabled&#125; 当然，如果有一些 Signpost 代码如果比较耗时，我们也可以通过判断当前 log handler 是否被禁用来进行下一步操作。示例代码如下 12345// 如果获取 info 比较耗时，那可以先进行一次判断if refreshLog.signpostsEnabled &#123; let information = copyDescription() os_signpost(..., information)&#125; 以上示例代码都是用的 Swift，但是在 C 代码中，它们也是可以用的。对应关系如下图，如果需要了解更多，可以进到对应的头文件，查看其使用方式和相关说明。 与 Instruments 配合使用这一章节，苹果工程师以一个本地徒步旅行的应用（参照上面截图）作为示例，展示了如何使用 Signpost 进行埋点，然后通过 Instrument 获取埋点数据，进而来进行对埋点的耗时分析计算。 查看 Signpost 数据我们可以 Instruments(10) 来记录、查看和分析我们在上面说的所有的埋点。下面是 Demo 的一些相关背景： 通常情况下，我们为了性能优化，会把一些耗时任务放到异步线程，等任务完成后再回到主线程，这样就很难对其进行时间的测量分析。当用户滑动的时候，就会同时触发多个图片下载任务。如果用户滑动非常迅速，那么很多图片在 cell 被重用时可能还没有下载完成，所以我们就需要取消这些下载任务，如果我们没有取消的话，就会平白多出几个我们并不想要的下载任务。 cell 有一个 startImageDownload 方法用来下载图片，代码如下每个下载任务开始时，会根据图片名称创建 downloader，然后根据 downloader 创建一个 SignpostID 用来作为这个下载任务的 Signpost 数据唯一标识，然后通过将图片名称传入到元数据中。 然后图片下载完成的回调如下同样直接通过 downloader 创建一个 SignpostID，这样可以确保 .begin 和 .end 能够匹配。注意到这里传入的 metadata &quot;Finished with size %{xcode:size-in-bytes}llu&quot;，这里的 xcode:size-in-bytes 告诉 Xcode 和 Instrument 这个参数在分析和展示时要当做 bytes 来处理。它们被称为工程类型（engineering types），可以在Instruments Developer Help查看更多相关信息。 在 cell 被重用时，我们需要记录图片下载的 cancel 操作，代码如下处理类似，不再赘述。 通过 Xcode-&gt;Product-&gt;Profile(或者快捷键 cmd+I) 来启动 Instrument。然后选取一个空白（Blank）配置，进行下面操作 右上角 + 按钮，然后搜索 os_signpost，然后选中将其拖入到左边栏，然后点击 Record 即可。 一顿滑动之后，停止录制（Record），然后查看顶部面板，我们可以看到各个图片加载的耗时，以及我们在埋点时传入的元数据。同时后续时间的一些 signpost 数据如下从这张图我们可以看到同时下载数不超过5个，这样证明我们的 cancel 方法生效了。为了证明这一点，放大得到下图可以看到滑动过程中确实产生了很多 metadata 是 cancel 的 signpost 数据。 如果我们想要看图片下载耗时，我们能可以看底部数据栏Instrument 会按照 SignpostID 进行汇总，然后给出各项数据，比如个数、最大值、最小值、标准差、平均值。同一个 SignpostID 又分为 Finished 和 Cancel。还记得上面提到 size-in-bytes 么？这里每一个 Finished 后面都跟了一个这张图片的字节数。如果想用 metadata 数据进行分析，我们可以切到下图所示的分类。 Instrument 根据 log handler 的 subsystem、category、format string、arguments 各个参数进行了一个分层。因为我们在格式化字符串中只有一个参数，所以这里只展示了 arg0。然后会根据 size-in-bytes 类型，算出总加载大小以及最大值、最小值、标准差、平均值，所以通过它，我们可以快速分析一些元数据传入的数据。 前面提到为了保证 OSLog 的轻量性，大部分工作被推迟到 Instrument 来处理，所以如果我们在录制的时候采用即时模式(默认)，数据直接交由 Instrument 处理，它就会实时展示和记录相关数据。当我们触发的 signpost 足够多时，那么整个流程会变慢，甚至你的 App 和电脑都将变得卡顿。所以为了避免这种情况，在每次录制前，最好先更改它的录制模式。操作方式就是长按录制按钮，然后选择录制选项（Recording Options），然后在弹出的面板进行类似下图的操作，将默认的即使模式（Immediate Mode）更改为你想要的模式，示例中选的是最后5秒。 兴趣点如果我们只想简单记录一些点击事件，但是又不想让这些点击事件淹没在上面的大量 signpost 数据中，也不想每次都创建空白配置，然后自行添加 os_signpost 配置，那么我们就可以使用兴趣点(Points Of Interest)的方式。具体如何操作的呢？其实和其它的 signpost 类似，不过创建 log handler 时，category 参数要传入 .pointsOfInterest，这是一种会被 Instrument 自动识别的特殊分类。创建和使用代码示例如下图 运行 Instrument，然后选择 Time Profile 配置，该配置会自带兴趣点一栏的数据。 自定义 Instrument通过 Demo 演示了如何通过自定义 Instrument 来快速直接地进行记录和分析，展示面板基本类似上面的数据查看。至于如何创建自定义 Instrument，可以查看 Session 410 Creating Custom Instruments 来了解更多。 总结通过使用 signpost，我们可以轻易地记录时间段，捕获感兴趣的元数据，然后通过 Instruments 来查看和分析 signpost 数据，查看时间花在哪些地方，更清楚的了解到程序的行为。]]></content>
      <categories>
        <category>原创</category>
      </categories>
      <tags>
        <tag>WWDC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WWDC 2018：理解崩溃以及崩溃日志]]></title>
    <url>%2F2019%2F02%2F22%2FUnderstanding-Crash%2F</url>
    <content type="text"><![CDATA[本文首发于掘金。 人非圣贤，孰能无过。每个人在写代码的时候，或多或少都会犯错，那么如何调试、找出问题所在呢？让我们跟随苹果工程师一起了解一下崩溃是如何产生以及如何解决它们的吧。 1. 基础知识崩溃是什么？崩溃是当应用想要做某件事的时候，被意外终止。 1.1 崩溃为什么会发生主要是以下几方面原因 CPU 无法执行的代码。 被操作系统“强杀”，系统为了用户体验，会强制终止掉那些卡顿时间过长或者内存消耗过高的应用。 编程语言为了防止错误发生而触发的崩溃，如 NSArray 或者 Swift.Array 越界 开发者为了防止错误发生而触发的崩溃，比如一些非空判断的断言 1.2 崩溃长什么样子1.2.1 调试器里当我们连接着 Xcode 进行调试的时候，遇到崩溃，大概长这个样子。 当连着调试器的时候，我们能够拿到崩溃现场的一些调用栈以及对应的方法，当没有连着调试器的时候，系统会将崩溃日志存储到磁盘当中。 1.2.2 崩溃日志里通常情况下，release 模式的应用的崩溃日志是没有符号化的，日志内记录的都是地址。我们可以通过 Xcode 来将崩溃日志进行符号化，解析出对应文件名、方法名以及对应崩溃在第几行。 1.3 获取崩溃日志获取崩溃日志的方式很多，我们先来了解一下如何通过 Xcode Organizer 来获取从 TestFlight 或App Store 下载的应用的崩溃日志。 1.3.1 Organizer Window先来看一下下面这张图： 下面数字 1~6 分别代表图中标注的 1~6 1.可以看到所有平台发布在 App Store 或者 TestFlight 上的应用。 2.崩溃日志列表，可以看到对应影响的设备数以及对应的平台、扩展（extension），如图中蓝色框标注的位置。 3.崩溃所在调用栈及崩溃位置的高亮。 4.在对应工程中打开崩溃所在的文件，并跳转到指定位置，方便追踪问题。 5.最近数据分析，包含系统和机型两个维度。 6.在崩溃数较多时，支持翻页。 PS：上面6个只是简单介绍了一下主题部分，剩余的可以自行探索使用。比如搜索、对单个日志做一些笔记、以及将已修复的崩溃标记为已解决等等。 那么如何才能在 Organizer 中获取对应的崩溃日志呢？很简单，只需要做到下面几步 在 Xcode 中登录已付费的开发者帐号。 上传应用到 App Store 或 TestFlight 时，一并上传符号文件。 打开 Xcode Organizer 窗口，选中 Crashes tab(快捷键:Cmd+Shift+6)。 1.3.2 Devices Window 连接上设备，打开 Xcode，使用快捷键 Cmd+Shift+2 来打开 Devices Window，选中对应设备，然后选择 View Device Logs，即可查看当前设备磁盘上的所有崩溃文件，找到应用对应的日志即可展开分析。 有些时候，获取到的崩溃日志并没有符号化。这个时候需要自己做一些额外操作，这里可以参考我之前在知识小集分享过的一个小 tip——iOS快速解析崩溃日志。 1.3.3 其它途径 Xcode 的自动化测试（得到的是已符号化的日志） Mac 自带的 Console 应用，获取 Mac 或者模拟器的崩溃日志 iOS设备可通过这种操作获取，打开【设置】-&gt;【隐私】-&gt;【分析】-&gt;【分析数据】拿到对应的未符号化的崩溃日志，然后通过系统自带的分享即可传输到对应的设备上进行分析。 1.4 符号化最佳实践 上传应用的符号文件，以便苹果后台可以直接符号化崩溃日志，最终得以在 Xcode Organizer 的 Crashestab 中呈现。 保留应用归档文件，以便做本地符号化，只要有归档文件在，Xcode 会自动进行符号化。 在 Xcode Organizer 的 Archivetab 为已开启 bitcode 的应用下载 dSYM 文件。 2. 分析奔溃日志2.1 崩溃日志的组成 崩溃摘要，主要记录一些基本信息，比如机型、系统版本、崩溃时间等 崩溃原因 崩溃信息（这一部分在真机上处于隐私原因，一般都是不可见的，在模拟器和 MacOS 上可见） 崩溃线程的调用栈 崩溃发生时，其它线程的调用栈 寄存器状态 已加载的可执行二进制文件 2.2 如何分析首先从崩溃原因中的崩溃类型开始 如上图的崩溃类型为 EXC_BAD_INSTRUCTION，它代表 CPU 尝试在执行一段不存在或无效的代码，而导致进行被“杀死”。 然后我们可以找到崩溃线程的调用栈的前几行，结合崩溃信息（如果有的话）进一步分析。找到崩溃栈中第一处二进制名为应用名称所在那一行，进到对应文件对应的代码行数进行查看（如上图中标红的那一行），然后进一步分析。上图中的崩溃可以很明显看出其原因是对 nil 进行了强制解包。 2.3 断言和先决条件导致的崩溃断言和先决条件的意义在于当错误发生时，强制终止当前进程。 上述提到的对 nil 强制解包导致的崩溃是断言和先决条件中的一种。而它们还包含下面几种情况： 数据越界访问 算术溢出 未捕获的异常 代码中的自定义断言 2.4 操作系统“杀死”应用导致的崩溃某些情况下，系统处于保护目的，会将一些异常的应用“杀死”。以下几种场景可能触发系统将应用“杀死”： 看门狗事件，主线程长时间无响应 设备过度发烫 内存消耗殆尽 非法的应用签名 以上几种场景导致的崩溃，其崩溃日志可以在上面提到的 Device Window 中查看，Organizer Window 并不一定能够收集到这些日志。更多细节可以参考苹果的这个技术讲座 Understanding and Analyzing Application Crash Reports。 先来看一个关于看门狗的例子。 上面的崩溃类型为 EXC_CRASH (SIGKILL)，SIGKILL 一般代表的是系统终止了进程的运行，这种信号无法被应用捕获，进而也就无法处理。终止原因为 Namespace SPRINGBOARD, Code 0x8badf00d，如果你有查看上面提到的关于崩溃日志的讲座，你应该会知道 Code 0x8badf00d 代表什么。从终止描述中来看，是由于启动时长超过了 19.97 秒。 这次总算知道为什么看门狗对应的 code 是 0x8badf00d 了，从这次苹果工程师的发音上来看，这个 code 的发音同 ate bad food。 2.4.1 如何避免启动超时应用审核被拒的比较常见的原因就包含启动超时这一项。那么如何来避免这种情况发生呢？苹果工程师给了我们这些建议： 在真机上测试，因为看门狗在模拟器以及调试阶段是被禁用的 在低性能设备上测试，高性能设备响应肯定会快，无法体现出真实效果 2.4.2 如何避免内存问题常见的内存错误包含：过度释放、野指针（访问已释放对象）、内存访问越界（比如 C 数组）。我们还是通过一个日志来分析一下具体问题。 由上图中标注的1，我们知道崩溃类型为 EXC_BAD_ACCESS(SIGSEGV)，这种类型崩溃主要是有两种情况导致： 对只读的内存地址进行写操作 访问不存在的内存地址 通过崩溃栈中的objc_release、object_dispose 等，我们更加确定这是由于内存问题导致的崩溃。我们通过这几个线索可以知道，LoginViewController 实例在调用 deinit 方法销毁相关属性的时候，发生了内存问题，进而导致崩溃的产生。 我们回到日志的第一部分中的Exception Codes，苹果的工程师说可以根据经验以及日志中的相关信息得出结论，对应的 BAD_ADDRESS 为 0x7fdd5e70700。原因是 0x7fdd5e70700 刚好在日志中的这一段 MALLOC_TINY 00007fdd5e400000-00007fdd5e800000 地址范围内。 一些关于内存及释放的基础 Objective-C 对象以及一些 Swift 对象的内存布局如图，当一个对象有效（未释放）时以 isa 开始，isa 指向它所属的类。objc_release 主要是读取对象的 isa 指针，然后将 isa 指针解除对 Class 的引用。 正常情况下，一切都能照常工作。如果对象已经被释放，会发生什么呢？free 函数调用后，会将对象删除，并且将其插入到包含了其它已释放对象组成的链表中，同时将之前 isa 区域指向链表中下一个已释放对象。 当之前的 isa 内存区域被写入成 rotated free list 指针时，意味着访问这个地址返回的将是一个无效的内存地址，进而导致崩溃。所以当 objc_release 去解除 isa 引用时，访问到的是 rotated free list，所以崩溃就发生了。 所以可以分析出，肯定是在释放某个属性时，该属性已经被释放。我们能知道具体是哪个属性导致的么？答案是肯定的。 目前从崩溃的那一行来看，__ivar_destroyer 是编译器帮我们自动生成的函数，所以我们无从知晓具体是哪一行导致的问题。我们只知道这个类有如图三个属性： 但是从 @objc LoginViewController.__ivar_destroyer + 42 可以获取到一些信息，+42 代表着汇编里面的该函数的偏移量。我们可以对 __ivar_destroyer 函数进行反汇编，然后看偏移量为42对应获取的是哪个属性，在 Xcode 中可以使用 lldb 调试。 断点后分别输入上图中黄色字的命令，分别为 command script import lldb.macosx.crashlog，crashlog /Users/.../RideSharingApp-2018-05-24-1.crash，后面的路径需要替换成你的崩溃日志路径。Xcode 会自动检索二进制文件以及对应的 dSYM 文件，然后符号化显示在 lldb 控制台中。然后我们找到崩溃处的地址，执行如下命令，即可得到对应的反汇编代码： 我们不需要理解每一行汇编的意思，每行后面的注释可以帮助我们理解，根据注释可以知道 1、2、3 处代码分别代表着 userName、database、views 的释放。回到上面提到的 +42，我们找到第3处的第一行，有一点需要注意的是大部分情况下汇编的偏移地址是返回地址，所以调用 objc_release 是在上一行。所以可以判断出是在释放 database 时出现了问题。虽然我们目前还不知道具体问题所在，但是可以通过这些信息缩小查找问题的范围，可以查找使用到 database 的地方，来找到真正的问题所在。 2.4.2 日志分析总结 理解崩溃日志产生的原因 检查崩溃栈信息 使用反汇编帮我们找到更多线索来分析 bad address 问题 2.4.3 常见内存错误 objc_msgSend 或者 retain/release 崩溃 无法识别的方法异常 abort() inside malloc/free 2.5 日志分析建议 不要只关注崩溃发生的那一行代码，多查看一下和崩溃相关的代码，比如上面那个崩溃代码并不是真正导致 bug 出现的原因 查看所有调用栈，不要只关注崩溃所在线程的调用栈，非崩溃线程调用栈可以帮助我们查看崩溃时应用所处状态 多查看一些崩溃日志，有些时候很多崩溃日志都是崩溃在同一个地方，但是某些崩溃日志会包含更多的信息 使用 Xcode 提供的工具来复现内存问题，比如 Address Sanitizer 或者 Zombies 3. 多线程问题3.1 崩溃日志中多线程问题的一些“症状” 最难复现和诊断的一类 bug 多线程问题通常会引起内存竞争 多个线程执行着相似代码 同一个 bug 可能会有不同的崩溃日志 3.2 使用 Thread Sanitizer 检测多线程问题多线程问题即使我们拿到日志大概率情况下也无法分析问题所在，即使连着 Xcode 调试也不一定能够稳定复现，即使运气好能复现也可能分析不出具体问题。所以我们可以借助 Xcode 提供的工具来帮我们分析，这个工具就是 Thread Sanitizer。通过快捷键 Cmd+shift+,，然后选则 Diagnostics tab，勾选 Thread Sanitizer 即可。如下图所示 可稳定复现多线程 bug 在模拟器下也可进行 只查找当前正在执行的代码的问题 3.3 实用建议在创建 GCD Queue、(NS)OperationQueue、(NS)Thread 时，使用自定义名称，方便后续调试以及崩溃日志内查看。 let queue = DispatchQueue(label: "com.example.myapp.networking") let operationQueue = OperationQueue() operationQueue.name = "Networking OperationQueue" let thread = Thread(...) thread.name = "Networking Thread" 3.4 额外建议 使用真机测试 尝试复现，从用户处拿到崩溃日志后根据调用栈尝试去复现问题 使用工具来查找难以复现的 bug，下面两个工具的更多使用方式可以参考 WWDC 2016 Session 412 Thread Sanitizer and Static Analysis 使用 Address Sanitizer 来查看内存问题 使用 Thread Sanitizer 来查看多线程问题]]></content>
      <categories>
        <category>原创</category>
      </categories>
      <tags>
        <tag>WWDC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时光的河如海流]]></title>
    <url>%2F2019%2F02%2F03%2F2018-Summary%2F</url>
    <content type="text"><![CDATA[老规矩，这次又是2018年的最后一天，是时候更新一下年终总结了，水一下，纯当一个记录~ 工作今年工作上的变动还是蛮大的，从年初的直播 SDK 拆分完成之后的交付，到4月份的时候去到美拍北京分部，再到12月底的离职，结束了在美图将近5年的时光，感谢在美图待的这几年，自己从一个无从下手的菜鸟慢慢变成一个得心应手的老菜鸟。由于自身原因（老婆在广州，后面生活部分也有提到），在年底的时候裸辞，然后去到广州，开启一段找工作之旅，希望年后有好消息😃。 这一年来主要是在北京，自己的角色也发生了一些变化，稍微了解了一点点的“管理”的皮毛，也感谢这个机会，让自己在非技术层面上也有一定的收获。到北京后主要是负责美拍 iOS 社区的相关开发，其中大部分都是日常迭代，乏善可陈。比较有成就感的两件事： 总算实现了一套基于 YYModel 和 IGListKit 的方案来替代现有美拍基于 ResetKit(CoreData) 的方案，最终在新 App (VCUS)中实践上线，不知道最终会不会在美拍中上线。后面也会更新一个系列，名字大概叫做《CoreData 从入门到放弃》，应该不会断更，可以期待一下~ 优化 Feed 滚动，滚动过程中只加载最终停下的区域的 cell，并且将其解耦成通用逻辑，无明显侵入。 生活 生活应该从微信的免“单”惊喜开始，不知道是不是预兆，去年年底的时候微信支付在情人节那天，被免单了。然后在这一年，自己真的脱单了，顺便还结了婚，感恩。 4月份的时候确定了要去北京，碰巧大学好哥们研究生毕业要去北京爱奇艺，所以一起和他的两个研究生同学合租了，住在北五环上，4个人大概每个月1.2w的房租（可怕😂）。得亏大学老哥的一首好厨艺，几乎每个周末都会开荤，自己下厨，也偶尔周末一起出去健身，打球。 中间清明放假回了一趟家，然后在老家贷款买了一套房，也跻身泱泱房奴大军。。。 12月底离职来到老婆在的城市–广州，直接从冬天进入夏天，舒服。由于裸辞，没有工作，所以每天除了接老婆上下班，基本上就是提升厨艺和准备面试，以及上面提到的那个系列博客的撰写。 旅游在北京其实比较少出去，也就刚来的时候去了一下南锣鼓巷以及后海酒吧一条街，喝了杯酒感受了一下。再就是团建一起自驾去了内蒙古乌兰布统大草原，挺美的，尤其是日落时候在一望无际的草原马路上开车，真的太棒了。 8月份的时候和老婆去了长城、天安门、圆明园，本打算去故宫，只可惜时间太赶，过去的时候已经关门了，后面自己和同事去了一次😂。国庆和中秋那段时间，休了一波婚假（算上中秋国庆，22天长假），带老婆和家人一起自驾去了桂林，只待了两天，后续有机会再去。11月底的时候和老婆去了一趟成都和重庆，成都主要是春熙路和宽窄巷子那边打卡，然后吃了一些川大神推荐的成都名小吃。晚上吃蜀大侠火锅，排队排了3个多小时（尴尬），辛苦川大神下班跑这么远来请我吃火锅。本来想按川大神的建议自驾去四姑娘山，但是由于自己自驾经验少，而且川西路线都非常险，而且可能伴随高原反应，所以退而求其次，去了毕棚沟，事后也证明确实有高反，幸好没自驾。毕棚沟，5星推荐，一“图”以蔽之。 然后由于裸辞，自己之前没买电脑，所以需要买一台 MBP，刚好小潘说他的工牌买 MBP 可以9.4折，所以元旦后去了一趟香港，买了台 MBP。 这里需要吐槽一下，由于TimeMachine 恢复一直失败，然后我就格盘重装，结果因为家里网络问题，一直连接不上苹果的服务器，所以系统安装文件一直无法下载，然后预约天才吧，客服说帮我预约了当天晚上7.30的，然后还说如果你提前去的话可以先去周围的授权店让他们帮忙安装新系统。结果大老远跑到天河区，真是被气死，跑到其中一家客服推荐的授权店，我还没说完情况，那位店员就说装系统要收费300（？？？），然后就想着在周边吃个饭，然后等到7.30再去让天才装，结果去了之后，天才说我没有预约。呵呵，我去年买了个登山包，超耐磨。第一次预约天才吧，就遇到这种客服？？？后面自己回去倒腾半天，最后用手机热点总算下载好了安装镜像，🌶🐔🍎💊 游戏这一年，手游占比90%，基本上集中在吃鸡和农药。刚到北京的时候，主要是和同学打王者，他是王者段位，然后经常用小号带我，反正我负责坑就完事了。由于当时和老婆异地，每天都会视频，所以当时为了避免无聊，就把她也拉入坑，和我一起玩吃鸡。英雄联盟玩的次数屈指可数，主要是不想去网吧，自己由于换电脑，没有装双系统，IG 夺冠后同学一直约，所以就装了双系统，偶尔周末玩一下午，反正我也是负责坑，有人 carry 就行。 展望这一年不管是生活还是工作，都变化蛮大的。从单身变成两个人一起生活，从朝十晚七变成失业在家做“家庭煮夫”，用浩文和小潘的话来说就是“软饭硬吃”。总得来说2018算是比较惊喜的一年，感恩~ 2019年（农历，嘿嘿）也即将来临，希望自己在工作和生活中都能稳步前进，订几个小目标： 多一些产出（开源项目和博客） 学会 JS 以及 Python，最好能用在实际应用中 刷 leetcode，重新学一下数据结构个算法 把之前买的纸质书和电子书看完 买车 带老婆吃遍广州的米其林店]]></content>
      <categories>
        <category>扯淡集</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Travis CI 实现 Hexo 博客自动部署]]></title>
    <url>%2F2018%2F10%2F28%2FBlog-Automation%2F</url>
    <content type="text"><![CDATA[现在使用的博客系统是 Hexo+GitHub Pages，每次发布新的文章时流程甚是繁琐，是否有好的方式来提高效率，专注于【写】这件事上呢？ 之前从 Jeklly 转到 Hexo，发现 Hexo 比较符合我的习惯，但是每次写一篇新文章要发布，流程有点麻烦，具体我们可以来看看。在流程介绍前，先说一下我的写作环境。 Markdown 编辑器：MWeb博客系统：Hexo 至于如何搭建基于 Hexo + GitHub Pages，这里就不说了，网上教程一大堆，而 MWeb 的一些基本使用以及进阶使用，在其官网上作者已经给了充分的介绍，这里也不再赘述，在我们只关心如何优化现有流程。好了，废话说完我们看下现有流程，以及我们期望的流程。 现有流程 用 hexo n &quot;some title&quot; 生成一个 markdown 文件 MWeb 写文章，可能还要插入图片 上传图片到图床，替换 markdown 中的本地图片路径为图床链接 hexo g、hexo s 确认无误后，hexo d 这里要推荐一波 MWeb，他可以真正让你专注于写作，如果需要插入图片，只需要截图后粘贴，或复制后粘贴，或直接把图片拖到编辑窗口中即可。得益于 MWeb 外部文档的概念，我们只需要把 Hexo 的 source 文件加添加到 MWeb 当中，然后进行简单的配置即可，如下图所示 现有流程有哪些麻烦的地方呢？需要本地安装 Hexo，每次换电脑都要重新安装，有时候因为国内这尿性，Hexo 根本就安装不下来，也是很无奈。然后每次还得 hexo g/s/d，让写作欲大大降低。 期望的流程 直接使用 MWeb 生成 md 文件 图片加水印 写完之后，推送到 GitHub，自动生成博客 动手实现第一个就不多说了，直接说下图片加水印。 图片加水印上面说到 MWeb 会帮我们自动上传文章引用的图片到图床，前提是我们配置了图床。我这里使用的是七牛作为图床。先来看下我的七牛相关配置以及 MWeb 中关于七牛的配置。 由于七牛测试域名已经无法再使用，所以必须要绑定一个域名，而且该域名需要备案过。 关于上面的第五点，图片处理样式的别名，七牛上我配置的是 wm，样式分割线我设置的是 !，所以 MWeb 里面我填的是 !wm，你只需要按照你自己的样式去弄即可。最后 MWeb 给的链接类似 http://sub.your.domain/xxxx.jpg!wm 这样的。 其中如何绑定域名，七牛上都有对应的开发文档，对着弄就行。 到这一步，我们实现了图片加水印，当然这是七牛提供的在线服务。这里关键点是，你需要一个备案过的域名。 自动生成博客一篇文章写完后我们就需要把它发布到博客上，这里不再采取 hexo g/s/d 的方式，而是使用 Travis CI 来帮我们做自动部署，我们只需要关心文章的推送，而不关心博客的生成，生成直接交给 Travis CI。 相信你已经有了名为 xxx.github.io 的 repo，然后博客应该是放在 master 分支上的。把远端 repo 拉到本地，然后新建一个分支，分支名随意，假设为 hexo，删除所有内容，然后把 Hexo 生成的整个文件夹内容移到这个文件夹中，包括 theme 文件夹，这里需要注意的是如果子文件夹中包含 .git 文件，你需要删除，或者使用 submodule 的形式，我这里采用的是删除的方式。 生成 Personal access tokens 按照图中步骤生成 Token，这一步在后面要用到，生成之后最好复制一下，以免关掉页面后，就看不到只能重新生成了。 Travis CI 配置首先我们用 GitHub 登录上 Travis CI，然后找到你想要开启的 Repo，然后将其开关打开，做如下图配置即可。 紧接着我们在电脑上需要使用命令 sudo gem install travis 安装 travis，然后在 hexo 文件夹下创建一个 .travis.yml。下面是我的整个安装记录步骤及日志，关键点我都加了注释： 👈点击安装步骤日志123456789101112131415161718192021# 当前在 hexo 根目录下，且 .travis.yml 文件已在根目录下创建好了$ sudo gem install travis Password:Fetching: backports-3.11.4.gem (100%)Successfully installed backports-3.11.4Fetching: addressable-2.4.0.gem (100%)Successfully installed addressable-2.4.0... # 中间一堆日志省略了$ travis login # 使用 GitHub 登录，下面是日志不用管 We need your GitHub login to identify you.This information will not be sent to Travis CI, only to api.github.com.The password will not be displayed.Try running with --github-token or --auto if you don't want to enter your password anyway.Username: wang9262 # 输入 GitHub 用户名Password for wang9262: ************** # 输入 GitHub 密码Successfully logged in as wang9262!travis encrypt ENVName=yourtoken --add # ENVName 可以换成任意字符串，yourtoken 换成上面生成的 token，比如我的是 BlogToken=12345 以上操作执行完，打开 .travis.yml，会发现已经生成了一些类似下面代码 123env: global: - secure: wrewrewrwebJ+XFbrUGTM0kIr..... 然后 .travis.yml 具体内容，可以参考我这个分支上的内容即可。其中上面那个脚本需要说明的是为了给每次 commit 时添加记录用的，同时为了防止之前的记录被覆盖，需要先将远端的 .git 拷贝到本地，然后再进行 commit，这样可以保证所有历史记录都在，这个脚本也是放在根目录下的。 我用的命令行方式，如果用的不是命令行方式，可以参考网上的，在网页上设置环境变量，把 Token 填入到网页上，也就是上图中的2、3两个标记点，2填入环境变量名，3处填入 Token，也可以新增其它环境变量。 最后现在每次有新文章发布，只需要本地写好后，把 markdown 文件推到远端的 hexo 分支即可，不需要额外操作，这样可以便捷地在多台电脑上发布内容，不必为环境配置而担心。当然这篇文章也是通过这种方式发布的，效果还行吧。 接下来的计划就是把文章顶部的一些 hexo 用到的元信息通过脚本自动生成而不需要手动去添加。 如果你根据上面步骤，没有达到想要的效果，可以在下方留言，一起交流沟通。当然如果你有更高效的方式，也欢迎分享一下~]]></content>
      <categories>
        <category>备忘记录</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GMTC 之旅]]></title>
    <url>%2F2018%2F10%2F28%2FSome-thoughts-On-GMTC-2018%2F</url>
    <content type="text"><![CDATA[上周凑巧有机会拿到 GMTC 的票，然后去现场体验了一下。这里主要记录第一次参加这种线下大会的一些感受。 大会在 6.21~6.22 进行，由于时间问题，我只去了两个自己感兴趣的专题：性能优化专场以及 iOS 新技术专场。性能优化专场在21号下午进行，当天早上 Flutter Release Preview 1 放出，更多关于 Flutter 的文章，可以在我们公众号知识小集上获取。 性能优化专场当天下午提前一小时从公司出发，1：30 到现场时，会场已经满座，只能坐地下，第二场一些人走了之后才空出一些座位。 第一场是 LinkedIn iOS 工程师带来的《LinkedIn 移动应用的性能优化实践》，分享了领英的一些性能优化实践。随着应用体量（功能）变得越来越庞大，最初的应用架构会变得越来越撑不住，所以需要适时调整合理的应用架构。领英使用组件化和标准化来提高代码复用率以及项目复杂度，进而减少了线上的崩溃率和性能问题。建立完善的性能监控体系对线上用户的性能数据进行分析，发现问题并解决问题，同时使用 AB 实验来快速验证效果。最后作者通过一个实际案例来阐述，以上几点是如何在项目中落地实践的。通过线上监控发现页面加载比较慢，主要原因有：网络请求多、数据量大、页面渲染慢，对这三个分别采取对应措施来解决：网络优化，使用 http/2、数据简化（服务端精简返回字段）、布局优化（领英开源库 LayoutKit，将布局计算放到后台线程）。 其实大部分应用都可能存在上述问题，从网络发起到页面完整渲染展示，里面很多的关键节点都可能导致页面加载过慢。对于数据简化这一块，作者有提到他们内部有一个 Frontend Deco 平台，客户端可以根据实际情况选择需要服务端返回的字段，然后生成一个 recipe_id，请求时带上这个参数，则只会返回对应的数据，进而实现数据精简。 这里有一点很疑问，理论上性能优化是肯定能改善用户体验的，这里对性能优化做 AB 实验是不是有点多此一举？ 分享者的回答： 剩下的 3 场主要是前端和安卓上的性能优化，由于自己对于安卓和前端技术一无所知，所以只是大概听了一下。印象比较深的是阿里的监控体系，还原用户“事发现场”，大致原理就是记录首屏时的所有数据，用户操作导致的增量数据页实时记录，进而实现用户操作现场的还原。爱奇艺的“极致”性能优化，对于功耗的测量，使用 PowerMonitor 来检测分析，同时使用 AI 来做自动化测试。同时开源了 LiteApp，感兴趣的可以自行在 GitHub 上搜索。 iOS 新技术专场这一场在22号早上9点半开始，9点到达会场，人没有昨天那么多，空位很多。这个专题出品人是嘀嘀出行的戴铭老师。这个专场有三个主题，讲师分别来自 Instagram、美团、美甲帮。 来自 Instagram 的工程师主要分享了复杂列表的解决方案、对照实验、以及加快编译速度。复杂列表使用他们自己开源的 IGListKit 以及 MVVM 架构来实现代码复用，各自业务团队代码集中在 SectionController 来达到解耦，各个业务团队只需专注于自己的业务逻辑。同样 Instagram 也通过 AB 实验来抉择出一些较好的产品需求，同时通过 AB 实验来保持产品的快速迭代。同时随着 AB 实验的增多，难免会遇到一些互斥实验或者互相影响的实验，所以在设计一些实验时，也需要尽量避免这种情况。对于可能互相干扰的实验，作者举了一个例子以及可能的几个解决方案，思路也是很不多的，具体内容大家可以去官网上找到对应的 PPT 链接，下载查看。最后一个分享点，也是目前大部分 iOS 开发者的槽点，就是 Xcode 的编译速度。随着工程及代码量的增大，编译速度也随之变慢，从原来的十几秒到几分钟到半小时（真正的“带薪编译”），编译时的心情也依次改变：😀-&gt;🙂-&gt;😰-&gt;😡-&gt;💀。Facebook 内部使用 Buck+Focus 来加快编译速度，Buck 目前已开源，据作者说，使用 Buck+Focus 后，编译速度又能到十几秒，感兴趣的可以尝试一下。 来自美团的臧成威老师分享了他们即将开源的面向对象的响应式架构：EasyReact 以及 EasyMVVM，相信用过 ReactiveCocoa 的同学都很清楚，每次调试时，调用栈非常深，而且中间的调用栈内容几乎没啥用处，调试起来比较费劲，作者表示 EasyReact 相对于 ReactiveCocoa，同样的5次变换操作，前者调用栈只有10层，而 ReactiveCocoa 有50层。关于其它的对比，可以参考一下作者放出的 benchmark 对比图 最后美甲帮的靛青分享了他的解决异构列表的开源库 Flix。主要是通过几个实例来一步步给出 Flix 的设计理念，以及一些使用场景，会上代码涉及的较多，感兴趣的可以自行去 GitHub 上翻阅对应源码。 感受AB 实验作为一种快速验证想法的工具，目前国内外大公司应该都有在使用，相对于传统的版本迭代，AB 实验可以较好的缩小迭代周期，在以数据结果为导向的情况下，也能快速得出结论，不需要做过多争辩。但同时它也带来了一些挑战，比如 AB 实验的设计，以及对实验结果的分析等。 性能优化作为每个开发者都应该掌握的技能，开发过程中需要多考虑性能上的问题，不能一味追求需求完成速度，还要兼顾质量。 整个两场专题听下来，感受最深的就是几乎每个小主题都在分享自己的开源框架，一方面可以提高自己公司的影响力，另一方面也可以吸引到更多人。 PS：以上所有场次的 PPT 均可在这里下载到]]></content>
      <categories>
        <category>扯淡集</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[替换系统音量提示的实现和遇到的坑]]></title>
    <url>%2F2018%2F06%2F03%2FReplace-System-Volume-View%2F</url>
    <content type="text"><![CDATA[相信平时大家在用 iPhone 看视频调节音量时，总会被系统的音量提示所打扰，因为它会遮住一部分内容。所以很多视频应用都使用自定义音量视图的方式来替代系统的音量提示。 比如下面三张截图，分别来自 Instagram、哔哩哔哩、即刻 原理这里主要记录一下在项目中如何替换系统音量提示视图的过程。通过 Google 和 stackoverflow，可以查到，如果要自定义音量提示，需要做到以下几步： 激活 AudioSession 创建一个 MPVolumeView，并将其添加到当前可见的视图层级当中，同时将其 frame 设置到不可见区域 监听音量按钮触发事件，改变音量提示 实现然后为了调用统一且音量视图层级永远在最上方（即不被 Alert 等挡住），首先想到使用一个 UIWindow，然后自定义视图和系统的视图加到这个视图层级上，初始化时 frame 为 CGRectZero，hidden 属性为 NO（注意这里必须为 NO，不然系统音量提示仍会出现，上面说到的第2点）；要显示时设置其 frame 设置成 mainScreen 的 bounds，然后展示即可。 由于自己创建的 UIWindow 的 hidden 属性默认是 YES，所以需要手动将其设成 NO。音量按钮每触发一次，变化量都是 6.25%，连续按16次，即可调节至最大或最小 上述的第3步有两种方式可以做到，各有优劣，下面来做一个简单介绍。 KVO通过 KVO 监听 [AVAudioSession sharedInstance] 的 outputVolume 属性，然后来显示自定义的 UI 控件。这种方式有一个不好的地方就是，在音量调节至最大/最小时，这个时候再调大/调小音量，由于 outputVolume 的值不变，所以不会触发 KVO，也就无法展示自定义音量视图。代码大概长下面这样 123456789101112131415161718192021222324252627- (void)dealloc &#123; [[AVAudioSession sharedInstance] removeObserver:self forKeyPath:NSStringFromSelector(@selector(outputVolume))];&#125;- (void)addObserver &#123; [[AVAudioSession sharedInstance] addObserver:self forKeyPath:NSStringFromSelector(@selector(outputVolume)) options:NSKeyValueObservingOptionNew context:nil];&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; if ([change isKindOfClass:[NSDictionary class]]) &#123; NSNumber *volumeNum = change[@"new"]; if (volumeNum) &#123; [self volumeDidChange:[volumeNum floatValue]]; &#125; &#125;&#125;- (void)volumeDidChange:(CGFloat)volume &#123; // 显示自定义音量提示&#125; 通知这种方式通过监听系统私有（未公开的）通知，名字是 AVSystemController_SystemVolumeDidChangeNotification，这个监听不会受到最大/最小音量时，调大/调小音量的影响，只要音量键按下，始终都会触发。但是这个通知由于是私有的，可能存在被拒风险，而且将来系统版本该通知名字发生改变，由于是硬编码而不像其它系统通知使用的是常量，会导致监听不到的问题。 代码大概长这样 1234567891011121314151617181920212223static NSNotificationName const kSystemVolumeDidChangeNotification = @"AVSystemController_SystemVolumeDidChangeNotification";- (void)dealloc &#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125;- (void)addObserver &#123; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(volumeDidChange:) name:kSystemVolumeDidChangeNotification object:nil];&#125;- (void)volumeDidChange:(NSNotification *)notification &#123; NSString *category = notification.userInfo[@"AVSystemController_AudioCategoryNotificationParameter"]; NSString *changeReason = notification.userInfo[@"AVSystemController_AudioVolumeChangeReasonNotificationParameter"]; if (![category isEqualToString:@"Audio/Video"] || ![changeReason isEqualToString:@"ExplicitVolumeChange"]) &#123; return; &#125; CGFloat volume = [[notification userInfo][@"AVSystemController_AudioVolumeNotificationParameter"] floatValue]; // 显示自定义音量提示&#125; 以上两种方式各自优劣势都已经列出来了，上面说到的三个应用，Instagram 使用的是通知的方式，即刻和哔哩哔哩都是用 KVO 的方式。具体要选那种方式，就看具体需求了，如果在最大或最小时，调节音量可以接受不展示音量视图的话，个人推荐使用 KVO 的形式。 遇到的问题上面阐明了原理和实现方式，接下来就是接入到项目中真正使用了，接入项目后发现问题还不少。 坑0x0001由于我们使用了 window 来显示自定义音量提示，所以 window 需要提前创建好，有一个需要注意的是 UIWindow 的 hidden 默认是 YES，由于上面说到系统的音量视图必须在可见视图层级内，所以创建的这个 window 必须要可见，然后尽量不影响交互，将其 userInteractionEnabled 置为 NO，且要让其不可见时层级最低，windowLevel 设置为 UIWindowLevelNormal。 123456self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];self.window.hidden = NO;self.window.windowLevel = UIWindowLevelNormal - 1;self.window.rootViewController = [[UIViewController alloc] init];self.window.backgroundColor = [UIColor clearColor];self.window.userInteractionEnabled = NO; 坑0x0010这样一切看起来很正常，但是有一个问题就是有一些地方通过 [[UIApplication sharedApplication].windows firstObject] 来进行一些操作，比如展示 toast 或者收起键盘的 UIControl，所以会导致其不可见或者无法响应交互。所以上面代码改成 123self.window = [[UIWindow alloc] initWithFrame:CGRectZero];self.window.clipsToBounds = YES;self.window.windowLevel = UIWindowLevelNormal; 嗯，运行起来，那些寻找 firstObject 的地方都正常了，但是…由于存在开屏广告，而且开屏广告用的也是 window，而且他会在自己要显示时，调用 makeKeyAndVisible 方法，消失的时候直接将其置为 nil，导致系统会自己寻找其它的 window 当做 keyWindow，这个时候不知道为什么会找到我们音量提示的 window？难道是因为 [UIApplication sharedApplication].delegate.window 层级是 Normal，音量提示 window 层级也是 Normal，然后会将后加入的 层级为 Normal 的 window 设置为 key window？暂时还不懂，有知道的大神麻烦指点一下。这样看来，这种修改方式也不太行，会导致其它地方取 keyWindow 的时候，取错掉。 坑0x0011嗯，那索性直接用 [UIApplication sharedApplication].delegate.window 这个来显示音量提示，最多也就出现 Alert 或键盘的时候，音量提示会被遮罩挡住，概率也比较小还好。于是改成下面代码 1self.window = [UIApplication sharedApplication].delegate.window; 但是这个时候会发现，iPhoneX 下音量提示会被状态栏挡住，wtf！！！那么好吧，在音量显示的时候隐藏一下状态栏，音量消失的时候回复一下之前记住的状态栏状态，但是如果存在两个页面状态栏显隐不一致的情况，就会出现问题。同时在某些 present 起来的页面，音量提示死活不显示，但是用 Xcode 自带视图层级调试工具看，音量提示视图的 frame、alpha、hidden 属性都是正常的，但就是没有显示出来。后面将提示视图 layer 的 zPosition 提高之后，就可以显示出来了，真的很神奇。 一步步下来，填完一个坑，又来一个，感觉是个无底洞，永远填不满。搞了一晚上，一筹莫展。 完美填坑最后灵光一闪，如果自定义一个 Window，继承自 UIWindow，然后复写 becomeKeyWindow 方法，在这个方法里让自身不成为 keyWindow 同时将 [UIApplication sharedApplication].delegate.window 设置为 keyWindow，大致代码长这样： 123456789101112@interface VolumeWindow : UIWindow@end@implementation VolumeWindow- (void)becomeKeyWindow &#123; [self resignKeyWindow]; [[UIApplication sharedApplication].delegate.window makeKeyWindow];&#125;@end 坑0x0100拍摄页拍摄之前系统音量提示是可以被替换的，但是拍摄一段之后，莫名其妙音量按钮按下后自定义提示不见了，出现了系统的铃声提示。一脸懵逼，后面发现是由于设置了 AVCaptureSession 的 usesApplicationAudioSession 为 NO，会导致在拍摄之后会变成铃声，这个和是否替换系统音量提示无关。这个属性是由于项目中很久之前需要兼容 iOS6，然后一直遗留着这个属性设置没有删除。由于 iOS7 之后，AVCaptureSession 和应用使用的是同一个 AudioSession，支持同时播放和录制且不会受到影响和打断，所以不需要再去设置这个属性。 坑0x0101做了以上操作，在 iPhoneX 下，当拉起控制中心，并上下滑调整音量后，再回到应用，会发现自定义音量视图会出现在状态栏下面，猜测虽然在应用内自定义音量视图 window 层级高于状态栏 window 层级，但是由于状态栏是全局的，在重新进入到应用时会出现状态栏层级高于音量视图。所以就索性仅在应用为 active 的情况下才处理 KVO。 最后一个需要注意的点是在语音电话（或者其它使用系统音量的场景下）时，去自己应用内调节音量是无效，因为这个时候音量其实代表的是系统在占用，系统优先级高于应用，所以在这些场景下，即使在应用内调节音量，也无法触发出自己的音量视图。 然后上面所有问题都迎刃而解了。 最后推荐一个开源库：VolumeBar]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pod 中资源引入方式对比]]></title>
    <url>%2F2018%2F03%2F17%2FPod-Resource%2F</url>
    <content type="text"><![CDATA[写这篇博客起因是由于周四在知识小集发了一个 Tip，讲 Pod 里面使用了 .xcassets 会导致 Xcode 9 打出来的包没有 icon 的解决方案。然后和 @Damonwong 展开了一下讨论。当然这条 Tip 讲得不全对，而且表达得不是很清晰，所以这里专门开一篇文章来讲一下那个 Tip 想要表达的意思，最后也会附上对应的 Demo。也当做之后要写的模块化系列的文章开篇吧。 首先我们先来给出结论： podspec 里面写资源时，最好用 s.resource_bundle 而不是 s.resource 只有 podspec 使用 resource 且明确写了 .xcassets 的情况下才会导致 Xcode 9 打出来的包没有 icon 环境配置：Xcode 9.2 、Cocoapods 1.4.0本文所涉及到的资源主要是指 png 格式的图片 下面我们先来了解一下这两种方式的具体情况，以及各自的优劣势，最后通过一个 Demo 来验证我们上面给的结论。 resource 和 resource_bundleresource通过官方文档描述 A list of resources that should be copied into the target bundle. 这种方式会引用的文件夹下的所有资源拷贝到 target 的 bundle 中去，可以简单的理解为 .app 目录下或者 .app 的 Assets.car 文件中（如果是 .xcassets 的资源）。 Tips: 注意一下上面加粗的部分。 这里抄一下官网上给的几个示例写法 #单个路径spec.resource = ‘Resources/HockeySDK.bundle’#多个路径spec.resources = [‘Images/*.png’, ‘Sounds/*‘] resource_bundle还是一样，我们来看一下 Cocoapods 官方文档上的描述 This attribute allows to define the name and the file of the resource bundles which should be built for the Pod. They are specified as a hash where the keys represent the name of the bundles and the values the file patterns that they should include. 这种方式可以将指定路径下的资源打包打 =&gt; 之前的 key 命名的 bundle 中，这个 bundle 最终会被拷贝到 target 也就是 .app 根目录下。如果有指定 .xcassets 资源，会被打包到以 key 命名的 bundle 里的 Assets.car 文件中。 Tips: 注意一下上面加粗的部分。 官方示例写法 #单个路径spec.ios.resource_bundle = { ‘MapBox’ =&gt; ‘MapView/Map/Resources/*.png’ }#多个路径，生成多个 bundlespec.resource_bundles = { ‘MapBox’ =&gt; [‘MapView/Map/Resources/*.png’], ‘OtherResources’ =&gt; [‘MapView/Map/OtherResources/*.png’] } 对比其实上面官网上的描述我故意漏附了后面的几段话，文档上在两种方式下都强烈(strongly)推荐使用 resource_bundle 的方式。 resource 下的描述We strongly recommend library developers to adopt resource bundles as there can be name collisions using the resources attribute. Moreover, resources specified with this attribute are copied directly to the client target and therefore they are not optimised by Xcode. resource_bundle 下的描述We strongly recommend library developers to adopt resource bundles as there can be name collisions using the resources attribute.The names of the bundles should at least include the name of the Pod to minimise the chance of name collisions. 综合上述所说，就是使用 resource_bundle 主要有以下两点好处： 避免命名冲突（bundle 命名时最好包含 Pod 的名字来尽可能避免掉命名冲突） Xcode 会对资源做优化，比如 .xcassets 里的图片压缩、Slicing、以及 @2x/@3x 图片资源分离 我们来对比下两种方式下最终打包出来的应用目录结构： 方式 生成的 .app 目录 可以看出 resource_bundle 的形式会生成对应的 bundle(上图中的 Pod1.bundle)，并且 .xcassets 最终会被打包到对应 bundle 下的 Assets.car 文件下（该文件可用这个工具打开：iOS-Images-Extractor）。而 resource 的形式，会把 .xcassets 打包到应用根目录下的 Assets.car 中。 而要读取对应的图片时，resource 对应的代码长下面这样： 123UIImage *image = [UIImage imageNamed:@"your-image-name" inBundle:[NSBundle bundleForClass:[self class]] compatibleWithTraitCollection:nil]; 而 resource_bundle 对应的读取代码如下面所示： 123456NSBundle *bundle = [NSBundle bundleForClass:[self class]];NSURL *url = [bundle URLForResource:@"your-bundle-name" withExtension:@"bundle"];NSBundle *targetBundle = [NSBundle bundleWithURL:url];UIImage *image = [UIImage imageNamed:@"your-image-name" inBundle:targetBundle compatibleWithTraitCollection:nil]; 通过以上两个代码片段，相信各位已经知道代码片段1、2都可能存在图片命名冲突的问题，但是一般情况下片段2的冲突概率远小于片段1的。因为一般情况下，模块内的图片命名肯定是不会冲突的，而模块间的图片的命名就不好说了。当然如果团队里有明确的命名规范，片段1和片段2都不会有问题。虽然片段2代码较片段1稍复杂一些，但是如果我们将其封装成一个 NSBundle 的分类，就免去了冗长的写法，对于 Storyboard/Xib 同样适用。 1234567891011121314151617181920212223242526272829// 具体代码可以在 Demo 中找到//.h@interface NSBundle (Pod1Bundle)+ (NSBundle *)pod1_bundle;@end//.m// FakeClass 仅作占位符用，即只为分类中的 `bundleForClass:` 方法服务@interface Pod1FakeClass : NSObject@end@implementation Pod1FakeClass@end@implementation NSBundle (Pod1Bundle)+ (NSBundle *)pod1_bundle &#123; NSBundle *bundle = [self bundleForClass:[Pod1FakeClass class]]; NSURL *url = [bundle URLForResource:@"Pod1" withExtension:@"bundle"]; return [self bundleWithURL:url];&#125;@end// 片段2可以简写为：UIImage *image = [UIImage imageNamed:@"your-image-name" inBundle:[NSBundle pod1_bundle] compatibleWithTraitCollection:nil]; Demo第一个 commit 写好了两个 podspec，一个用 resource_bundle(Pod1)，一个用 resource(Pod2)，然后都引用 .xassets 资源，里面都有一个名为Pod的图片，主工程也有。区别在于 Pod 中的图片顶部会有该 Pod 名称的水印。然后页面上有3个 ImageView，目前只设置了中间那个 ImageView 的图片为主工程的图片。运行起来，一切表现正常，展示出来的图片也确实是主工程的图片。 第二个 commit 在主工程内分别读取 Pod1 和 Pod2 的名为 Pod 的图片，然后分别塞到上下两个 ImageView 中，运行起来，最下面那个 ImageView 的图片变成主工程的图片了，而最上面的 ImageView 的图片是正常的！！！这就是我们上面说到的那个问题，由于 Pod2 使用 resource 的方式，.xcassets 中图片是直接和主工程的 .xcassets 中图片一样是打包到 .app 根目录下的 Assets.car 中，命名一致，导致被主工程的图片给覆盖掉了（可以使用上面说到的解压工具解压，查看根目录 .car 下的文件内容，只有主工程的图片）。 第三个 commit 及 ruby-shell 分支主要解决应用 icon 为空的问题。当我们 Home 键回到桌面时，回发现 Demo 的 icon 是空的，但是我们是有设置 icon 的。所以我们有两种解决方案来解决这个问题。 方案一：不使用 .xcassets把图片放到 Pod2 目录下，不再放到 .xcassets 里面，然后 podspec 里的写法改成： 1s.resources = ['Pod2/**/*.png'] pod install 之后再跑一下，发现 icon 回来了，但是图片还是被主工程覆盖了，查看 .app 文件，我们发现根目录下多了两张图片，他们来自于 Pod2 目录下。 相应的我们的读取代码就需要改成下面这种形式，还需要区分 @2x 和 @3x，非常麻烦，但是这个时候确实能读到对应的图片 12345678// @2x 读取_podImage = [UIImage imageNamed:@&quot;Pod@2x&quot; inBundle:[NSBundle bundleForClass:[self class]] compatibleWithTraitCollection:nil];// @3x_podImage = [UIImage imageNamed:@&quot;Pod@3x&quot; inBundle:[NSBundle bundleForClass:[self class]] compatibleWithTraitCollection:nil]; 方案二：脚本在 podfile 中加入下面这一段脚本 12345678post_install do |installer|copy_pods_resources_path = "Pods/Target Support Files/Pods-ResourceDemo_Example/Pods-ResourceDemo_Example-resources.sh"string_to_replace = '--compile "$&#123;BUILT_PRODUCTS_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;"'assets_compile_with_app_icon_arguments = '--compile "$&#123;BUILT_PRODUCTS_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;" --app-icon "$&#123;ASSETCATALOG_COMPILER_APPICON_NAME&#125;" --output-partial-info-plist "$&#123;BUILD_DIR&#125;/assetcatalog_generated_info.plist"'text = File.read(copy_pods_resources_path)new_contents = text.gsub(string_to_replace, assets_compile_with_app_icon_arguments)File.open(copy_pods_resources_path, "w") &#123;|file| file.puts new_contents &#125;end 然后 pod install 之后，运行即可。 以上两种方式执行之前最好 clean 一下，防止 Xcode 缓存，导致以上方法执行后也会出现 icon 消失的情况。 总结综合以上，我们再总结一下 resource_bundle 的优势： 绝大多数(99.999%)情况下不会有资源命名冲突问题 如果图片资源放到 .xcasset 里面 Xcode 会帮我们自动优化、可以使用 Slicing 等（这里不仅仅指的是 resource_bundle 下的 xcassets，只不过 s.resource 中如果引用会导致 icon 消失的问题）。 至于劣势，我觉得根本就没有，上面那个硬编码问题，完全可以通过我说的分类或者你自定义宏的方式把这个硬编码问题 Cover 掉。 如果认为文章中的观点或结论有问题，欢迎指出，一起沟通探讨。 参考链接 App Icons not included in build from Xcode 9关于 Pod 库的资源引用 resource_bundles or resources]]></content>
      <categories>
        <category>模块化</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>Xcode</tag>
        <tag>Pod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[亦无岁月可回头]]></title>
    <url>%2F2018%2F02%2F16%2F2017-Summary%2F</url>
    <content type="text"><![CDATA[2018 即将来到(哈哈哈哈哈哈，我说的是农历年)，这篇文章纯当一篇水文，做个2017的年终总结。 工作 来美图工作已经快4年了（算上实习的话），从一个 CollectionView 都不会用的人，到现在慢慢得能够比较轻松应对现在的工作。 去年工作上最有成就感的两件事情： 在业界的几种模块化方式上结合美拍实际情况进行了简单的实践。年后写篇文章分享一下这个过程和思路。 配合架构同学让美拍直播实现了真正的秒开。 讲真陌陌直播秒开真的很牛逼，现在美拍也能达到这个水平了！ 年中的时候，买了几本书，目前只看了其中三本，年后再继续吧。12月的时候美拍开始996，说真的有点累，每天晚上10点多到家，洗完澡差不多到睡觉时间，希望年后不要再继续了😂还是比较怀念之前有双休的日子。对于学习的方式也发生了一点变化，以前总是想着要学很多，列了很多待学习项，但是最后都是不了了之，现在慢慢开始往某一个方向去深入了解，其他的做个基本了解就 ok。 生活随着毕业季到来，和公司的两个小鲜肉合租，周末偶尔自己做做饭，刚开始兴趣比较大，后面由于996，基本上也就没怎么用过厨房了。今年夏天在小鲜肉们的带领下，学会了一项求生技能—-游泳。现在还不会换气，一口气只能游10m，姿势是狗刨试。基本上每个月至少会和他们一起看一部电影，烂片除外。国庆和小伙伴们去了一趟台湾，本来去年就计划好的，但是又去通行证时间来不及坑了熊哥，所以原计划就推到了今年。台湾旅程感觉最有意思的地方非绿岛莫属了，环岛骑了半天机车，傍晚时分一起去潜水。第一次比较紧张，到十几米水下的时候感觉不舒服，然后手脚错乱，还好教练在身边，马上浮了上来，差点 GG。后面再下去就比较顺利了，如果后面有机会，值得再去一次。 游戏周末一般会和同学玩一玩英雄联盟，S7世界赛和同事们在家里一起投屏看比赛，只是很可惜零封 SSG 的 RNG 没有赢下对 SKT 的比赛。当然 EDG 是被喷的最惨的，不过 iBoy 这个小朋友很皮，S8可以期待一下。 996之后英雄联盟就玩的比较少了，一般就中午的时候吃一吃鸡。 不过不管玩什么游戏，都很菜，而且有时候反应很慢，可能不是玩游戏的料，纯属娱乐😂。哈哈哈哈哈，只能用这个来安慰自己了，感谢队友的不杀之恩！！！ 技能技术方面 初识逆向 发现逆向还是蛮好玩的，但是基础知识不够，还没有深入玩下去，只是做了个简单的了解。改善了一下平时写正向代码的思路。 RAC 实践 之前组内同事一直在推广，但是自己没有真正实践过，都是停留在他的分享上。今年接手美拍直播这一块之后，慢慢开始使用，很多值得注意的地方，也踩了一些坑，目前只是算对 RAC 有一个基本的了解，以及初步实践，后面还需要继续实践，以及完整读一遍源码。 生活方面 做菜 上面说到合租后有自己做过一段时间饭，有照着食谱做，也有回忆着老爸做菜时候的一些操作和步骤。从难吃到慢慢变成勉强能吃，到后面每次大家都能把菜吃光，也算是一种进步了吧。 游泳 之前对游泳是抗拒的，主要是不会游，觉得去了很尴尬，后面看了几集视频教程以及实践，开始学会了一丁点，能有一点点距离了，但还是不会换气。 展望躺在床上，敲着这些流水账，听着外面鞭炮声，这真的是一篇写了“一年”的文章。 2017已经过去，希望2018自己能够继续成长。]]></content>
      <categories>
        <category>扯淡集</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Modern Objective-C]]></title>
    <url>%2F2017%2F04%2F21%2FModern-Objective-C%2F</url>
    <content type="text"><![CDATA[本文主要介绍一些 Objective-C 的一些新特性。 从一个 Bug 来说说 Objective-C 中的指定构造器某天测试反馈，iOS8 点击按钮时弹出一个列表视图出现必现崩溃，看了下崩溃日志，是野指针导致导出乱崩，具体是 [xxx collectionView:numberOfItemsInSection:] unrecognized selector send to instance xxxxx。连上设备调试，发现 setupDataSource 走了两次，由于调用栈非常类似，一开始没注意它调了两次，一直没找到问题所在。后面各种断点上去，发现 setupDataSource 方法被调用了两次，进一步 commonInit 被调用了两次。最后查看初始化代码，才发现调用 convenience init method 时，没有调 designed init method，并且调完之后又再调了一次 commonInit。具体看下代码： 123456789101112131415161718192021222324252627282930313233343536373839@interface PanelView()@property (nonatomic, strong) UICollectionView *collectionView;@end- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123; if (self = [super initWithCoder:aDecoder]) &#123; [self commonInit]; &#125; return self;&#125;- (instancetype)initWithFrame:(CGRect)frame &#123; if (self = [super initWithFrame:frame]) &#123; [self commonInit]; &#125; return self;&#125;- (instancetype)initWithType:(PanelType)type &#123; if (self = [super init]) &#123; [self commonInit]; self.type = type; &#125; return self;&#125;- (void)commonInit &#123; self.colletionView = ... [self addSubview:self.colletionView]; [self setupDataSource];&#125;- (void)setupDataSource &#123; DataSource *dataSource = [[DataSource alloc] initWithCollectionView:self.collectionView]; dataSource.delegate = self; self.collectionView.dataSource = dataSource; self.dataSource = dataSource;&#125;// 外面使用 initWithType: 做了初始化 由于调了两次 commonInit，导致创建了两个 collectionView 和 dataSource，由于第一次创建的 dataSource 没有持有者，被释放为 nil，而第一次创建的 collectionView 被加到视图层级当中被 self 持有，所以在第一个 collectionView 在执行调用数据源方法时，dataSource 为 nil，但是在 iOS9 之前 UICollectionView 和 UITableView 的 delegate 和 dataSource 属性用 assign 而非 weak 修饰，导致这一块内存被污染，继续调用时会出现野指针崩溃。 归根结底，就是初始化的姿势不对。 正确的姿势应该是： 子类指定构造器必须调用父类指定构造器 便捷构造器只能通过调用自身指定构造器来完成初始化 指定构造器必须要用 NS_DESIGNATED_INITIALIZER 标示 可参考下图 图片出自 《The Swift Programming Language (Swift 3.0.1)》 Initialization - Syntax for Designated and Convenience Initializers 小节 关于指定构造器，iOS 自身内部实现也有一个 bug UITableViewController subclass designated initializer Crash、How to subclass UITableViewController in Swift。iOS8 下自定义一个 UIViewController 继承自 UITableViewController，然后自定义指定构造器，代码如下： 12345678910111213141516171819// 指定构造器- (instancetype)initWithTitle:(NSString *)title &#123; if (self = [super initWithStyle:UITableViewStyleGrouped]) &#123; //.... &#125; return self;&#125;- (instancetype)initWithNibName:(nullable NSString *)nibNameOrNil bundle:(nullable NSBundle *)nibBundleOrNil &#123; return [self initWithTitle:nil];&#125;- (instancetype)initWithStyle:(UITableViewStyle)style &#123; return [self initWithTitle:nil];&#125;// 外面调用，iOS8 下调用此段代码，必崩// 所以 iOS8 最好不要继承自 UITableViewControllerTestViewController *vc = [[TestViewController alloc] initWithTitle:@"Hello"]; 几个小问题 Question 1: instancetype 和 id 两者有什么区别？ instancetype 能够做到类型检测而 id 不行。前者仅可做方法返回值，不能作为参数，见示例代码比如如下代码： 1234567891011121314151617@interface TestObjectA : NSObject+ (id)createObjectA;- (void)methodA;@end@interface TestObjectB : NSObject+ (instancetype)createObjectB;- (void)methodB;@end[[TestObjectA createObjectA] methodB]; // no compile error or warning but crash[[TestObjectB createObjectB] methodA]; // compile error --&gt; No visible @interface for 'TestObjectB' declares the selector 'methodA' 延伸问题：为什么(id)initWithXXX: 也可以做到类型检测？ 类方法只要以 alloc、new 开头就会有关联返回类型（即类型检测）实例方法只要以 init、autorelease、retain、self 开头就会有关联返回类型Clang Language Extensions–Objective-C FeaturesNote: ARC 下实测，实例方法只有 init 开头的才有关联返回类型。 Question 2: 新建一个VC 文件同时勾选 Also create XIB file 后，初始化 VC *vc = [[VC alloc] init] 得到的是否和 initWithNibName:bundle: 初始化得到的 UI 一致？为什么？ 是一致的，因为最终都会调到指定构造器 initWithNibName:bundle:，但此时 nibName 为 nil，关于 nibName 的相关设置文档是这么说的However, if you do not specify a nib name, and do not override the loadView method in your custom subclass, the view controller searches for a nib file using other means. Specifically, it looks for a nib file with an appropriate name (without the .nib extension) and loads that nib file whenever its view is requested. Specifically, it looks (in order) for a nib file with one of the following names:If the view controller class name ends with the word ‘Controller’, as in MyViewController, it looks for a nib file whose name matches the class name without the word ‘Controller’, as in MyView.nib.It looks for a nib file whose name matches the name of the view controller class. For example, if the class name is MyViewController, it looks for a MyViewController.nib file. 简单来说，如果没设置该属性也没有复写 loadView 方法，则系统有一套自己的寻找机制来看是否有对应的 xib 文件，如果有，则加载 xib 文件。 Question 3: 如下代码输出的是什么？为什么？ 选自 神经病院objc runtime入院考试 123456789101112@interface TestSubclass : TestSuperclass@end@implementation TestSubclass- (instancetype)init &#123; self = [super init]; if (self) &#123; NSLog(@"%@", NSStringFromClass([self class])); NSLog(@"%@", NSStringFromClass([super class])); &#125; return self;&#125;@end 输出的都是 TestSubclass，因为两者的 receiver 都是 self。当我们给 super 发消息的时候，实际上是给 self 发消息，只不过在查找方法列表时会自动跳过当前类的方法列表，而从父类方法列表中开始查找。归根结底，最后产生的消息是 objc_msgSendSuper(self, @selector(init));。 Question 4: 为什么我们初始化方法的写法都长这样？ 1234567891011@interface SomeClass : TestSuperClass@end@implementation- (instancetype)init &#123; if (self = [super init]) &#123; &#125; return self;&#125;@endSomeClass *aInstance = [[SomeClass alloc] init]; 我们可以将上面代码拆成以下几个步骤： [SomeClass alloc] 返回一个 SomeClass 的实例 紧接着给 步骤1 生成的实例发 init 消息，所以 init 方法中的 self 为 步骤1 生成的实例 [super init] 实际上调用的是父类的初始化方法，在父类的方法中，self 依然是 步骤1 生成的实例，对于这一点的理解很重要 父类的 init 方法要么做一些基本的初始化工作，要么修改 self，然后返回一个新的实例 回到 SomeClass 的init方法中来，此时得到的要么是 步骤1 生成的实例，要么是新生成的实例。这就是为什么我们要加 if 判断的原因。 新增关键字及特性Nullabilitynonnull/_Nonnull 表达的意思是一样的，nullable/_Nullable 同理，只是修饰符的位置不同_Nonnull 和 _Nullable 的位置和 C语言的 const 关键字位置一致。 1234567// 写法1和2 表达的意思完全一致// 写法1- (AAPLListItem * _Nullable)itemWithName:(NSString * _Nonnull)name;@property (copy, readonly) NSArray * _Nonnull allItems;// 写法2- (nullable AAPLListItem *)itemWithName:(nonnull NSString *)name;@property (copy, readonly, nonnull) NSArray *allItems; 几个特例： typedef 类型由于可以从上下文中推断出它是空（nullable）或非空（nonnull），所以内部不需要写 nullable 或 nonnull。 复杂指针必须显式声明其是否可为空，比如指定一个指向非空对象的可空指针可声明为 _Nullable id * _Nonnull NSError ** 类型通常为一个指向可空对象的可空指针。 为了避免重复写 nonnull，有一对宏 NS_ASSUME_NONNULL_BEGIN 和 NS_ASSUME_NONNULL_END，被这两个宏包裹的代码，默认都是 nonnull，如果可为空，则需显式声明为 nullable 或者 _Nullable。 null_resettable: 可被置 nil，但是调用 getter 时又会重新创建，可参考 UIViewController 的 view 属性 或者 UIView 的 tintColor 属性。 更多关于 Nullability 可参考： Nullability and Objective-CDifference between nullable, __nullable and _Nullable in Objective-C __kindof该关键字的出现可以很好的避免做强转，比如 UIView、UITableView 的如下方法/属性 123456789101112// UIView.h@property(nonatomic,readonly,copy) NSArray&lt;__kindof UIView *&gt; *subviews;- (nullable __kindof UIView *)viewWithTag:(NSInteger)tag;...// UITableView.h- (nullable __kindof UITableViewCell *)cellForRowAtIndexPath:(NSIndexPath *)indexPath;@property (nonatomic, readonly) NSArray&lt;__kindof UITableViewCell *&gt; *visibleCells;// 无警告，不需要做强转UIlabel *textLabel = view.subviews.firstObject; CustomCell *cell = self.tableView.visibleCells.lastObject; Generics为了更好的桥接 Swift，Objective-C 新增了轻量级的泛型支持，之所以是轻量级泛型，是因为它只是编译时的泛型。目前 Swift 仅支持 NSArray,、NSDictionary、NSSet 这 3 个类的泛型桥接，其它类(含自定义)，不支持。Using Objective-C Lightweight Generics __covariant子类可赋给父类 __contravariant父类可赋给子类，目前没有想到适用的场景，__kindof 和这个有点类似，但是又不一样，__kindof 可直接修饰属性。比如 @property (nullable, nonatomic, strong) __kindof NSObject *object; 协变和逆变的具体区别可参考，sunnyxx 的博客2015 Objective-C 新特性 __attributes__ 命令基本概念__attribute__ 命令是用来修饰 C/C++/Objective-C 中的代码片段，让它们拥有额外的属性，进而使编译器做出对应的优化或者为代码调用者提供有用的上下文（警告或提示）。进一步来讲，就是 __attributes__ 命令为我们提供了阅读代码的上下文，便于编译器提前做出优化，达到事半功倍的效果。 什么时候用Twitter 官方博客是推荐，能用且可以提供额外上下文的地方就尽量用。这样不仅可以让编译器做优化，同时可以让其他阅读代码的人（包括你自己）受益匪浅。当你想用却又在犹豫该不该用时，就不要用了。 怎么用虽然上面说到在能够使用的地方尽量使用，但是也不能乱用、滥用。具体例子可以参考下面提到的 Twitter 官方博客。 最开始接触 __attribute__ 命令是在 PSPDFUIKitMainThreadGuard.m，第一次看到这个的时候一脸懵逼，仅仅一个 .m 文件，就可以起到检测是否在主线程执行的作用，而且对项目毫无侵入。后面看了下源代码，然后每个方法都设置了一个断点，然后在非主线程操作 UI，看断点位置。结果运行后，就走到了一个方法： 12345678910111213141516171819202122// This installs a small guard that checks for the most common threading-errors in UIKit.// This won't really slow down performance but still only is compiled in DEBUG versions of PSPDFKit.// @note No private API is used here.__attribute__((constructor)) static void PSPDFUIKitMainThreadGuard(void) &#123; @autoreleasepool &#123; for (NSString *selStr in @[PROPERTY(setNeedsLayout), PROPERTY(setNeedsDisplay), PROPERTY(setNeedsDisplayInRect:)]) &#123; SEL selector = NSSelectorFromString(selStr); SEL newSelector = NSSelectorFromString([NSString stringWithFormat:@"pspdf_%@", selStr]); if ([selStr hasSuffix:@":"]) &#123; PSPDFReplaceMethodWithBlock(UIView.class, selector, newSelector, ^(__unsafe_unretained UIView *_self, CGRect r) &#123; PSPDFAssertIfNotMainThread(); ((void ( *)(id, SEL, CGRect))objc_msgSend)(_self, newSelector, r); &#125;); &#125;else &#123; PSPDFReplaceMethodWithBlock(UIView.class, selector, newSelector, ^(__unsafe_unretained UIView *_self) &#123; PSPDFAssertIfNotMainThread(); ((void ( *)(id, SEL))objc_msgSend)(_self, newSelector); &#125;); &#125; &#125; &#125;&#125; 具体代码就不分析了，就是 hook 了一些布局才会调用的函数，然后判断其是否在主线程。最有意思的是前面的修饰符__attribute__((constructor))，后面查阅资料才知道，该修饰符修饰的方法，在 main() 函数执行前， +load 方法执行后。 constructor 和 +load 都是在 main 函数执行前调用，但 +load 比 constructor 更加早一丢丢，因为 dyld（动态链接器，程序的最初起点）在加载 image（可以理解成 Mach-O 文件）时会先通知 objc runtime 去加载其中所有的类，每加载一个类时，它的 +load 随之调用，全部加载完成后，dyld 才会调用这个 image 中所有的 constructor 方法。Clang Attributes 黑魔法小记 __attribute__ 是编译器命令，后面会跟随两个括号对，主要是为了防止宏的歧义，方便宏的展开。 12345678910111213// +(void)load 执行之后，main() 执行之前，只对 C 方法生效// 若有多个 constructor 且想控制优先级的话，可以写成 __attribute__((constructor(101)))// 里面的数字越小优先级越高，1 ~ 100 为系统保留__attribute__((constructor))__attribute__((objc_requires_super)) // 子类复写时，必须先调用父类方法// ---------- // 用于 @interface 或 @protocol，将类或协议的名字在编译时指定成另一个__attribute__((objc_runtime_name("SomeClass")))@interface Some : NSObject@endNSLog(@"%@", NSStringFromClass([Some class])); // "SomeClass" 更多的 __attribute__ 命令可参考： Twitter 官方博客：attribute directives in Objective-CNSHipster 关于 __attribute__ 的讨论： attribute]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode 常用插件]]></title>
    <url>%2F2016%2F09%2F17%2FUseful-Xcode-Plugins%2F</url>
    <content type="text"><![CDATA[工欲善其事，必先利其器。随着 Xcode 的一步步变得强(yong)大(zhong)，许多功能已经被集成到 Xcode 中，但是日常开发还是会遇到很多小问题，影响效率，于是 Xcode plugins 便派上用场了。下面介绍一下自己在开发中常用的插件，排名不分先后，仅按字母排序。 关于 Xcode8 不能使用插件的问题，可以在我上一篇文章让你的 Xcode8 继续使用插件找到解决方案。 Alcatraz 这个就不用多说了吧，所有插件包管理器，快捷键 cmd + shift + 9。 ATProperty平时在属性声明时，总要写一堆的诸如 @property (strong, nonatomic) UIWindow *window;之类的，前面那一长串在属性一多时，写起来挺累的。这个插件正是为了解决这个痛点而存在，快捷键如下： 快捷键 结果 @t @property (nonatomic, strong) @w @property (nonatomic, weak) @y @property (nonatomic, copy) @a @property (nonatomic, assign) readonly 只需在 @ 后插入 r 即可，比如 @rt，就是 @property (nonatomic, strong, readonly) Auto-Importer 在写代码过程中，比如处在 line500 的时候要引入一个新的类，这个时候不得不滑到顶部，去写一次 #import&quot;xxxx.h&quot;，然后又滑回来继续写代码，严重影响效率。此时你需要这个插件来解决这个苦恼，随便一个地方，使用快捷键 cmd + ctrl + h 来呼出弹窗，在搜索框中输入想要导入的头文件即可，无需在滑到文件顶部，参考上图。 CATweakerSense用的不是很多，主要是在做动画比较有用，时间缓冲函数，将时间曲线可视化。 ColorSenseRainbow一目了然，颜色可视化。 DBSmartPanels智能化的区域隐藏插件，在输入时自动隐藏底部 debug、右侧 inspector 区域，具体可以自定义。 DXXcodeConsoleUnicodePlugin有时候在调试时，服务端返回的中文字符在 debug console 中总是显示成 unicode，这个插件可以将其自动转成中文字符。具体可到其 GitHub 主页查看用法。 FastStub 检测头文件、父类、协议等中的方法，然后自动在 .m 文件插入。快捷键 cmd + ctrl + k FuzzyAutocomplete快速补全。 GitDiff检测文件中的 git 状态。 RRConstraintsPlugin对系统 Auto Layout 的一些补充。 SCXcodeSwitchExpander switch 时根据枚举类型，自动补全所有枚举 SCXcodeTabSwitcher 此插件用于存在多个 tab 时在 tab 间快速切换，类似 Chrome。快捷键 Cmd + 1...9 切换。 VVDocumenter-Xcode这个不用多说了吧。快速注释，现已集成到 Xcode8。 XAlign对齐插件，可自定义对齐方式。 XQuit完全退出(cmd + q) Xcode 之前，弹出一个确认框，防止误操作。 XToDo用于工程中的一些标注，及快速查找这些标注的插件。 XVimVim 控必备。 以上便是个人常用的 Xcode 插件，欢迎推荐。]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
        <tag>插件</tag>
        <tag>Xcode8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让你的 Xcode8 继续使用插件]]></title>
    <url>%2F2016%2F09%2F10%2FMake-Your-Xcode8-Great-Again%2F</url>
    <content type="text"><![CDATA[随着 iOS10 的正式版即将发布，Xcode8 GM 也在发布会后放出，本文不会涉及到 Xcode8 有哪些更新，而是记录了如何让 Xcode8 继续支持 Plugin。 Update:2017.4.9 Xcode 8.3 生成 XcodeGr8 后，XVim 即使用脚本更新也会失效，需要重新编译一次。下载 XVim 到本地后，需要删除删除如下几个文件： IDEPlaygroundEditor+XVim.hIDEPlaygroundEditor+Xvim.m同时屏蔽掉 XVim/XVimHookManager.m 里面对上面两个文件的引用和调用 详情参考这个 issue: Build failure with Xcode 8.3 2016.10.8如果你的 XcodeGr8 时不时就转菊花卡死，可以试下这种方式：打开系统偏好设置-&gt;安全性与隐私-&gt;通讯录-&gt;将 Xcode 前面的勾去掉，如下图所示，解决方案来自 Xvim 的这个 issue。 2016.9.16看到 GitHub 上有一个 repo 可以一句命令即可解决本文提到的所有问题 update_xcode_plugins，没有亲测，如果觉得本文方法比较麻烦，可以一试。 我个人常用的 Xcode 插件可以参见这篇文章Xcode 常用插件。 相信各位已经有尝试过 Xcode-beta 了，但是会发现之前所有的插件都失效了。一开始我以为是和之前一样 Xcode 升级了，需要更新 Xcode info.plsit 中的 DVTPlugInCompatibilityUUID,于是运行了如下命令，具体修复原理和方案可以参考这篇文章 Xcode升级后插件失效的原理与修复办法。 1find ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I&#123;&#125; defaults write &#123;&#125; DVTPlugInCompatibilityUUIDs -array-add `defaults read /Applications/Xcode-beta.app/Contents/Info.plist DVTPlugInCompatibilityUUID` 结果还是无效，去 Github 上看，果然一堆人遇到了这个问题，可以看下这个 issue。由于 Xcode8 没了插件支持，我用的时候勉强还能习惯，一个用习惯了 Xvim 的同事表示不能忍，于是就去到 XVim 看有没有提这个 issue，果然也是有一堆人提到了这个问题，作者也给出了对应的解决方案，摘录最主要的一段如下： With Xcode 8 and above, you’ll be asked if you want to remove code singature from Xcode. It is required to make the XCode load XVim. So if you are OK just type ‘y’ to proceed and remove code signature from your Xcode. 但是我并没有按照这种方式来操作，而是结合这个 issue 中的解决方案，总结起来步骤如下： 编译 MakeXcodeGr8Again 并且导出其 product (关于 MakeXcodeGr8Again，下文会详细说到)。 退出 Xcode8，同时运行刚刚导出的 MakeXcodeGr8Again，将 Xcode8 拖入其中，等待一段时间(3~10分钟)。 等菊花转完后，应用程序文件夹下会生成一个 XcodeGr8 的应用，运行命令 sudo xcode-select -s /Applications/XcodeGr8.app/Contents/Developer 将 Xcode 开发路径指向刚生成的 XcodeGr8。 既然 Xcode8 的签名已被移除，那么就可以继续使用上面的修复插件失效代码。但是上面的脚本要稍微改一下就是把 Xcode.app 换成 XcodeGr8.app 即可。代码如下： 1find ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I&#123;&#125; defaults write &#123;&#125; DVTPlugInCompatibilityUUIDs -array-add `defaults read /Applications/XcodeGr8.app/Contents/Info.plist DVTPlugInCompatibilityUUID` 下面我们来看下步骤1提到的 MakeXcodeGr8Again，其 ReadMe 也有对应的介绍。这里大概摘录一下: 苹果为了避免类似 Xcode Ghost 👻 事件的再次发生，Xcode8 禁用了插件机制，而开放了另一种形式：Source Editor extensions，但是这种形式局限性太大。MakeXcodeGr8Again 只是去除了它的签名，这样使得 Xcode8 也可以继续使用插件了。由于签名被移除，所以它的安全性又重回 Xcode7 时代，也就是还有可能受到类似 Xcode Ghost 的攻击。所以不推荐用 XcodeGr8 来提交应用到 Appstore。Use at your own risk. PS：可能遇到的问题 1.生成了 XcodeGr8 之后，打不开。 解决方法：重启。 2.如果之前对其它版本的 Xcode-beat 也有使用这种方式，再对 Xcode8 GM 也是用该方式可能 MakeXcodeGr8Again 这个 APP 会一直闪退。 解决方法：卸载之前生成的 XcodeGr8，再重试。卸载后记得将开发路径重新指回原来的路径，即 sudo xcode-select -s /Applications/Xcode.app/Contents/Developer。如果这种方式还不行，卸载所有版本的 Xcode，然后再安装 GM 版，重复上述步骤。 PPS：如果要卸载 XcodeGr8，记得将重新开发路径置回初始状态。 最后，重要的事情说三遍：不要使用 XcodeGr8 打包上传 Appstore，最好使用服务器打包，保证服务器 Xcode 是 Appstore 下载的！！！不要使用 XcodeGr8 打包上传 Appstore，最好使用服务器打包，保证服务器 Xcode 是 Appstore 下载的！！！不要使用 XcodeGr8 打包上传 Appstore，最好使用服务器打包，保证服务器 Xcode 是 Appstore 下载的！！！]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
        <tag>插件</tag>
        <tag>Xcode8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS Animations by Tutorials 2.0 笔记]]></title>
    <url>%2F2016%2F08%2F27%2FNote-for-iOS-Animations-by-Tutorials%2F</url>
    <content type="text"><![CDATA[这本书主要分成七个部分，二十七个章节，涵盖了从底层的 Core Animation 到上层的 UIView 的动画封装，AutoLayout 动画以及 ViewController 之间的转场动画。最后选择了两个开源动画库（Easy Animation、pop）进行实践。本篇文章主要是在阅读、学习过程中的一些笔记，留下记录，日后忘记可以再来翻看。 Section Ⅰ View Animation这部分主要是关于 UIView 的动画，UIView 层次的动画是一些经过封装的上层 API，简单但是实用。基本都是日常用到的，比如位置、大小、透明度、旋转、关键帧动画等等，所以没啥好记录的。 View 之间的过渡转场主要是使用如下两个方法: 12345+ (void)transitionWithView:(UIView *)view duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^ __nullable)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(4_0);// toView added to fromView.superview, fromView removed from its superview+ (void)transitionFromView:(UIView *)fromView toView:(UIView *)toView duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(4_0); Section Ⅱ Auto Layout这部分主要是 Auto Layout 的相关动画，首先基本介绍了它的使用，然后通过同一个 Demo 层层递进。总得来说，不管是手写还是 IB,布局虽然看似静态的，但是它也是能做动画的。 这一部分的动画，无非就是改了约束，然后把 [view layoutIfNeeded] 放到动画 block 里面。不过在这里学会了一招，就是在 IB 里面可以为约束设置标识（identifier）有点类似于 view 的 tag。 Section Ⅲ Layer Animation这一部分通过几个 Demo 来着重介绍 CALayer 及其几个常用的子类、CAAnimation 及其子类。其中使用 CAShapeLayer、CAGradientLayer、CAReplicatorLayer 的实例都比较有趣。当 UIView 的那一套动画 API 已经无法满足需要时，这个时候应该转向更为底层的 Core Animation。UIView 的那一套动画 API 归根结底也是对 Core Animation 的封装。说白了，UIView 是 CALyaer 的 delegate.两者的具体区别如下: UIView CALayer 拥有复杂的视图布局及层级等 较简单的层级结构，所以能快速布局及绘制 可交互 不可交互 利用 CPU 在主线程做一些自定义绘制及其它逻辑 默认没有自定义逻辑，直接使用 GPU 绘制及缓存 灵活、实用 - 这里作者给出了选择 UIView 还是 Core Animation 来做动画的一些建议： choose view animations any time you can to do the job; you will know when you need more performance or flexibility and have to switch to layer animations instead.Don’t stress yourself about it though, because you can mix and match view and layer animations freely. 简单来说就是在 UIView 满足需求的时候尽量使用 UIView，当追求更好的性能及灵活性时可以考虑使用 Core Animation.当然，两者也可以混合使用。 fillMode这里借用书中的几张图来阐明一下各种模式 kCAFillModeRemoved 默认模式：动画执行完毕后恢复原样 kCAFillModeBackwards 动画开始前展示第一帧 kCAFillModeForwards 动画结束后 layer 维持最后一帧的状态 kCAFillModeBoth 是上面两种模式的结合，动画开始前维持第一帧，动画结束后维持最后一帧 Layer 弹性动画这一节以钟摆举例，来解释弹性阻尼动画的相关属性。 damping 阻尼？不知道是不是这么翻译，主要是由空气摩擦、机械摩擦以及其它外界阻力造成的。 mass 惯性？物体的质量越大，振荡时间越长。 stiffness 重力加速度（G） initial velocity 初始速度，开始运动前，外界的推（拉力）产生的速度 某些情况下，UIView 的弹性阻尼动画看起来胡比较生硬，因为在指定的 duration 内无法停下来，而被系统强制停下来，所以看起来很生硬。就如下图： 如果 duration 为0.25，此时本应该还有振荡，但是动画时间已到，只能强制停止振荡，进而使动画看起来略微生硬。所以 CASpringAnimation 里面有一个属性叫做 settlingDuration,该属性表示所有动画参数设定好之后，振荡完成是所需时间，如果将 duration 设置成这样，那么动画看起来就会很自然。 友情提示：请在设置好所有弹性振荡参数之后再设置 duration. Section Ⅳ 3D Animations这部分主要通过一个侧拉菜单的 Demo 讲解了 3D 动画该如何实现。关键还是在于 CATransform3D 中的 m34 以及配合改变 anchor point,要想让视图看起来具有 3D 透视效果，可以将 m34 设置为 -1.0 / [camera distance], 分母代表相机离视图的距离. 关于距离选值与透视效果的明显程度可参见下表： distance 0.1~500 失真较严重 700~2000 效果最好，逼真 &gt;2000 几乎没有透视效果 Section Ⅴ Further Types of Animations这部分主要是讲一些其它动画的延伸，比如粒子动画、ImageView 的帧动画。粒子动画主要使用 CAEmitterLayer 来做，具体细节可以参考 CAEmitterLayer 的 API。帧动画主要是讲解 UIImageView 关于使用图片数组产生帧动画的效果，基本就是改变其 animationDuration 来达到控制帧率的效果。 Section Ⅵ View Controller Transitions这一部分主要是将视图控制器之间过渡的转场效果动画。关于这里，不再过多记录，毕竟关于 VC 之间的转场效果 GitHub 上一抓一大把了，随便拿一个读一读源码即可，万变不离其宗。 Section Ⅶ Third-Party Animation Libraries这部分主要是两个开源动画库的使用，找个时间读一读源码，另外再写一篇文章。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebView 与 JS 的交互]]></title>
    <url>%2F2015%2F10%2F19%2FCommunication-Between-WebView-and-JS%2F</url>
    <content type="text"><![CDATA[本文主要分析一些 iOS 中 WebView 与 JavaScript 交互的一些框架。 UIWebView 调 JS 方法通过调用如下方法： 1- (NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script; 比如获取网页 title，也可以动态注入 JS，先写一个 JS 函数 123function showAlert() &#123; alert('show alert'); &#125; 然后保存为js 文件，最后读取这个文件并注入 123NSString *filePath = [[NSBundle mainBundle] pathForResource:@"test" ofType:@"js"]; NSString *jsString = [[NSString alloc] initWithContentsOfFile:filePath]; [webView stringByEvaluatingJavaScriptFromString:jsString]; JS 调原生方法直接调用无法做到，可以间接实现。 方法1JS 中要从现在的网页跳到另外一个网页的时候，就会去修改 window.location.href ，而在 @protocol UIWebViewDelegate 中有一个回调方法 1- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType; 可以监听到网页的跳转，所以可以在此做文章。通过指定window.location.href = schemename://nativemethodname:args就可以去间接调用到原生函数。JS 一旦修改了window.location.href，UIWebView就会收到相应回调，也就是上面说的方法，这样我们可以通过判断request的url是否为自定义的 scheme来决定是否调用原生函数。 方法2创建iframe，设置src，并插入到body节点 123456789function execute(url) &#123; var iframe = document.createElement("IFRAME"); iframe.setAttribute("src", url); document.documentElement.appendChild(iframe); iframe.parentNode.removeChild(iframe); iframe = null;&#125;execute("schemename://nativemethodname:args"); 上述的这一串schemename://nativemethodname:args由客户端和前端约定好即可。剩余的事就是截获这个request，然后解析得到相应的参数，传入要调用的原生函数即可。同时在回调方法中要return NO。大致代码如下： 1234567891011- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType&#123; NSURL *requestUrl = request.URL; if ([requestUrl.scheme isEqualToString:@"schemename"]) &#123; NSArray *components = [requestUrl.absoluteString componentsSeparatedByString:@":"]; NSString *resultJSONString = [components[2] stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; [self customMethod:resultJsonString]; return NO; &#125; return YES;&#125; WebViewJavaScriptBridge 实现原理大致原理与上面说的一致。只不过WebViewJavaScriptBridge进行了更完善的封装，使得 JS与Native之间的通信变得更为简便。 一开始注入WebViewJavaScriptBridge.js,该文件中的JS方法主要做了以下几件事 创建了一个用于发送消息的iFrame(通过创建一个隐藏的ifrmae，并设置它的URL 来发出一个请求，从而触发UIWebView的shouldStartLoadWithRequest回调协议) 创建了一个核心对象WebViewJavaScriptBridge，并给它定义了几个方法，这些方法大部分是公开的API方法 创建了一个事件：WebViewJavaScriptBridgeReady，并dispatch。## native将方法名、参数、回调的id放到一个对象中传给js。js根据方法名字调用相应方法，之后将返回数据和responseId拼装，最后通过src 重定向到UIWebview 的delegate。native得到数据后根据responseId调用事先装入_responseCallbacks的block，动态读取调用，从而完成交互。 流程（Native端）Public Interface12345678910+ (instancetype)bridgeForWebView:(WVJB_WEBVIEW_TYPE*)webView handler:(WVJBHandler)handler;+ (instancetype)bridgeForWebView:(WVJB_WEBVIEW_TYPE*)webView webViewDelegate:(WVJB_WEBVIEW_DELEGATE_TYPE*)webViewDelegate handler:(WVJBHandler)handler;+ (instancetype)bridgeForWebView:(WVJB_WEBVIEW_TYPE*)webView webViewDelegate:(WVJB_WEBVIEW_DELEGATE_TYPE*)webViewDelegate handler:(WVJBHandler)handler resourceBundle:(NSBundle*)bundle;+ (void)enableLogging;- (void)send:(id)message;- (void)send:(id)message responseCallback:(WVJBResponseCallback)responseCallback;- (void)registerHandler:(NSString*)handlerName handler:(WVJBHandler)handler;- (void)callHandler:(NSString*)handlerName;- (void)callHandler:(NSString*)handlerName data:(id)data;- (void)callHandler:(NSString*)handlerName data:(id)data responseCallback:(WVJBResponseCallback)responseCallback; 初始化一个 bridge初始化的工作主要如下： 设置默认的消息处理 block ———— messageHandler 初始化用来保存消息处理 block 的字典 ———— messageHandlers 初始化消息队列数组 ———— startupMessageQueue 初始化响应回调 ———— responseCallbacks 以及初始化全局唯一标识 ———— uniqueId 当在外部调用 1- (void)registerHandler:(NSString *)handlerName handler:(WVJBHandler)handler; 方法时，会将 handler 保存到上面初始化好的 messageHandlers 当中，key为上述方法中的 handlerName，value 为上述方法的 handler。 1- (void)sendData:(id)data responseCallback:(WVJBResponseCallback)responseCallback handlerName:(NSString*)handlerName; 发送消息时，会将消息加入到消息队列数组，加到数组当中的object 为字典型，字典有三个 key，分别为 data，callbackId， handlerName，分别对应上述方法的三个参数。入队时，如果当前消息队列存在，则将该消息入队，否则立即分发该消息。 网页加载过程1- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType; 加载请求或 html 时，在 shouldStartLoadWithRequest 回调中会先判断请求是否带自定义协议。如果带有自定义协议，会调用注入的 js 中 WebViewJavaScriptBridge 的_fetchQueue 方法来获取当前消息，然后分发该消息。主要是在分发消息这一块，拿到消息 json 然后序列化，如果这个消息是队列(数组)才进行处理，消息队列中也是一系列字典型对象，这些对象可能有这么几个key：responseId，responseData，callbackId，handlerName，data。然后对消息队列做一个遍历大致逻辑如下： 如果 responseId 对应的 value 存在，那么就到 responseCallbacks 字典中去寻找对应的 WVJBResponseCallback 型回调 block，然后执行，block 参数为 responseData 对应的 value。然后把这个 block 从 responseCallbacks 字典中移除。 如果 responseId 对应的 value 不存在，再看 callbackId 对应的 value 是否存在，存在则设置回调 responseCallback，这个 responseCallback 主要是创建一个消息，然后是消息入队，这个消息字典为 @{ @&quot;responseId&quot;:callbackId, @&quot;responseData&quot;:responseData }；反之 responseCallback 中什么也不执行；最后判断 handlerName 对应的 value 是否存在，存在则取 messageHandlers 中对应的回调 handler，不存在就是用默认的 handler，最后执行这个 WVJBHandler 型的 handler，参数为 data 对应的 value 以及 responseCallback。 文字有点多，参考下下面这个流程图： 1- (void)webViewDidFinishLoad:(UIWebView *)webView; 加载结束的回调中判断 js 是否初始化了 WebViewJavaScriptBridge实例，如果不存在，就注入本地的 js。然后检测到 bridge 调用自定义 scheme 后会分发整个消息队列即 startupMessageQueue，遍历消息队列然后取出每一个消息对象(NSDictionary) 然后将其序列化成 JSON，在主线程中调用 JS 的 WebViewJavaScriptBridge._handleMessageFromObjC 方法，参数就是序列化后的 JSON 数据。分发完成后，将 startupMessageQueue 队列置为 nil。 至此 OC 端的整个流程完毕。 JS 端流程JS 端流程和 OC 端流程大致是一样的 Public Interface123456function init(messageHandler)function send(data, responseCallback)function registerHandler(handlerName, handler)function callHandler(handlerName, data, responseCallback)function _fetchQueue()function _handleMessageFromObjC(messageJSON) 初始化类似 OC 中的初始化 注入一个默认的 messageHandler 初始化一个消息接收队列，然后调用内部方法 _dispatchMessageFromObjC 来分发消息,同时将消息接收队列置空 发送消息调用内部 function _doSend(message, responseCallback) 函数，该函数通过判断 responseCallback 回调是否存在，存在则将这个回调存入到 responseCallbacks 字典中，其 key 是全局唯一的，同时将这个 key 存入到 message 这个字典参数中，其 key 和 value 一致，及 message[‘key’] = key。接着把这个 message 参数入队即加到 sendMessageQueue 数组中。然后重定向 frame 的 src，这样 OC 端就可以在代理回调方法中去拦截这个 src 对应的 request。 消息处理机制如果消息接受队列存在则将消息 JSON 入队即添加到 receiveMessageQueue 数组中。反之，调用内部消息分发方法 1function _dispatchMessageFromObjC(messageJSON) 分发机制类似 OC 端的那张流程图，在此不做详述。 注册及调用 handler 注册：在 messageHandlers 这个字典添加对应的 key 和 value。key 为 name，value 为 handler 调用：类似发送消息，message 参数为 { handlerName:handlerName, data:data } 获取消息队列(供 OC 端调用)这里会将消息发送数组进行 JSON 转化，转换后清空消息队列，然后返回给 OC 端。 内部注入的 JS上面说的所有都在内部注入的 JS(WebViewJavaScriptBridge.js.txt) 中完成,该 JS 做的事情在上述的实现原理中也有提到，这里不再展开。 外部 html 或 js 需要处理的事可参考下例的写法： 1234document.addEventListener('WebViewJavascriptBridgeReady', function(event) &#123; var bridge = event.bridge // Start using the bridge&#125;, false) 可将上述代码封装到一个 JS 函数中，然后在函数中进行其它一系列操作，如init，send 等具体参见 Demo。 JavaScriptCore(iOS7 &amp; OS X 10.9 later)主要的类: JSVirtualMachine：非常轻量，可初始化多个 VM 来支持 JS 中的多线程 JSContext：给 JS 提供运行上下文环境以及一系列值操作(通过下标来获取，类似 NSdictionary，即context[@”objectKey”])，一个 VM 中可有多个 context JSValue：数据桥梁 JSManagedValue：用于解决 retain cycle OC 调用 JSJSContext 可调用 evaluateScript: 方法来执行某个脚本如下： 12345[context evaluateScript:@”var square = function(x) &#123;return x*x;&#125;”]; JSValue *squareFunction = context[@”square”]; NSLog(@”%@”, squareFunction); // function (x) &#123;return x*x;&#125;JSValue *aSquared = [squareFunction callWithArguments:@[context[@”a”]]]; NSLog(@”a^2: %@”, aSquared); //a^2: 25JSValue *nineSquared = [squareFunction callWithArguments:@[@9]]; NSLog(@”9^2: %@”, nineSquared); //81 JS 调用 OC两种方式： Block JSExport 协议 Block1234567891011context[@"factorial"] = ^(int x) &#123; int factorial = 1; for (; x &gt; 1; x--) &#123; factorial *= x; &#125; return factorial; &#125;;[context evaluateScript:@"var fiveFactorial = factorial(5);"];JSValue *fiveFactorial = context[@"fiveFactorial"];// 5! = 120NSLog(@"5! = %@", fiveFactorial); 值得注意的是： 不要在 block 中持有 JSValue，而是应该将JSValue 作为参数来传递 不要在 block 中持有 JSContext，可通过 [JSContext currentContext]来获取当前 context 1234JSContext *context = [[JSContext alloc] init]; context[@"callback"] = ^&#123; //错误示例 JSValue *object = [JSValue valueWithNewObjectInContext:context]; //正确的姿势 JSValue *object = [JSValue valueWithNewObjectInContext: [JSContext currentContext]]; object[@"x"] = 2; object[@"y"] = 3; return object; &#125;; JSExport 协议如果没有这个协议，OC 端的修改会同步到 JS 端，但是 JS 端的修改对 JS 和 OC 均无影响。见下例 12345678910111213141516171819202122232425262728//TestModel.m- (NSString *)description&#123; NSString *str = [@"TestModel With testString:" stringByAppendingString:self.testString]; return [str stringByAppendingString:[NSString stringWithFormat:@" and numberStr:%@",self.numberStr]];&#125;// viewDidLoadTestModel *model = [[TestModel alloc] init];model.testString = @"test string";model.numberStr = @"123";JSContext *context = [[JSContext alloc] initWithVirtualMachine:[[JSVirtualMachine alloc] init]];context[@"model"] = model;JSValue *modelValue = context[@"model"];// model: TestModel With testString:test string and numberStr:123NSLog(@"model: %@",model);// model JSValue: TestModel With testString:test string and numberStr:123NSLog(@"model JSValue: %@",modelValue);model.numberStr = @"456";// model: TestModel With testString:test string and numberStr:456NSLog(@"model: %@",model);// model JSValue: TestModel With testString:test string and numberStr:456NSLog(@"model JSValue: %@",modelValue);[context evaluateScript:@"model.testString = \"anotoher test\";model.numberStr = \"789\""];// model: TestModel With testString:test string and numberStr:456NSLog(@"model: %@",model);// model JSValue: TestModel With testString:test string and numberStr:456NSLog(@"model JSValue: %@",modelValue); 如果想要上述 JS 修改起作用,则需要实现 JSExport 协议。通过实现该协议来暴露自定义类给 JS，这样 JS 会为这个类创建一个 wrapper object，这样看起来就像 OC 和 JS 在互相传值一样。这样，一个对象可以在 JS 和 OC 间共享，任何一端的更改都将同步到另外一端。需要注意的是，JS 只能修改暴露在协议中的属性或调用协议中的方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// .h@protocol TestModelDelegate &lt;JSExport&gt;@property (nonatomic, copy) NSString *testString;- (void)modelTest;@end@interface TestModel : NSObject &lt;TestModelDelegate&gt;@property (nonatomic, copy) NSString *testString;@property (nonatomic, copy) NSString *numberStr;@end// .m- (NSString *)description&#123; NSString *str = [@"TestModel With testString:" stringByAppendingString:self.testString]; return [str stringByAppendingString:[NSString stringWithFormat:@" and numberStr:%@",self.numberStr]];&#125;- (void)modelTest&#123; NSLog(@"modelTest!!!");&#125;- (void)test&#123; NSLog(@"Test!!!");&#125;// viewDidLoad[context evaluateScript:@"model.testString = \"anotoher test\";model.numberStr = \"567\""];// model: TestModel With testString:anotoher test and numberStr:123NSLog(@"model: %@",model);// model JSValue: TestModel With testString:anotoher test and numberStr:123NSLog(@"model JSValue: %@",modelValue);// modelTest!!![context evaluateScript:@"model.modelTest()"];JSValue *unknowValue = [context evaluateScript:@"model.test()"];// unknowValue :undefinedNSLog(@"unknowValue :%@",unknowValue); 上例中的 numberStr 之所以还是保持为 123 是因为，这个属性不在协议中，JS 对其修改不起作用，同样如果 JS 中调用 model 不在协议中的方法，也不起作用，如果用 JSValue 去接收这个值，其值为 undefined。没有任何响应，如果用一个 JSValue 去接收上面代码的值，得到的是 undifine 对象对应关系 Objective-C type JavaScript type nil undefined NSNull null NSString string NSNumber number, boolean NSDictionary Object object NSArray Array object NSDate Date object NSBlock Function object id Wrapper object Class Constructor object UIWebView 与 JavaScriptCore 的交互UIWebview 也有一个 JSContext 实例，但是没有暴露在 API 中，但是我们可以通过 KVC 或者在 NSObject 分类去拿到这个实例，然后来进行自定义的一些操作。关于 NSObject 分类实现可以参考这里。但是这两种方法都有可能被拒。 其实WebView 与 JS 的交互和上述的 TestModel 与 JS 交互区别不大。只不过上例都是自己创建的 context，而在webView 中则是我们通过 KVC 来拿到这个 context 而不是自己创建。来看一个例子： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script&gt; function test() &#123; objcObject.testDemo(); alert(objcObject); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;JavaScriptCore Demo&lt;/h1&gt; &lt;button type="button" onclick="test()"&gt;测试&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 上述 html 简单创建了一个 button，然后绑定一个事件。接下来看看 ViewController 里面做了什么。 1234567891011121314151617181920212223242526272829// .h@protocol TestJSDelegate &lt;JSExport&gt;- (void)testDemo;@end@interface WebViewController : UIViewController &lt;TestJSDelegate,UIWebViewDelegate&gt;@end// .m- (void)viewDidLoad&#123; [super viewDidLoad]; NSURL *path = [[NSBundle mainBundle] URLForResource:@"test" withExtension:@"html"]; NSString *html = [NSString stringWithContentsOfURL:path encoding:NSUTF8StringEncoding error:nil]; [self.webView loadHTMLString:html baseURL:nil];&#125;- (void)webViewDidFinishLoad:(UIWebView *)webView&#123; JSContext *context = [webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"]; context[@"objcObject"] = self;&#125;- (void)testDemo&#123; NSLog(@"test!!!");&#125; 运行效果: 如果协议方法中有多个参数该怎么调用呢？举个例子 12345// ObjC 中的某个协议方法- (void)testWithName:(NSString *)name age:(NSNumber *)age&#123; NSLog(@"name:%@,age:%@",name,age);&#125; 12// 在上述 html 的 js 中添加一行代码objcObject.testWithNameAge("Tracy",20); 那么在按钮点击后，协议方法将会被执行，然后打印出 name:Tracy,age:20。 内存管理OC 中是用的是 ARC，JavaScriptCore 中用的是垃圾回收机制（garbage collection）,JavaScriptCore 中所有引用都为强引用。在大部分情况下，JavaScriptCore 能做到在这两种内存管理机制之间无缝切换，但是在以下两种情况下需要特别注意： 在 OC 对象中存储 JavaScript 值 在 OC 对象中添加 JavaScript 域 如下例就会造成循环引用： 12// ClickHandler 构造器，button 为 OC 对象，callback 是按钮点击事件回调function ClickHandler(button, callback) &#123; this.button = button; this.button.onClickHandler = this; this.handleEvent = callback; &#125;; 1@implementation MyButton - (void)setOnClickHandler:(JSValue *)handler &#123; _onClickHandler = handler; // Retain cycle &#125; @end 上例中 ClickHandler 对 button 进行了强引用，而 MyButton 中又对 _onClickHandler 这个 JSValue 进行了强引用，最终导致循环引用，如下图所示： 如果将 _onClickHandler 设置为 weak，那么我们将收不到点击事件回调。 举个栗子，在某个方法中有一个临时的 OC 对象，然后通过 JSContext 被 JS 中的变量引用，但是该 OC 方法调用结束后，这个临时对象将被释放，因此 JS 会造成错误访问。 同样的，如果用 JSContext 创建了对象，然后在 OC 中用 JSValue 去接收，即使把 JSValue 变量在 OC 中被 retain，但可能因为 JS 中因为变量没有了引用而被释放内存，那么对应的JSValue也没有用了。 所以苹果引入了另一个类来解决这种循环引用的问题。 123@implementation MyButton - (void)setOnClickHandler:(JSValue *)handler &#123; //正确的姿势 _onClickHandler = [JSManagedValue managedValueWithValue:handler]; [_context.virtualMachine addManagedReference:_onClickHandler withOwner:self] &#125; @end addManagedReference做的事情主要如下：它创建了一个 garbage collected reference，这种引用既不是强引用也不是弱引用。 JSManagedValue 本身是一个对 JavaScript Value 的弱引用，而 JSValue 是强引用。addManagedReference 将 JSManagedValue 转换为 garbage collected reference。如果 JS 在垃圾回收过程中能够找到 managed reference 的所有者，那么这个引用将不会被释放，否则将被释放。JSManagedValue 需要调用其addManagedReference:withOwner: 方法把它添加到JSVirtualMachine 中，确保使用过程中 JSValue 不会被释放。 多线程如前面所说，每一个 JSVirtualMachine 都可以有多个 JScontext，在每个进程中又可以有多个 JSVirtualMachine。JSValue 可以在同一个 JSVirtualMachine 中的不同 JSContext 之间传递，但是不能跨 JSVirtualMachine 来传递。因为每个 JSVirtualMachine 都有自己的内存堆以及垃圾回收器，如果 JSValue 跨 JSVirtualMachine 传递，那么垃圾回收器将不知如何处理来自不同内存堆的 JSvalue。 JavaScriptCore 的 API 是线程安全的 同步锁粒度：JSVirtualMachine，即我们可以在 JSVirtualMachine 不同线程中调用 JS，但是如果有线程正在执行 JS，那么其它线程将不能执行 JS 操作。所以要想进行并发操作，那么需要为每个操作创建一个单独的 JSVirtualMachine 来实现并发。 WKWebView (iOS8 and later)新特性 在性能、稳定性、功能方面有很大提升（最直观的体现就是加载网页是占用的内存）； 允许JavaScript的Nitro库加载并使用（UIWebView中限制）； 支持了更多的HTML5特性以及 native 和 web 的高效交互； 高达60fps的滚动刷新率以及内置手势； 将UIWebViewDelegate与UIWebView重构成了14类与3个协议 WebKit 为非线程安全的，所以要确保该 framework 的所有方法在主线程上调用。 更多内容请参考Nshipster。 总结总得来说两种方式都可以实现二者的交互，JavaScriptBridge 相对而言复杂一些，但是安全且不需要做版本适配，APP 上架不会被拒，但是 JavaScriptCore 更加简洁，不需要写繁琐的代码，但是有被拒的风险，同时这个框架是在 iOS7 之后才有，所以如果要适配 iOS6的话还是选择 JavaScriptBridge。 本文 Demo]]></content>
      <categories>
        <category>框架学习</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>WebView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何创建一个翻书动画(Part2)[译]]]></title>
    <url>%2F2015%2F09%2F01%2FHow-to-Create-an-iOS-Book-Open-Animation-part-two-translation%2F</url>
    <content type="text"><![CDATA[欢迎回到 iOS 翻书动画教程系列！在该系列的第一部分(译文)，你已经知道如何创建自定义的 layout 以及如何在 app 中使用阴影效果来创建景深和模拟现实。在这篇教程中，你将学到如何创建一个自定义的转场以及如何使用 pinch 手势来打开书本。 2019.11.21 update本文中图片和资源相关链接可能已失效，如需查阅，请查看原文感谢Attila Hegedüs创建了这个棒棒哒示例工程。 原文：How to Create an iOS Book Open Animation: Part 2 开始这篇教程基于第一部分。如果你不了解第一部分或者想重新开始，可以下载上一教程的完整代码。 在 Xcode 中打开工程。现在你可以选择一本书，然后书本从右滑出(即 push)，这是 UINavigationController 的默认转场行为。但是在这片教程结束的时候，自定义转场看起来像这样： 自定义转场将在书本打开和合上的状态转换中进行丝滑的动画过渡，这种方式非常自然，深得我心。来吧，骚年，开撸！ 创建自定义导航控制器想要实现自定义转场必须创建一个自定义的导航控制器然后实现 UINavigationControllerDelegate 协议。右键 App 分组创建一个继承自 UINavigationController 名为 CustomNavigationController 的类。语言设置为 Swift。 打开CustomNavigationController.swift，用下面代码替换其内容： 1234567891011121314151617181920212223import UIKit class CustomNavigationController: UINavigationController, UINavigationControllerDelegate &#123; override func viewDidLoad() &#123; super.viewDidLoad() //1 delegate = self &#125; //2 func navigationController(navigationController: UINavigationController, animationControllerForOperation operation: UINavigationControllerOperation, fromViewController fromVC: UIViewController, toViewController toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123; if operation == .Push &#123; return nil &#125; if operation == .Pop &#123; return nil &#125; return nil &#125;&#125; 上面代码主要做了两件事： 1.在 viewDidLoad 方法中将代理设置为自身 2.navigationController(_:animationControllerForOperation:fromViewController:toViewController:) 方法是协议方法中的一个。这个方法在每次 push 或者 pop 的时候被调用，你可以在此返回对应的转场类型动画。现在这个方法返回 nil 使得其使用默认的标准转场。马上你就会用你自定义的转场类来替换它。 既然导航控制器已经准备就绪，那么让我们开始来替换 storyboard 中默认的导航控制器 设置如下图所示： 运行一下，确保能正常运行，一切正常，因为你在代理方法中返回 nil，导致控制器使用默认转场行为。 创建自定义转场终于来到重头戏环节————撸一个自定义转场！在自定义转场类中，必须遵循 UIViewControllerAnimatedTransitioning 协议，特别是需要实现下面几个方法： transitionDuration：必须实现。返回转场动画时间，以及同步交互转场动画 animateTransition：必须实现。提供转场过程中的源控制器和目的控制器。自定义转场的工作重心主要是在这个方法中完成 animationEnded：可选实现。在转场结束时调用。可以在该方法中还原之前的设置 设置你的转场右键 App 分组新建一个继承自 NSObject 名为 BookOpeningTransition 的类，设置语言为 Swift。 打开它，然后用下面代码来替换其所有内容： 1234567891011121314151617181920import UIKit //1class BookOpeningTransition: NSObject, UIViewControllerAnimatedTransitioning &#123; // MARK: Stored properties var transforms = [UICollectionViewCell: CATransform3D]() //2 var toViewBackgroundColor: UIColor? //3 var isPush = true //4 //5 // MARK: UIViewControllerAnimatedTransitioning func transitionDuration(transitionContext: UIViewControllerContextTransitioning) -&gt; NSTimeInterval &#123; return 1 &#125; func animateTransition(transitionContext: UIViewControllerContextTransitioning) &#123; &#125;&#125; 每个数字标号注释的解释： 1.BookOpeningTransition 实现了 UIViewControllerAnimatedTransitioning 协议 2.字典 transforms 存储了键为 UICollectionViewCell 值为 CATransform3D类型的键值对。当书本打开时，它存储了每个 cell 的 transform 3.定义了目的控制器的背景色，使得渐变看起来更加清爽 4.isPush 决定了转场为 push 还是 pop 5.添加了协议中必须实现的方法避免编译器报错。紧接着就是要实现这些方法 一切变量设置就绪，是时候来实现协议方法了。 用下面代码来替换 transitionDuration(_:) 中的内容： 12345if isPush &#123; return 1&#125; else &#123; return 1&#125; 该方法返回了转场动画持续的时间，这里 pop 和 push都返回1秒。这个方法可以轻松改变转场动画的持续时间。接下来需要实现第二个必须是闲的方法——animateTransition，这个方法让一切变得皆有可能。你将分两部分来实现： 写两个工具方法来分别实现 push 和 pop 的animateTransition。 创建 push 转场回想一下实际生活中，你翻书的场景： 看起来很复杂，但是你只需要关心动画的两种状态，然后让 UIView 的 animateWithDuration 方法来实现两种状态之间的过渡： 1.第一阶段：书被合上 2.第二阶段：书被打开 在实现 animateTransition(_:) 前，首先写一个工具方法来处理两种状态。还是在 BookOpeningTransition.swift 中，在最后添加： 123456// MARK: Helper Methodsfunc makePerspectiveTransform() -&gt; CATransform3D &#123; var transform = CATransform3DIdentity transform.m34 = 1.0 / -2000 return transform&#125; 该方法返回一个 transform，以及添加一个 z 轴上的透视。后面动画过程中你将会用到它来改变 view。 第一阶段——书本合起接着在上述方法后面添加： 12345678910111213141516171819202122232425func closePageCell(cell : BookPageCell) &#123; // 1 var transform = self.makePerspectiveTransform() // 2 if cell.layer.anchorPoint.x == 0 &#123; // 3 transform = CATransform3DRotate(transform, CGFloat(0), 0, 1, 0) // 4 transform = CATransform3DTranslate(transform, -0.7 * cell.layer.bounds.width / 2, 0, 0) // 5 transform = CATransform3DScale(transform, 0.7, 0.7, 1) &#125; // 6 else &#123; // 7 transform = CATransform3DRotate(transform, CGFloat(-M_PI), 0, 1, 0) // 8 transform = CATransform3DTranslate(transform, 0.7 * cell.layer.bounds.width / 2, 0, 0) // 9 transform = CATransform3DScale(transform, 0.7, 0.7, 1) &#125; //10 cell.layer.transform = transform&#125; 我们对每一个页面做了转换使其与书脊对齐，然后翻页时围绕着个轴做旋转来达到真实的翻阅效果。首先你想要书本是合上状态。这个方法使得每个页面平铺在封面的底部。如下图所示： 我们来解释一下上面的代码： 1.使用之前创建的工具方法初始化一个新的 transform 2.判断页面是否在书脊右侧 3.如果是右侧页面，设其角度为0，使其呈平铺状态 4.将页面居中并位于封面之下 5.使页面的x，y 均乘以0.7.如果你不知道为什么要乘以0.7，回想上一篇教程中你曾将封面缩小到0.7。 6.如果不是右侧页面，那就是左侧页面 7.设置左侧页面角度为180度。 8.使其位于封面之下，并居中 9.同5 10.设置 cell 的 transform 现在添加如下代码到上面方法之前： 1234567891011121314151617181920212223func setStartPositionForPush(fromVC: BooksViewController, toVC: BookViewController) &#123; // 1 toViewBackgroundColor = fromVC.collectionView?.backgroundColor toVC.collectionView?.backgroundColor = nil //2 fromVC.selectedCell()?.alpha = 0 //3 for cell in toVC.collectionView!.visibleCells() as! [BookPageCell] &#123; //4 transforms[cell] = cell.layer.transform //5 closePageCell(cell) cell.updateShadowLayer() //6 if let indexPath = toVC.collectionView?.indexPathForCell(cell) &#123; if indexPath.row == 0 &#123; cell.shadowLayer.opacity = 0 &#125; &#125; &#125;&#125; 该方法设置了第一阶段的转场。它同时使用两个 VC 来做动画： fromVC：即书单 VC toVC：书页 VC 相关解释： 1.存储 BooksViewController 的 collectionView 的背景色，设置 BookViewController 中 collectionView 的背景色为 nil 2.隐藏选中书籍的封面，toVC 将会处理封面图片的呈现 3.遍历书本页面 4.保存每个 cell 打开状态下的transform 5.因为书本一开始是合上的，所以需要合上所有页面然后更新阴影层 6.最后忽略封面的阴影 第二阶端——打开书籍我们已经完成第一阶段的过渡转场，是时候撸一撸第二阶段的了。第二阶段是有闭合到打开的状态。 在 setStartPositionForPush(_:toVC:)) 方法下添加如下代码： 123456789101112func setEndPositionForPush(fromVC: BooksViewController, toVC: BookViewController) &#123; //1 for cell in fromVC.collectionView!.visibleCells() as! [BookCoverCell] &#123; cell.alpha = 0 &#125; //2 for cell in toVC.collectionView!.visibleCells() as! [BookPageCell] &#123; cell.layer.transform = transforms[cell]! cell.updateShadowLayer(animated: true) &#125;&#125; 分析一下上面的代码： 1.隐藏所有书的封面，因为我们将展示选中书籍的页面。 2.遍历所有页面然后加载之前保存的打开状态下的 transform 当你从 BooksViewController push 到 BookViewController 之后，还原之前的一些设置。 加入以下代码： 1234func cleanupPush(fromVC: BooksViewController, toVC: BookViewController) &#123; // Add background back to pushed view controller toVC.collectionView?.backgroundColor = toViewBackgroundColor&#125; push 完成后将 BookViewController 的背景色设置为你之前保存的背景色，将下面所有东西都隐藏起来。 实现开书转场上面所有工具方法已经整装待发，接着我们来实现 push 动画。将下面代码加到 animateTransition(_:) 中： 1234567891011121314151617181920212223242526//1let container = transitionContext.containerView()//2if isPush &#123; //3 let fromVC = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey) as! BooksViewController let toVC = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey) as! BookViewController //4 container.addSubview(toVC.view) // Perform transition //5 self.setStartPositionForPush(fromVC, toVC: toVC) UIView.animateWithDuration(self.transitionDuration(transitionContext), delay: 0.0, usingSpringWithDamping: 0.7, initialSpringVelocity: 0.7, options: nil, animations: &#123; //6 self.setEndPositionForPush(fromVC, toVC: toVC) &#125;, completion: &#123; finished in //7 self.cleanupPush(fromVC, toVC: toVC) //8 transitionContext.completeTransition(finished) &#125;)&#125; else &#123; //POP&#125; 下面解释一下上面代码做了哪些事： 1.获取容器视图，它在转场过程中充当父视图角色。 2.判断当前是执行 push 操作 3.获取 fromVC 和 toVC 4.将 toVC 加入到当前容器视图 5.设置闭合状态下 toVC 和 fromVC 的起始位置 6.从起始位置做动画，直到终点位置 7.还原设置 8.告知系统转场已完成 在导航控制器中使用 push 转场上面我们已经实现了 push 转场动画，是时候来使用它了。打开 BooksViewController.swift 将下面属性添加到类声明之后： 1var transition: BookOpeningTransition? 这个属性是转场类实例，它帮助你判断当前转场是 push 还是 pop。添加如下扩展： 123456789101112extension BooksViewController &#123;func animationControllerForPresentController(vc: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123; // 1 var transition = BookOpeningTransition() // 2 transition.isPush = true // 3 self.transition = transition // 4 return transition &#125;&#125; 1.创建一个 transition 2.设置 isPush 为 true 3&amp;4.保存当前 transition，返回 transition 接着打开 CustomNavigationController.swift 用下面代码替换 push 的 if 判断 12345if operation == .Push &#123; if let vc = fromVC as? BooksViewController &#123; return vc.animationControllerForPresentController(toVC) &#125;&#125; 这一步判断判断是否从 BooksViewController 中 push 过来的，然后用你创建的 BookOpeningTransition 来做转场展示你的 BookViewController。 运行，选中某本书你会看到，书本在开、合之间的动画非常顺畅。 WTF…这货看起来没有动画？！ 它直接从闭合状态跳转到打开状态，不要慌，这是因为你还没有加载页面 cell。导航控制器从 BooksViewController 过渡到 BookViewController，他们两个都是继承自 UICollectionViewController。UICollectionViewCell 没有在主线程中加载，所以没有动画过程。你需要给 collectionView 足够的时间让它来加载所有的 cell。打开 BooksViewController.swift 然后使用下面代码替换 openBook(_:)： 1234567891011func openBook(book: Book?) &#123; let vc = storyboard?.instantiateViewControllerWithIdentifier("BookViewController") as! BookViewController vc.book = selectedCell()?.book //1 vc.view.snapshotViewAfterScreenUpdates(true) //2 dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; Void in self.navigationController?.pushViewController(vc, animated: true) return &#125;)&#125; 下面说下是如何解决这个问题的： 1.当转场要发生时告诉 BookViewController 去截取当前视图 2.确定是在主线程中 push，来给 cell 足够的时间进行加载 运行程序，应该和下图类似： 看起来更完美了。至此 push 的转场已经完成，继续撸 pop 的转场。 实现 Pop 转场的工具方法pop 的过程和 push 过程刚好相反。第一阶段是书打开状态，第二阶段是书本闭合状态。 打开 BookOpeningTransition.swift 添加如下代码： 123456// MARK: Pop methodsfunc setStartPositionForPop(fromVC: BookViewController, toVC: BooksViewController) &#123; // Remove background from the pushed view controller toViewBackgroundColor = fromVC.collectionView?.backgroundColor fromVC.collectionView?.backgroundColor = nil&#125; 该方法存储了 BookViewController 的背景色然后移除了 BooksViewController 中 collectionView 的背景色。我们不需要设置任何的 transform，因为书本当前状态就是打开状态。接下来添加如下代码到上述代码之后： 1234567891011121314func setEndPositionForPop(fromVC: BookViewController, toVC: BooksViewController) &#123; //1 let coverCell = toVC.selectedCell() //2 for cell in toVC.collectionView!.visibleCells() as! [BookCoverCell] &#123; if cell != coverCell &#123; cell.alpha = 1 &#125; &#125; //3 for cell in fromVC.collectionView!.visibleCells() as! [BookPageCell] &#123; closePageCell(cell) &#125;&#125; 该方法设置 pop 转场的最终状态： 1.获取当前选中书本的封面 2.在书本闭合状态，遍历 BooksViewController 所有书本封面，然后渐显 3.遍历 BookViewController 中所有的 cell，然后将它们转换成闭合态 然后加入以下代码： 123456func cleanupPop(fromVC: BookViewController, toVC: BooksViewController) &#123; // Add background back to pushed view controller fromVC.collectionView?.backgroundColor = self.toViewBackgroundColor // Unhide the original book cover toVC.selectedCell()?.alpha = 1&#125; 该方法在 pop 转场结束后做了一些还原工作。主要是将 BooksViewController 的 collectionView 的背景色还原成之前的状态，以及展示之前的书本封面。把下面代码加到代理方法 animateTransition(_:) 中的 带有 //POP 注释的 else 大括号内。 123456789101112131415161718//1let fromVC = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey) as! BookViewControllerlet toVC = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey) as! BooksViewController //2container.insertSubview(toVC.view, belowSubview: fromVC.view) //3setStartPositionForPop(fromVC, toVC: toVC)UIView.animateWithDuration(self.transitionDuration(transitionContext), animations: &#123; //4 self.setEndPositionForPop(fromVC, toVC: toVC)&#125;, completion: &#123; finished in //5 self.cleanupPop(fromVC, toVC: toVC) //6 transitionContext.completeTransition(finished)&#125;) 下面解释下 pop 转场动画的工作原理： 1.获取转场过程中的控制器。fromVC 现在变成了 BookViewController，toVC 变成了 BooksViewController。 2.在 containerView 中把 BooksViewController 的视图放置到 BookViewController 视图下面。 3.setStartPositionForPop(_:toVC) 方法存储了背景色 4.用动画形式将书本有打开状态转换到闭合状态 5.动画完成则做还原设置，将背景色设置为之前保存的，然后显示书本封面 6.通知转场完成 在导航控制器中使用 pop 转场现在让我们像之前添加自定义 push 动画那样将 pop 动画也加入到代理方法中去。打开 BooksViewController.swift 然后在 animationControllerForPresentController(_:) 方法后添加如下代码： 123456func animationControllerForDismissController(vc: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123; var transition = BookOpeningTransition() transition.isPush = false self.transition = transition return transition&#125; 这个方法同样创建一个 BookOpeningTransition 实例，唯一不同的是其 transition 设置为 pop。打开 CustomNavigationController.swift 用下面代码替换之前的 if 逻辑： 12345if operation == .Pop &#123; if let vc = toVC as? BooksViewController &#123; return vc.animationControllerForDismissController(vc) &#125;&#125; 它返回一个 transition，然后执行 pop 动画来把书合上。运行程序，选中一本书，看下它的打开和闭合状态，应该和下图类似： 创建一个可交互的导航控制器打开和关闭转场动画看起来非常屌，但是你可以做得更好。你可以使用 pinch 手势来控制书的开、合。首先打开 BookOpeningTransition.swift 添加如下属性： 12// MARK: Interaction Controllervar interactionController: UIPercentDrivenInteractiveTransition? 接着打开 CustomNavigationController.swift 然后添加如下代码： 123456func navigationController(navigationController: UINavigationController, interactionControllerForAnimationController animationController: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning? &#123; if let animationController = animationController as? BookOpeningTransition &#123; return animationController.interactionController &#125; return nil&#125; 上述方法返回一个可交互的动画对象。它使得导航控制器控制着整个动画过程，这样用户就可以使用 pinch 手势来控制书本的开、合。打开 BooksViewController.swift 在transition 变量下添加如下属性： 12345678910//1var interactionController: UIPercentDrivenInteractiveTransition?//2var recognizer: UIGestureRecognizer? &#123; didSet &#123; if let recognizer = recognizer &#123; collectionView?.addGestureRecognizer(recognizer) &#125; &#125;&#125; 下面解释为什么要添加这几个变量： 1.interactionController 是一个 UIPercentDrivenInteractiveTransition 实例，它管理 VC 转场过程中自定义动画的出现和消失。这个可交互控制器同样依赖一个 transition animator。这个 animator 实现了 UIViewControllerAnimatorTransitioning 协议，你刚才创建的 BookOpeningTransition 就是干这件事的。iteractionController 可以控制 push 和 pop 的过程，如果想要了解更多细节可以参考苹果官方文档。 2.recognizer 是一个 UIGestureRecognizer 实例。你可以使用它来控制书本的开、合。 在 BooksViewController 扩展中的 animationControllerForPresentController(_:) 方法中添加如下代码，将其放在 transition.isPush = true 这一行之后： 1transition.interactionController = interactionController 这行代码让自定义导航控制器知道使用那一个交互控制器。同样把上面在添加到 animationControllerForDismissController(_:) 方法中 transition.isPush = false 之后。紧接着在 viewDidLoad() 中加入下面一行代码： 1recognizer = UIPinchGestureRecognizer(target: self, action: "handlePinch:") 它初始化了一个 UIPinchGestureRecognizer 实例，这个 pinch 手势的 action 是 handlePinch(_:)。 现在我们来实现 handlePinch(_:) 这个方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243// MARK: Gesture recognizer actionfunc handlePinch(recognizer: UIPinchGestureRecognizer) &#123; switch recognizer.state &#123; case .Began: //1 interactionController = UIPercentDrivenInteractiveTransition() //2 if recognizer.scale &gt;= 1 &#123; //3 if recognizer.view == collectionView &#123; //4 var book = self.selectedCell()?.book //5 self.openBook(book) &#125; //6 &#125; else &#123; //7 navigationController?.popViewControllerAnimated(true) &#125; case .Changed: //8 if transition!.isPush &#123; //9 var progress = min(max(abs((recognizer.scale - 1)) / 5, 0), 1) //10 interactionController?.updateInteractiveTransition(progress) //11 &#125; else &#123; //12 var progress = min(max(abs((1 - recognizer.scale)), 0), 1) //13 interactionController?.updateInteractiveTransition(progress) &#125; case .Ended: //14 interactionController?.finishInteractiveTransition() //15 interactionController = nil default: break &#125;&#125; 对于 UIPinchGestureRecognizer，我们关心三种不同的状态：began，changed，end。 begin状态 1.初始化一个 UIPercentDrivenInteractiveTransition 对象 2.判断 scale， 也就是 pinch 手势移动的距离，看起是否大于等于1 3.如果是，确保手势发生在 colletionView 当中 4.获取当前手势所作用的书脊 5.执行 push 转场动画，显示书籍页面 6.如果小于1 7.执行 pop 动画来展示书本封面 changed 状态 8.判断当前转场是否为 push 9.如果正 push 到 BookViewController，获取用户 pinch 手势的百分比。将 pinch 手势缩小为其原始值的 1/5，这样用户更加容易控制转场过程 10.根据之前计算的白封闭更新 transition 完成状态的百分比。 11.如果当前转场不是 push，那肯定是 pop 12.当使用 pinch 手势控制书本关闭时，缩放比一定是从1变到0 13.最后更新 transition 的进度 end 状态 14.通知系统用户转场交互已完成 15.将交互 controller 置为 nil 最后，你需要实现 pinch-to-closed 状态。因此你需要将手势传递给 BookViewController，这样他就能自发进行 pop。 1234567var recognizer: UIGestureRecognizer? &#123; didSet &#123; if let recognizer = recognizer &#123; collectionView?.addGestureRecognizer(recognizer) &#125; &#125;&#125; 当你在 BookViewController 中设置好手势时，它会马上被加到 collectionView 中区，这样我们就可以在用户合上书本的时候追踪 pinch 手势。下面需要在 BooksViewController 和 BookViewController 之间进行手势的传递。打开 BookOpeningTransition.swift 添加下面一行代码到 cleanUpPush(_:toVC) 方法中，并且将它放在设置背景色之后： 12// Pass the gesture recognizertoVC.recognizer = fromVC.recognizer 当从 BooksViewController push 到 BookViewController后，你需要将手势回传。加入下面代码到 cleanUpPop(_:toVC) 方法中，同样是放在设置背景色之后： 12// Pass the gesture recognizertoVC.recognizer = fromVC.recognizer 运行程序，选中任意一本书然后使用 pinch 手势来控制书本的开、合。 用 pinch 收拾来控制书本的开合显得非常自然，同样可以让界面更加简洁，我们不再需要导航栏上的返回按钮，是时候来清理它了。 如下图设置即可： 继续运行，可以看到导航栏不复存在画面变得更加简洁！:] 何去何从你可以在此下载完整代码。在这系列教程中，你学会了如何使用自定义布局、自定义转场、使用手势来控制转场交互。我希望你喜欢这篇教程并从中受益，我想在此感谢Attila Hegedüs创建了这个碉堡的项目。如有任何疑问，请在下面留言指出。]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>UICollectionView</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何创建一个翻书动画(Part 1)[译]]]></title>
    <url>%2F2015%2F08%2F31%2FHow-to-Create-an-iOS-Book-Open-Animation-part-one-translation%2F</url>
    <content type="text"><![CDATA[在这个分两部分的教程系列中，你将开发一个漂亮的 iOS 打开及翻书动画，类似于Paper by FiftyThree： 2019.11.21 update本文中图片和资源相关链接可能已失效，如需查阅，请查看原文 第一部分，你将学习如何自定义 UICollectionViewLayout，然后使用景深和阴影来让 app 看起来更加真实。 第二部分(译文)，你将学习创建自定义的转场动画，然后集成手势来创建自然、简洁的 view 之间的转场。 原文：How to Create an iOS Book Open Animation: Part 1 本教程主要针对于进阶中的开发者，讲解一些自定义转场以及自定义 collectionView Layout 相关的知识。如果你之前没有用过 collectionView，那么建议你先看看其他关于 collectionView 的教程。 感谢Attila Hegedüs创建了这个棒棒哒示例工程。 开始下载模板，解压，在 Xcode 中打开。使用模拟器运行程序，将得到如下画面： 这个应用已经初具其功能，你可以滑动书库然后选中你喜欢的书来翻阅。上一次你一页一页翻看书籍是什么时候？在现有对 collectionView 了解的基础上，你可以美化页面视图。 工程结构下面是快速对初始工程重要方面的一个简要描述：Data Model 文件夹包含三个文件： Books.plist：包含样书数据。每本书都含有一个图片封面以及一系列的书页图片 BookStore.swift：单例，主要工作就是从 Books.plist 中加载数据然后创建 Book 对象。 Book.swift：存储书本相关信息的类 Books 文件夹包含两个文件： BooksViewController.swift：UICollectionViewController的子类，主要负责展示书单 BookCoverCell.swift：展示所有书的封面，在BooksViewController使用。 Book 文件夹包含下面几个文件： BookViewController.swift：也是UICollectionViewController的子类，用来展示BooksViewController中选中的某一本书的内容页面 BookPageCell.swift：用来展示书的所有页面，在BookViewController中使用。 最后一个文件夹 Helper 中包含： UIImage+Helpers.swift：是 UIImage 的一个扩展。里面有两个工具方法，一个用来圆角化图片，另一个用来缩放图片到指定大小。 以上就是整个工程的目录结构。现在让我们开始撸代码吧！ 自定义 Book 布局首先你需要为BooksViewController的 collectionView复写默认的布局，默认布局显示3个大的书本封面，它们几乎占据整个屏幕。你需要缩小它们来让它看起来更舒服，像这样： 在你滑动的过程中，最接近屏幕中心的封面将会变大一些来表示它当前被选中。继续滑动，封面将会变小，这意味着你将它移到一边即远离屏幕中心。在 App\Books 下创建一个名为 Layout 的分组，然后右击 Layout 文件夹选择新建文件，然后创建一个继承自UICollectionViewFlowLayout的子类，取名为BooksLayout，语言为 Swift。接下来你需要告诉BooksViewController的 collectionView 使用你新建的 Layout。打开Main.storyboard，选中BooksViewController的Collection View然后在右侧的Attributes Inspector将 layout 设置为 Custom，Class 设置为 BooksLayout，如下图所示： 打开BooksLayout.swift，在BooksLayout类声明上面添加如下代码： 12private let PageWidth: CGFloat = 362private let PageHeight: CGFloat = 568 这两个常量将被用来设置 cell 的 size。接着添加下面初始化方法： 1234567required init(coder aDecoder: NSCoder) &#123; super.init(coder: aDecoder) scrollDirection = UICollectionViewScrollDirection.Horizontal //1 itemSize = CGSizeMake(PageWidth, PageHeight) //2 minimumInteritemSpacing = 10 //3&#125; 下面是关于1，2，3的解释： 1.设置滑动方向为水平 2.设置 cell 的页面宽度为362，高度为568 3.设置 cell 减最小间距为10 接下来，在init(coder:)后面添加如下代码： 123456789101112131415override func prepareLayout() &#123; super.prepareLayout() //The rate at which we scroll the collection view. //1 collectionView?.decelerationRate = UIScrollViewDecelerationRateFast //2 collectionView?.contentInset = UIEdgeInsets( top: 0, left: collectionView!.bounds.width / 2 - PageWidth / 2, bottom: 0, right: collectionView!.bounds.width / 2 - PageWidth / 2 )&#125; prepareLayout()让你有机会在获取布局信息前进行一系列运算。下面是对每个数字注释的解释： 1.设置用户手指移开后collectionView 的减速速率。通过设置其值为UIScrollViewDecelerationRateFast，colletionView 将会更快速的停止滑动。也可以尝试以下Normal来查看以下对比。 2.设置 contentInset，让第一本书的封面一直居中。 现在你需要位没一个 cell 处理布局信息。在prepareLayout()方法下面添加如下代码： 123456789101112131415161718override func layoutAttributesForElementsInRect(rect: CGRect) -&gt; [AnyObject]? &#123; //1 var array = super.layoutAttributesForElementsInRect(rect) as! [UICollectionViewLayoutAttributes] //2 for attributes in array &#123; //3 var frame = attributes.frame //4 var distance = abs(collectionView!.contentOffset.x + collectionView!.contentInset.left - frame.origin.x) //5 var scale = 0.7 * min(max(1 - distance / (collectionView!.bounds.width), 0.75), 1) //6 attributes.transform = CGAffineTransformMakeScale(scale, scale) &#125; return array&#125; layoutAttributesForElementsInRect(_:)返回一个包含了多个UICollectionViewLayoutAttributes对象的数组，这些对象为每个 cell 提供布局属性。下面是对代码的拆分： 1.调用父类的layoutAttributesForElementsInRect方法来获取每个 cell 默认的布局属性 2.遍历数组中的每个属性 3.获取当前 cell 布局属性的 frame 4.计算封面与屏幕中心的距离 5.根据4中的距离来改变封面的 scale，使其在0.75到1之间，最后在乘以一个系数0.7让它看起来更舒服 6.最后让封面使用设置后的 scale 紧接着在layoutAttributesForElementsInRect(_:)之后添加如下代码： 123override func shouldInvalidateLayoutForBoundsChange(newBounds: CGRect) -&gt; Bool &#123; return true&#125; 返回 true 表示在每一次 collectionView bounds 发生改变时强制让 layout 去重新计它的布局属性。collectionView 在滑动过程中 bounds 会发生改变，这使得重计算 cell 的布局属性变得很方便。 运行程序，将会发现中间的封面会比其他的大。 滑动来查看每个封面是如何放大和缩小的。但是如果书籍吸附在相应位置是不是更好呢？接下来我们就来实现这个。 书本吸附targetContentOffsetForProposedContentOffset(_:withScrollingVelocity:)决定collectionView停在什么位置，然后返回一个offset来设置 collectionView 的 contentOffset。如果不复写这个方法，则返回默认的 offset。在shouldInvalidateLayoutForBoundsChange(_:)后面添加如下代码： 123456789101112131415161718192021222324252627override func targetContentOffsetForProposedContentOffset(proposedContentOffset: CGPoint, withScrollingVelocity velocity: CGPoint) -&gt; CGPoint &#123; // Snap cells to centre //1 var newOffset = CGPoint() //2 var layout = collectionView!.collectionViewLayout as! UICollectionViewFlowLayout //3 var width = layout.itemSize.width + layout.minimumLineSpacing //4 var offset = proposedContentOffset.x + collectionView!.contentInset.left //5 if velocity.x &gt; 0 &#123; //ceil returns next biggest number offset = width * ceil(offset / width) &#125; else if velocity.x == 0 &#123; //6 //rounds the argument offset = width * round(offset / width) &#125; else if velocity.x &lt; 0 &#123; //7 //removes decimal part of argument offset = width * floor(offset / width) &#125; //8 newOffset.x = offset - collectionView!.contentInset.left newOffset.y = proposedContentOffset.y //y will always be the same... return newOffset&#125; 在用户手指离开屏幕时，该方法将会计算书本封面的 offset。 1.创建一个名为 newOffset 的 CGPoint 2.获取当前 collectionView 的 layout 3.获取 cell 的宽度 4.计算当前offset 5.如果 velocity.x &gt; 0,用户是在向右滑。把 offset/width 理解成书本的 index，滑至对应的 index 6.如果 velocity.x = 0,用户滑动距离不够，保持上衣吃选中的书不变 7.如果 velocity.x &lt; 0,用户向左滑 8.更新 x 的 offset，然后返回。保证书的封面居中显示 运行程序，滑动一下，你会发现滑动过程中书本，吸附效果更明显了。你需要建立一种机制来使得用户只能点击居中的书本，然而现在不管书本在哪，你都可以点击。打开BooksViewController.swift，将下面代码加到// MARK: Helpers注释下方： 12345678func selectedCell() -&gt; BookCoverCell? &#123; if let indexPath = collectionView?.indexPathForItemAtPoint(CGPointMake(collectionView!.contentOffset.x + collectionView!.bounds.width / 2, collectionView!.bounds.height / 2)) &#123; if let cell = collectionView?.cellForItemAtIndexPath(indexPath) as? BookCoverCell &#123; return cell &#125; &#125; return nil&#125; 该方法返回居中的 cell。接下来用下面代码来替换openBook(_:) 123456789func openBook() &#123; let vc = storyboard?.instantiateViewControllerWithIdentifier("BookViewController") as! BookViewController vc.book = selectedCell()?.book // UICollectionView loads it's cells on a background thread, so make sure it's loaded before passing it to the animation handler dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; Void in self.navigationController?.pushViewController(vc, animated: true) return &#125;)&#125; 该方法简单使用了上面写的selectedCell方法来获取当前选中的书本。然后用下面代码替换collectionView(_:didSelectItemAtIndexPath:)： 123override func collectionView(collectionView: UICollectionView, didSelectItemAtIndexPath indexPath: NSIndexPath) &#123; openBook()&#125; 这个方法使得你的点击打开的书本一直是居中的 cell 对应的书本，而不是之前 indexPath 对应的书本。 至此，我们已经完成了 BooksLayout。是时候展示真正的技术了–让屏幕上的书本看起来更自然真实，同时支持翻页。 翻页布局下图是我们要达成的最终效果： 使其看起来更像一本书！:] 在 Book 分组下新建 Layout 分组，右键新建一个继承自UICollectionViewFlowLayout名为BookLayout的子类，语言设置为 Swift。 和之前一样，bookCollectionView 需要设置其 Layout 为刚才新建的 Layout 类，如下图所示： 打开 BookLayout.swift，在 BookLayout 类声明上面加入如下代码： 123private let PageWidth: CGFloat = 362private let PageHeight: CGFloat = 568private var numberOfItems = 0 我们将使用这些常量来设置每个 cell 的大小，同样我们需要记录一本书的页数。接下来在类声明中添加如下代码： 123456override func prepareLayout() &#123; super.prepareLayout() collectionView?.decelerationRate = UIScrollViewDecelerationRateFast numberOfItems = collectionView!.numberOfItemsInSection(0) collectionView?.pagingEnabled = true&#125; 和你在BooksLayout中所做的类似，不同的是： 1.设置减速速率为UIScrollViewDecelerationRateFast来增加减速速率，进而使得 scrollView 快速停止 2.获取当前书本的页数 3.启用翻页；让每次滑动都是一个页面的距离 继续在BookLayout.swift添加如下代码： 123override func shouldInvalidateLayoutForBoundsChange(newBounds: CGRect) -&gt; Bool &#123; return true&#125; 和上面一样，在 bounds 发生改变时使布局失效，进而调用 prepareLayout 来计算新的布局。接下来复写collectionViewContentSize()来设置 collecyionView 的 contentSize： 123override func collectionViewContentSize() -&gt; CGSize &#123; return CGSizeMake((CGFloat(numberOfItems / 2)) * collectionView!.bounds.width, collectionView!.bounds.height)&#125; 该方法返回整个内容视图大小，高度不变，宽度随着 item 及书的页数发生改变。之所以要除以2，是因为每一页有两面，每一面上都有内容。和你在BooksLayout中做的一样，需要复写layoutAttributesForElementsInRect(_:)方法，在这个方法中可以添加为每一页添加翻页效果。在collectionViewContentSize()方法后面添加下面代码： 123456789101112131415161718override func layoutAttributesForElementsInRect(rect: CGRect) -&gt; [AnyObject]? &#123; //1 var array: [UICollectionViewLayoutAttributes] = [] //2 for i in 0 ... max(0, numberOfItems - 1) &#123; //3 var indexPath = NSIndexPath(forItem: i, inSection: 0) //4 var attributes = layoutAttributesForItemAtIndexPath(indexPath) if attributes != nil &#123; //5 array += [attributes] &#125; &#125; //6 return array&#125; 和 BooksLayout 不同的是，因为所有 cell 都在可见区域中，所以我们在 layoutAttributesForItemAtIndexPath(_:) 方法中来计算布局属性。下面是每一行的解释： 1.创建一个新的数组来持有所有 cell 的布局属性 2.遍历所有 item 3.为每个 item 创建一个 indexPath 4.获取 indexPath 对应的布局属性。你马上就要复写 layoutAttributesForItemAtIndexPath(_:) 方法 5.将布局属性添加到数组当中 6.返回所有 cell 的布局属性 页面的几何运算在你实现 layoutAttributesForItemAtIndexPath(_:) 之前，花点时间来考虑布局，想想它该如何工作，我们是否能写一些工具方法来使得所有事情简单化、模块化。:] 上图显示书页的翻动是以书脊作为旋转轴。上图中的比例从-1.0到1.0变化。为什么？想象一下将一本书放在桌子上，书脊表示0.0，当你从左至右翻页时，翻转比率从-1.0（最左端）变到1.0（最右端）。因此，你可以用如下比率来表示你的翻页过程： 0.5表示页面成90度状态，与桌面垂直 +/- 0.5表示与桌面成45度 +/- 1.0表示与桌面平行 因为旋转是逆时针的，角度符号与比率符号相反。（即正负符号相反）首先将下面工具方法添加在 layoutAttributesForElementsInRect(_:) 之后： 123456789101112//MARK: - Attribute Logic Helpers func getFrame(collectionView: UICollectionView) -&gt; CGRect &#123; var frame = CGRect() frame.origin.x = (collectionView.bounds.width / 2) - (PageWidth / 2) + collectionView.contentOffset.x frame.origin.y = (collectionViewContentSize().height - PageHeight) / 2 frame.size.width = PageWidth frame.size.height = PageHeight return frame&#125; 根据 collectionView 的中心为每一个页面计算其 frame。getFrame(_:) 方法会将每个页面边缘与书脊对其。改变的唯一变量是collectionView的内容在x方向偏移。接下来，添加如下方法： 1234567891011121314151617func getRatio(collectionView: UICollectionView, indexPath: NSIndexPath) -&gt; CGFloat &#123; //1 let page = CGFloat(indexPath.item - indexPath.item % 2) * 0.5 //2 var ratio: CGFloat = -0.5 + page - (collectionView.contentOffset.x / collectionView.bounds.width) //3 if ratio &gt; 0.5 &#123; ratio = 0.5 + 0.1 * (ratio - 0.5) &#125; else if ratio &lt; -0.5 &#123; ratio = -0.5 + 0.1 * (ratio + 0.5) &#125; return ratio&#125; 上面方法计算页面的比率。下面是对每个注释的解释： 1.计算页面在书本当中的编号，记住书页是双面的。乘以0.5可以得到你当前所在的页面。 2.根据你翻动的权重计算比率 3.需要将比率范围限制在-0.5到0.5之间。乘以0.1是用来给页面之间添加一个间距使得它们看起来是被遮盖一样。 在你计算好比率之后，就可以用它来计算当前翻动的角度了。在上面代码后添加如下代码： 12345678910111213141516171819func getAngle(indexPath: NSIndexPath, ratio: CGFloat) -&gt; CGFloat &#123; // Set rotation var angle: CGFloat = 0 //1 if indexPath.item % 2 == 0 &#123; // The book's spine is on the left of the page angle = (1-ratio) * CGFloat(-M_PI_2) &#125; else &#123; //2 // The book's spine is on the right of the page angle = (1 + ratio) * CGFloat(M_PI_2) &#125; //3 // Make sure the odd and even page don't have the exact same angle angle += CGFloat(indexPath.row % 2) / 1000 //4 return angle&#125; 这里进行了一些数学计算，但是拆开来看也不是很难： 1.判断当前页面是否为双书面，即序号是否为2的倍数，也就是说它处在书脊的右边。向左翻动是逆时针，在书脊右侧的页面的角度是负的。回想一下之前定义的在-0.5到0.5变化的比率。 2.如果当前面是奇数，那么它就在书脊的左侧，向右翻动是顺时针，所以书脊左侧的页面角度为正。 3.为每个页面添加一个偏移角度 4.返回旋转角 现在我们有了旋转角，我们需要转换每一个页面，添加如下代码： 12345func makePerspectiveTransform() -&gt; CATransform3D &#123; var transform = CATransform3DIdentity transform.m34 = 1.0 / -2000 return transform&#125; 修改 transform 中的m34来为每个页面增加透视。现在是时候加上旋转效果了。加入如下代码： 123456func getRotation(indexPath: NSIndexPath, ratio: CGFloat) -&gt; CATransform3D &#123; var transform = makePerspectiveTransform() var angle = getAngle(indexPath, ratio: ratio) transform = CATransform3DRotate(transform, angle, 0, 1, 0) return transform&#125; 该方法使用上面提到的两个工具方法来计算 transform 和 angle，然后创建了一个 CATransform3D并将其使用到页面的 y 轴上。现在所有工具方法已准备就是，是时候为每个 cell撸一下布局属性了。在 layoutAttributesForElementsInRect(_:) 后面加入下面代码： 123456789101112131415161718192021222324252627282930override func layoutAttributesForItemAtIndexPath(indexPath: NSIndexPath) -&gt; UICollectionViewLayoutAttributes! &#123; //1 var layoutAttributes = UICollectionViewLayoutAttributes(forCellWithIndexPath: indexPath) //2 var frame = getFrame(collectionView!) layoutAttributes.frame = frame //3 var ratio = getRatio(collectionView!, indexPath: indexPath) //4 if ratio &gt; 0 &amp;&amp; indexPath.item % 2 == 1 || ratio &lt; 0 &amp;&amp; indexPath.item % 2 == 0 &#123; // Make sure the cover is always visible if indexPath.row != 0 &#123; return nil &#125; &#125; //5 var rotation = getRotation(indexPath, ratio: min(max(ratio, -1), 1)) layoutAttributes.transform3D = rotation //6 if indexPath.row == 0 &#123; layoutAttributes.zIndex = Int.max &#125; return layoutAttributes&#125; 每个 cell 都会调用这个方法： 1.为给定的 indexPath 创建一个 UICollectionViewLayoutAttributes 2.使用 getFrame 方法给布局属性设置 frame，来保证它会与书脊对齐 3.用之前的 getRatio 方法来设置布局属性的比率 4.判断当前页的比率是否在限制范围内，如果不在就不展示这个 cell。为了优化，通常不显示背面，只展示正面。当然如果是书的封面则需要一直展示。 5.根据计算得到比率来获取 rotation 和 transform 6.判断 indexPath 是否为第一页，如果是第一页则设置其 zIndex 让它显示在所有页面之上，避免闪现情况发生。 运行程序，打开书本，翻动以下。。。what the f**k!! 页面的锚点貌似是 center 而不是边缘！ 如图所示，每个页面锚点坐标为（0.5,0.5）。你知道怎么解决这个问题吗？ 很明显，你需要改变锚点位置，使其位于边缘。如果页面在书脊的右侧，锚点应该为(0,0.5),反之锚点为(1,0.5)。 打开 BookPageCell.swift 添加如下代码： 123456789101112131415override func applyLayoutAttributes(layoutAttributes: UICollectionViewLayoutAttributes!) &#123; super.applyLayoutAttributes(layoutAttributes) //1 if layoutAttributes.indexPath.item % 2 == 0 &#123; //2 layer.anchorPoint = CGPointMake(0, 0.5) isRightPage = true &#125; else &#123; //3 //4 layer.anchorPoint = CGPointMake(1, 0.5) isRightPage = false &#125; //5 self.updateShadowLayer()&#125; 上面复写了 applyLayoutAttributes(_:) 方法，它使用了 BookLayout 中的布局属性。这看起来非常言简意赅。 1.判读当前页面是否为双数，也就是当前页面在书脊右侧。 2.将锚点设置成左边缘，然后设置isRightPage为 true。这个变量可以帮你确定圆角的位置。 3。如果当前页面为奇数，那么它就处于书脊左侧 4.设置奇数页面的锚点为其右测边缘，然后设置isRightPage为 false 5.最后更新当前页的阴影 layer 运行一下，翻动页面，看起来比之前好多了。 到此为止，该教程的第一部分已经结束。花点时间休息一下，想想这个过程是不是很屌？！ 何去何从你可以在此下载第一部分的完整代码。你从默认的 layout 开始，然后学习了如何自定义一个新的 layout 然后创建了一个比较屌的效果！用这个 app 的人会觉得他们像在翻实体书一样。正是这样一个细节使得一个普通的阅读类软件变得深受用户欢迎。然而，一切还没有结束。在第二部分中你可以让这个 app 变得更好更简洁。你是否也有很炫的布局想法？如果你有任何疑问、评论以及对这篇教程的其他想法，欢迎在下面讨论。]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>UICollectionView</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UICollectionView自定义布局之风火轮[译]]]></title>
    <url>%2F2015%2F08%2F31%2FA-Spinning-Wheel-Layout%2F</url>
    <content type="text"><![CDATA[现在有许多极具创造力的网站，几周前我碰巧浏览到一个名为Form Follows Function的网站，上面有各种交互动画。其中最吸引我的是网站上的导航转轮，转轮由各种交互体验海报组成。 原文：UICollectionView Custom Layout Tutorial: A Spinning Wheel 本教程将讲解如何使用自定义的 UICollectionViewFlowLayout 来再现那个导航风火轮。在开始之前，希望你有对 2D 转换、UICollectionView 及其自定义布局的基本知识。如果你对这些还不是很熟悉，推荐你先看看下面几篇教程。 UICollectionView Tutorial Part 1: Getting Started UICollectionView Tutorial Part 2: Reusable Views and Cell Selection Video Series: Collection Views Video Series: Custom Collection View Layouts 通过学习该教程，你将了解到： 从头开始创建自定义collectionView的布局，而不是使用UICollectionViewFlowLayout作为你的基类。 view 在其 bounds 之外绕某点旋转 那么现在，让我们开搞吧。 开始首先下载模板，在 Xcode 中打开，运行。你将看到一系列 cell，每个代表书城中的一本书。 下面我们来看看工程目录结构，有一个 CollectionViewController、一个自定义 Cell，cell 中有一个 imageView。然后 VC 被这些 Cell填充。我们的任务就是创建一个UICollectionViewLayout子类来将这些 Cell 按照圆弧排列。 理论知识下图是一个带有 cell 的风火轮。黄色区域是 iPhone 的屏幕，蓝色圆角矩形是 cell，红色虚线是你将要放置 cell 的圆弧。 你需要三个参数来创建这种排列： 1.圆弧半径（radius） 2.每个 cell 之间的角度（anglePerItem） 3.每个 cell 的角位置 你可能已经注意到，并非所有 cell 在屏幕当中能正常显示。 假设第0个 cell 的角度为 x 度，那么第1个 cell 的角位置为 x + anglePerItem,第二个为x + anglePerItem * 2，以此类推。第 n 个的角位置的计算公式如下： 1angle_for_i = x + (i * anglePerItem) 下图展示的是角坐标系。0度代表中心，顺时针方向为正，逆时针方向为负。所以0度角的 cell 将处在正中央，完全垂直的方向。 现在你对理论知识有了一个全面的理解，让我们开始撸代码吧。 Circular Collection View Layout新建一个 swift 文件，取名CircularCollectionViewLayout，继承自UICollectionViewLayout。 点击下一步、创建。这个UICollectionViewLayout的子类将包含所有与位置相关的代码。因为CircularCollectionViewLayout继承自UICollectionViewLayout而不是UICollectionViewFlowLayout，所以你需要处理所有布局过程而不是简单调用 super 中的实现。 我发现 FlowLayout 非常适合网格视图而非圆形布局。在CircularCollectionViewLayout中，新建两个属性itemSize和radius。 1234567let itemSize = CGSize(width: 133, height: 173) var radius: CGFloat = 500 &#123; didSet &#123; invalidateLayout() &#125;&#125; 当半径改变时你需要重新计算所有值，所以要在 didSet 中调用invalidateLayout()。在 radius 声明下面紧接着anglePerItem的定义： 123var anglePerItem: CGFloat &#123; return atan(itemSize.width / radius)&#125; anglePerItem可以是你想要的任何值，但是公式要确保 cell 不要被分散的太开。下一步，实现collectionViewContentSize()来声明你的 collectionView 的内容有多大： 1234override func collectionViewContentSize() -&gt; CGSize &#123; return CGSize(width: CGFloat(collectionView!.numberOfItemsInSection(0)) * itemSize.width, height: CGRectGetHeight(collectionView!.bounds))&#125; 内容高度与 collectionView 高度一致，但是宽度是itemSize.width * numberOfItems。现在打开Main.storyboard，选中视图大纲中的Collection View，如下图所示 打开Attributes Inspector，将其 Layout 设置为自定义，将其 Class 设置为CircularCollectionViewLayout。 运行程序，你将发现除了一个可滑动区域外，屏幕上没有任何东西。但是它就是你想要的，因为这确保你正确地将 collectionView 的 Layout 设置为你自定义的 Class 即 CircularCollectionViewLayout。 自定义布局属性除了新建一个新的布局子类，你还要新建一个继承自UICollectionViewLayoutAttributes的类来存储角位置以及锚点（anchorPoint）。把下面代码加到CircularCollectionViewLayout.swift这个文件中，将其放在CircularCollectionViewLayout类声明上面。 12345678910111213141516171819class CircularCollectionViewLayoutAttributes: UICollectionViewLayoutAttributes &#123; // 1 var anchorPoint = CGPoint(x: 0.5, y: 0.5) var angle: CGFloat = 0 &#123; // 2 didSet &#123; zIndex = Int(angle * 1000000) transform = CGAffineTransformMakeRotation(angle) &#125; &#125; // 3 override func copyWithZone(zone: NSZone) -&gt; AnyObject &#123; let copiedAttributes: CircularCollectionViewLayoutAttributes = super.copyWithZone(zone) as! CircularCollectionViewLayoutAttributes copiedAttributes.anchorPoint = self.anchorPoint copiedAttributes.angle = self.angle return copiedAttributes &#125;&#125; 1.我们需要一个锚点，因为旋转是围绕锚点而非中心。 2.当设置角度（angle）的时候，在内部设置其 transform 旋转 angle 弧度。同时我们想要右边的 cell 覆盖在左边的 cell 上，这个可以通过设置 zIndex 来实现。因为角度用弧度表示，我们将其扩大 1,000,000倍来确保相邻的值不会被四舍五入成同一个 zIndex 值，zIndex 是 Int 型的。 3.复写copyWithZone()来遵循NSCopying协议，因为在 collectionView 布局时，内部会拷贝布局属性。复写这个方法来确保复制过程中，anchorPoint 和 angle两个属性也会被拷贝。 下面我们回到CircularCollectionViewLayout中来实现 layoutAttributesClass()方法。 123override class func layoutAttributesClass() -&gt; AnyClass &#123; return CircularCollectionViewLayoutAttributes.self&#125; 这一步是为了告知 collecttionView 你将使用CircularCollectionViewLayoutAttributes而不是默认的UICollectionViewLayoutAttributes。为了持有布局属性，在所有属性声明之后创建一个名为attributesList的数组。 1var attributesList = [CircularCollectionViewLayoutAttributes]() Preparing the Layout当 collectionView 第一次展示在屏幕上时，Layout 的prepareLayout()方法将被调用。在每次布局生效时这个方法也会被调用。这是布局过程中最重要的方法之一，因为这是创建和存储布局属性的入口。在CircularCollectionViewLayout添加如下代码： 1234567891011121314151617override func prepareLayout() &#123; super.prepareLayout() let centerX = collectionView!.contentOffset.x + (CGRectGetWidth(collectionView!.bounds) / 2.0) attributesList = (0..&lt;collectionView!.numberOfItemsInSection(0)).map &#123; (i) -&gt; CircularCollectionViewLayoutAttributes in // 1 let attributes = CircularCollectionViewLayoutAttributes(forCellWithIndexPath: NSIndexPath(forItem: i, inSection: 0)) attributes.size = self.itemSize // 2 attributes.center = CGPoint(x: centerX, y: CGRectGetMidY(self.collectionView!.bounds)) // 3 attributes.angle = self.anglePerItem*CGFloat(i) return attributes &#125;&#125; 简单来说，我们便利每一个 item，然后执行闭包。下面我们一行行来解释： 1.为每个 IndexPath 创建一个CircularCollectionViewLayoutAttributes实例，然后设置其大小（size） 2.将 item 放在屏幕中间 按弧度来旋转每个 item，旋转量为anglePerItem * i 方法中的 map 是 Swift 标准库中的一部分，它创建了一个新的数组，数组中存储的是闭包的执行结果。你可以在这篇文章中了解更多。 我们还需要实现下面的方法，这些方法返回在给定矩形区域中的 item 布局属性，以及给定的 indexpath 的 item 布局属性。collectionView 在布局过程中将会多次调用这些方法，在用户滑动 collectionView 也会触发这些方法。为了保证其高效性，我们在prepareLayout()方法中缓存了这些布局属性。把下面代码加到prepareLayout()下面： 12345678override func layoutAttributesForElementsInRect(rect: CGRect) -&gt; [AnyObject]? &#123; return attributesList&#125; override func layoutAttributesForItemAtIndexPath(indexPath: NSIndexPath) -&gt; UICollectionViewLayoutAttributes! &#123; return attributesList[indexPath.row]&#125; 第一个方法简单返回了整个布局属性数组，第二个方法返回了指定的 indexpath 对应的布局属性。这个方法非常 OK 因为我们的 item 数目比较小，但是通常我们会遍历数组来判断布局属性的 frame 是否与给定的矩形区域相交，然后返回与给定区域相交的布局属性。这使得 collectionView 在屏幕上只绘制这些 item，或者将要出现在屏幕上的 item。 运行，你会看到所有 cell 出现在屏幕上，但是它们是围绕自身来旋转而非外部的某个点。虽然它不是非常急需的效果，但是如果能做到确实挺酷的，你觉得呢？ 你能猜到为什么会这样吗？ 有人说是锚点吗？你还记得上面我们说的 cell 的锚点吗？你还没有设置过它，上面的旋转效果远没达到我们希望得到的效果。 锚点是 CALayer 的一个属性，所有的旋转和缩放都是围绕着它而发生的。锚点的默认值是 center，就像上面的运行结果那样。真正的锚点的 x 值应该为0.5，y 值应该为radius + (itemSize.height / 2)，因为锚点是在归一化坐标系中定义的，所以你要除以itemSize.height。 回到prepareLayout()，然后再 centerX 的定义下面定义anchorPointY： 1let anchorPointY = ((itemSize.height / 2.0) + radius) / itemSize.height 在map(_:)闭包中的 return 上方添加如下代码： 1attributes.anchorPoint = CGPoint(x: 0.5, y: anchorPointY) 接着打开open CircularCollectionViewCell.swift，然后复写applyLayoutAttributes(_:) ： 123456override func applyLayoutAttributes(layoutAttributes: UICollectionViewLayoutAttributes!) &#123; super.applyLayoutAttributes(layoutAttributes) let circularlayoutAttributes = layoutAttributes as! CircularCollectionViewLayoutAttributes self.layer.anchorPoint = circularlayoutAttributes.anchorPoint self.center.y += (circularlayoutAttributes.anchorPoint.y - 0.5) * CGRectGetHeight(self.bounds)&#125; 这里你用父类实现来使用默认属性如 center 和 transform 但是因为锚点（anchorPoint）是一个自定义属性，我们需要手动使用它，同样我们也更新了 center.y 来补偿圆形布局中的anchorPoint.y变化。 运行程序，你会看到所有的 cell 按照圆形来布局了，但是滑动的过程中…等一下，发生了什么？它们被移出了屏幕而不是旋转！？ 这使得找到想要的书变得非常困难。 改善滑动效果最具挑战性的布局 item 任务已经完成了，可喜可贺！:] 现在需要做的就是改变角度值来实现滑动。 回到CircularCollectionViewLayout，然后在底部添加下面代码： 123override func shouldInvalidateLayoutForBoundsChange(newBounds: CGRect) -&gt; Bool &#123; return true&#125; 该方法返回 true 告知 collectionView 在滑动时布局失效，然后它会调用prepareLayout()，进而使用更新后的角位置重新计算 cell 的布局。angle被定义为第0个 item 的角位置。你将要通过把contentOffset.x转换成一个合适的角度值来实现滑动。 滑动过程中，contentOffset.x从 0 到collectionViewContentSize().width - CGRectGetWidth(collectionView!.bounds)变化。将contentOffset.x的极值定义为maxContentOffset，当其为 0 时，让第 0 个item 处在中心，当其为极值时（即maxContentOffset），让最后一个 item 处在屏幕中心，这就意味着最后一个 item 的角位置会变为 0 。 想象一下右边的场景，如果你是用angle_for_last_item = 0来解决下面等式你会得到： 123angle_for_last_item = angle_for_zero_item + (totalItems - 1) * anglePerItem0 = angle_for_zero_item + (totalItems - 1) * anglePerItemangle_for_zero_item = -(totalItems - 1) * anglePerItem 定义-(totalItems - 1) * anglePerItem为angleAtExtreme，如下所示： 12contentOffset.x = 0, angle = 0contentOffset.x = maxContentOffset, angle = angleAtExtreme 由上面，使用下面的公式非常容易计算任意contentOffset.x对应的角度： 1angle = -angleAtExtreme * contentOffset.x / maxContentOffset 脑海中回想以下这些算式，把下面代码添加到 itemSize 的声明下： 12345678var angleAtExtreme: CGFloat &#123; return collectionView!.numberOfItemsInSection(0) &gt; 0 ? -CGFloat(collectionView!.numberOfItemsInSection(0) - 1) * anglePerItem : 0&#125;var angle: CGFloat &#123; return angleAtExtreme * collectionView!.contentOffset.x / (collectionViewContentSize().width - CGRectGetWidth(collectionView!.bounds))&#125; 接下来使用 1attributes.angle = self.angle + (self.anglePerItem * CGFloat(i)) 来替换prepareLayout()中的 1attributes.angle = (self.anglePerItem * CGFloat(i)) 这一步添加为每个 item 添加了角度值，这样 item 的角度值不在是一个常量，而是一个与contentOffset.x有着函数关系的值。运行程序，在屏幕上滑动，你将发现所有 item 按照你想要的方式在滑动。干得漂亮！ 加分环节:优化你已经成功的重现了风火轮导航，现在可以在拍拍自己肩膀说一句干得漂亮，然后架着二郎腿享受这美好时光。但是在存在优化空间的情况（滑动丝滑般流畅）下你为什么要停下来呢？在prepareLayout()中为每个 item 创建了一个CircularCollectionViewLayoutAttributes实例，但是不是所有的 item 都会立刻展示在屏幕上。那些离屏的 item，你可以完全跳过对它们的计算，也不必创建CircularCollectionViewLayoutAttributes实例。但是有一个棘手的问题是：我们需要确定哪些 item 正在屏幕上显示，哪些是离屏的。如下图所示，在 (-θ, θ)范围之外的所有 item 都是离屏的。 举个栗子，为了计算三角形 ABC 中的 θ 角，可以使用下面公式： 1tanθ = (collectionView.width / 2) / (radius + (itemSize.height / 2) - (collectionView.height / 2)) 在prepareLayout()中的anchorPointY下一行加入如下代码： 1234567891011121314151617// 1 let theta = atan2(CGRectGetWidth(collectionView!.bounds) / 2.0, radius + (itemSize.height / 2.0) - (CGRectGetHeight(collectionView!.bounds) / 2.0))// 2var startIndex = 0var endIndex = collectionView!.numberOfItemsInSection(0) - 1 // 3if (angle &lt; -theta) &#123; startIndex = Int(floor((-theta - angle) / anglePerItem))&#125;// 4endIndex = min(endIndex, Int(ceil((theta - angle) / anglePerItem)))// 5if (endIndex &lt; startIndex) &#123; endIndex = 0 startIndex = 0&#125; 这一步我们做了什么？ 1.使用反正切函数计算theta角 2.初始化startIndex及endIndex 3.如果第0个 item 的角位置小于 -theta，那么它就是离屏的，屏上第 1 个 item 的 index 将为 -θ 与 angle 的差值再除以 anglePerItem 4.同样的，屏幕上最后一个 item 是θ 与 angle 的差值再除以 anglePerItem，min 是保证endIndex不会越界 5.最后做了一个容错处理，防止在快速滑动时所有 cell 都离屏时导致 endIndex小于 startIndex的情况 下图把上面的计算过程可视化： 既然我们知道了哪些正在显示，哪些是离屏的，我们需要更新用来计算布局属性的起始和结束的 index。使用 12attributesList = (startIndex...endIndex).map &#123; (i) -&gt; CircularCollectionViewLayoutAttributes in 来替换prepareLayout()中的： 12attributesList = (0..&lt;collectionView!.numberOfItemsInSection(0)).map &#123; (i) -&gt; CircularCollectionViewLayoutAttributes in 运行程序，你会发现视觉上没有明显变化，因为所有的改变仅仅影响离屏的 item。我们可以打开 Xcode 内置的视图层级查看器 因为创建了更少的变量，你应该可以看到性能的提升。 何去何从你可以在此下载完整代码。 恭喜，你已经成功使用了自定义的 Layout 来实现一个导航风火轮。在这篇教程中你应该学到不少东西，包括如何旋转 view、改变锚点、从头创建自定义的 Layout 以及如何优化让它变得更好。你可以更改radius和anglePerItem来进一步了解它们是如何来改变最终的圆形布局排列的。这篇教程主要是改变2D 的 transform，你也可以使用3D transform 来创建更有趣的效果。同样你也可以通过复写argetContentOffsetForProposedContentOffset(_:withScrollingVelocity:)方法来实现snapping行为。我相信你已经开始跃跃欲试了吧？如果你遇到问题，可以参考下面的代码： 1234567891011121314151617override func targetContentOffsetForProposedContentOffset(proposedContentOffset: CGPoint, withScrollingVelocity velocity: CGPoint) -&gt; CGPoint &#123; var finalContentOffset = proposedContentOffset let factor = -angleAtExtreme/(collectionViewContentSize().width - CGRectGetWidth(collectionView!.bounds)) let proposedAngle = proposedContentOffset.x*factor let ratio = proposedAngle/anglePerItem var multiplier: CGFloat if (velocity.x &gt; 0) &#123; multiplier = ceil(ratio) &#125; else if (velocity.x &lt; 0) &#123; multiplier = floor(ratio) &#125; else &#123; multiplier = round(ratio) &#125; finalContentOffset.x = multiplier*anglePerItem/factor return finalContentOffset&#125; 如果你有任何疑问、评论或者炫技，请加入下面的讨论。]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>UICollectionView</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Koloda动画第二版[译]]]></title>
    <url>%2F2015%2F08%2F23%2FKoloda-Second-Version%2F</url>
    <content type="text"><![CDATA[一个月前，我们发布了how we developed Tinder-like Koloda in Swift(如何创建一个类似 Tinder 的交互动画[译])。在开发者与设计师社区这个动画都受到强烈的欢迎，所以我们决定继续改善它。 原文：Koloda Tinder-Like Animation Version 2. 从我们发布第一个简单的 Koloda 动画后，我们的设计师Dmitry Goncharov坚持要实现他的下一个想法。同样，我们的 iOS 开发工程师，Koloda 动画创建者Eugene Andreyev承诺要让 frame 计算更加自定义化来让更多开发者在我们的 Koloda 动画上制作他们别具一格的组件。所以这是 Koloda 故事的第二章。这一次我们将同时讨论设计和开发。同时你也可以在Dribble以及GitHub上查看该动画。 我们如何用 Pixate 制作 Koloda 原型 by Dmitry Goncharov 我被 Tinder-like 这个概念所鼓舞，决定详细阐述把 Koloda 转变为不同寻常动画的最原始的想法。可喜的是，几个小时后我有了一个新的想法。我的想法是去除底部层级，从背景中来加载下一个卡片。我在 PS 中设计了一个实物模型，然后在Pixate中制作了原型。Pixate 是一个类似 InVisio、Marver、Origami 的设计工具。尽管在 Pixate 中设计原型比在 InVisio 中花了更多时间，但是Pixate做出的原型更加像一个原生应用。这个原型重造了我想要的卡片行为。 现在让我们来讲一下其中的过程。Pixate 工具栏中包含了layers、action kit、以及animations。在资源加载完成出现在 artboard 上后，你就可以在layer上开始工作了，然后继续创建交互。一开始我需要让卡片水平移动然后当他们跨越临界点时从屏幕当中飞出。在简单的动画帮助下，我实现了这个过程。同样我也让卡片改变它的透明度和在交互过程中进行旋转。 然后我要让一个新的卡片按照就像它从背景中加载一样出现，所以我需要对其进行拉伸和缩放。我设置了缩放比为3.5倍到1倍，3.5倍是卡片在背景中的大小。 为了有更好的效果，我加了一些弹性动画，然后它就大功告成了。至此，原型设计就完成了，接下来就是开发的事情了。下面我想总结一下我对 Pixate 的总体印象。优点： 在移动设备上预览 原型处理简单 不需要有特定的动画基础知识 原型看起来更像原生 App 工程共享更加方便（可导出到电脑，外链，二维码） 缺点： 一个原型没有囊括整个 App 的功能，只是展示独立的功能和交互 一个单独的 artboard 不能容纳原型的所有界面 不能将原型导出为代码 web 端应用有 bug 基础的 asset kit 非常有限 动画没有时间线 尽管有这么些缺点，但是 Pixate 是一个强大的工具，它能够设计师设计原生可点击的原型，创建导航模式以及屏幕间的交互。最重要的是，它能够让整个团队明白工程开发的整体方向。你可以观看Jared Lodwick的视频教程来了解更多。 现在你已经知道一些关于 Koloda 的原型设计过程，是时候来谈谈我们如何开发出第二版动画的。 我们如何开发 Koloda v.2 by Eugene Andreyev 第一版和第二版动画的最主要的区别就是卡片的布局。新版动画中最前的卡片被放置在屏幕中间，下面的卡片在背景中拉伸。底部卡片不会随顶部卡片移动而做出响应，而是在顶层卡片被滑出时出现在屏幕中，出现过程中有一个弹性特效。得益于 Dima 的原型，第二版更加容易开发。首先，Pixate 允许查看原型的所有交互，其次我可以通过 Pixate 来查看所有应用到的变化，以及它们的顺序。然后简单地讲它们写进代码中，不需要人为调整。最后，第二版 Koloda 是一个旅行 app 的一部分，不像第一版那样全是摇滚。 第一版： Koloda v.2的实现为了实现 Dima 设计的动画，我需要用不同的方式来放置卡片，所以我将上一篇文章(KolodaView实现那一段)中的frameForCardAtIndex暴露在头文件中。在 KolodaView 的子类中我复写了这个方法，然后按如下方式来放置卡片： 1234567891011121314151617181920212223242526272829303132333435override func frameForCardAtIndex(index: UInt) -&gt; CGRect &#123; if index == 0 &#123; let bottomOffset:CGFloat = defaultBottomOffset let topOffset:CGFloat = defaultTopOffset let xOffset:CGFloat = defaultHorizontalOffset let width = CGRectGetWidth(self.frame ) - 2 * defaultHorizontalOffset let height = width * defaultHeightRatio let yOffset:CGFloat = topOffset let frame = CGRect(x: xOffset, y: yOffset, width: width, height: height) return frame &#125; else if index == 1 &#123; let horizontalMargin = -self.bounds.width * backgroundCardHorizontalMarginMultiplier let width = self.bounds.width * backgroundCardScalePercent let height = width * defaultHeightRatio return CGRect(x: horizontalMargin, y: 0, width: width, height: height) &#125; return CGRectZero &#125; 发生了什么？我将 frontCard放置在KolodaView中间，然后拉伸背景卡片为其原始大小的1.5倍。 背景卡片的弹性动画因为背景卡片以弹性动画的方式出现，以及在移动过程中改变透明度，我写了一个新的代理方法： 1KolodaView - func kolodaBackgroundCardAnimation(koloda: KolodaView) -&gt; POPPropertyAnimation? 在这个方法中，POPAnimation 被创建用来传给 Koloda。然后当用户滑动卡片时， Koloda 用它来给 frame 的改变做动画。如果代理方法返回 nil，意味着 Koloda 使用默认的动画。 下面代码就是这个代理方法的实现 1234567891011func kolodaBackgroundCardAnimation(koloda: KolodaView) -&gt; POPPropertyAnimation? &#123; let animation = POPSpringAnimation(propertyNamed: kPOPViewFrame) animation.springBounciness = frameAnimationSpringBounciness animation.springSpeed = frameAnimationSpringSpeed return animation &#125; 怎样阻止背景卡片移动？同样我也添加了一个新的代理方法在新版的 Koloda 中 1func kolodaShouldMoveBackgroundCard(koloda: KolodaView) -&gt; Bool 如果返回 false就意味着交互动画被禁用，背景卡片不会随着顶层卡片移动而移动。 下面就是返回 false 时的动画效果： 这是返回 true 的动画效果 希望你能喜欢第二版的 Koloda，尽情使用它吧！ Dribbble GitHub]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何创建一个类似 Tinder 的交互动画[译]]]></title>
    <url>%2F2015%2F08%2F21%2FHow-We-Built-Tinder-Like-Koloda-Animation-in-Swift-Chinese-Translation%2F</url>
    <content type="text"><![CDATA[有时候我认为 Tinder 不仅仅让人们遇见彼此，更多的是它引领了一种交互设计趋势。所以我们非常肯定地说 Tinder 已经完成了他的历史使命，可以安心等待着下一个 Tinder 出现。原文:How We Built Tinder-Like Koloda Animation in Swift Tinder 的右滑喜欢，左滑忽略不仅仅在约会（pao）应用中很流行，在购物 App 中也很流行，比如Fancy，也是像 Tinder 一样是滑动喜欢的形式。他们之所以才用这种交互形式是因为这种卡片式的交互确实深得用户欢心。卡片上的内容吸引了用户的注意力促使他们去进行一系列操作，进而提高了用户参与度。还有许多不同种类 App 也是用这种像 Tinder 一样的卡片式滑动交互的例子，比如Uptop，就连谷歌浏览器 iOS 客户端也是用这种卡片形式来管理书签。 我们把卡片式布局以及基于滑动的交互作为今年的交互设计趋势，我们的这篇文章有相关介绍。之后我们的设计师Dmitry Goncharov创建了一个类似 Tinder 交互的动画，实际上他是故意这么做的。我们把我们的这种类似 Tinder 基于卡片式的动画命名为Koloda，在乌克兰语中它的意思是甲板（卡片），听起来非常有趣。这个组件能够被不同 app 使用，如果加上约会（pao）地点的话，甚至在 Tinder 中也很实用。Dmitriy提出了这个概念，我们的iOS工程师实现了这个想法。详见GitHub。（译者注：Objective-C 版详见这里）。 我们如何实现 Koloda 动画 by Eugene Andreyev Tinder的滑动喜欢界面被许多不同的 App 借鉴，也有一些现成的库来给开发者使用。首先，我看了MDCSwipeToChoose以及TinderSimpleSwipeCards，事实证明，它们并不能完美的实现我的需求。我想要的动画要非常简单而且方便，就像UITableView 那样由数据源来驱动。因此，我创建了一个自定义组件来构建这个动画。主要分为如下三个部分： DraggableCardView：用来展示内容的卡片式图 OverlayView：遮罩视图，根据用户手势方向（左、右）来动态改变 KolodaView：用来控制加载和卡片之间的交互的视图 DraggableCardView的实现正如我前面提到的那样，DraggableCardView是用来展示内容的卡片视图。网上有很多教程阐述了 Tinder 滑动动画的原理，我选择了其中一种解决方案，做了一些改动，然后利用UIPanGestureRecognizer 和 CGAffineTransform实现了 DraggableCardView。部分代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//译者注：原文是用 swift 写的，我索性翻译成了 OC，下同- (void)panGestureRecognized:(UIPanGestureRecognizer *)pan&#123; self.xDistanceFromCenter = [pan translationInView:self].x; self.yDistanceFromCenter = [pan translationInView:self].y; CGPoint location = [pan locationInView:self]; switch (pan.state) &#123; case UIGestureRecognizerStateBegan: &#123; self.originalLocation = self.center; self.dragBegin = YES; self.animationDirection = location.y &gt;= self.frame.size.height / 2 ? -1.0 : 1.0; self.layer.shouldRasterize = YES; &#125; break; case UIGestureRecognizerStateChanged: &#123; CGFloat rotationStrength = MIN(self.xDistanceFromCenter / self.frame.size.width, kRotationMax); CGFloat rotationAngle = self.animationDirection * kDefaultRotationAngle * rotationStrength; CGFloat scaleStrength = 1 - ((1 - kScaleMin) * fabs(rotationStrength)); CGFloat scale = MAX(scaleStrength, kScaleMin); self.layer.rasterizationScale = scale * [UIScreen mainScreen].scale; CGAffineTransform transform = CGAffineTransformMakeRotation(rotationAngle); CGAffineTransform scaleTransform = CGAffineTransformScale(transform, scale, scale); self.transform = scaleTransform; self.center = CGPointMake(self.originalLocation.x + self.xDistanceFromCenter, self.originalLocation.y + self.yDistanceFromCenter); [self updateOverlayWithFinishPercent:self.xDistanceFromCenter / self.frame.size.width]; if ([self.delegate respondsToSelector:@selector(cardView:draggedWithFinishPercent:)]) &#123; [self.delegate cardView:self draggedWithFinishPercent:MIN(fabs(self.xDistanceFromCenter * 100 / self.frame.size.width), 100)]; &#125; &#125; break; case UIGestureRecognizerStateEnded: &#123; [self swipeMadeAction]; self.layer.shouldRasterize = NO; &#125; break; default: break; &#125;&#125; 当用户拖拽最前面的卡片视图时,它就离事件触发边缘越来越近，当达到触发边缘时，它就从屏幕中消失了。到触发边缘的距离用百分比来表示。在顶部卡片视图被拖拽的过程中，底部的卡片也会有相应的动作，要么是放大要么是缩小。换而言之，顶层和底层的动画是同步的。同样遮罩也会在移动的时候实时更新，在实时更新动画过程中，它的透明度从5%（几乎不可见）到100%（清晰可见）。 为了防止卡片边缘变得锯齿化，我使用了layer的shouldRasterize属性。同时我也要考虑到当卡片没有被拖拽到触发点时如何重置它的状态。我使用了 Facebook 的 Pop框架来设置其重置状态以及恢复上一步(undo)的动画。如果你有印象的话，所有Paper应用中的动画和过渡转换动画都是使用这个框架来完成的。它支持动态弹性动画，也允许创建任何物理现实中的交互动画，可喜的是它仅仅只需要很少的几行代码就可以实现。 OverlayView的实现OverlayView是在顶部卡片 View 进行动画时被添加上去的，它只有一个名为overlayState的属性，这个属性有两个可选值：当用户拖动卡片到左边，overlayState就添加一个红色的遮罩到卡片视图上，反之用户拖拽到右边，这个属性被设置为另一个可选值，使得卡片的遮罩变成绿色。（译者注：我在把代码翻译成 OC 时对变量名做了些许改动，overlayState改成了type，具体参见 GitHub，下同）。为了实现遮罩的自定义行为，我们可以继承OverlayView，然后重载overlayState的didSet方法。大致代码如下： 1234567891011121314151617181920212223242526272829303132333435//.h#import &lt;UIKit/UIKit.h&gt;#import "OverlayView.h"@interface CustomOverlayView : OverlayView@end//.m#import "CustomOverlayView.h"@interface CustomOverlayView ()@property (weak, nonatomic) IBOutlet UIImageView *imageView;@end@implementation CustomOverlayView- (void)setType:(OverlayType)type&#123; switch (type) &#123; case OverlayTypeLeft: self.imageView.image = [UIImage imageNamed:@"noOverlayImage"]; break; case OverlayTypeRight: self.imageView.image = [UIImage imageNamed:@"yesOverlayImage"]; break; case OverlayTypeNone: default: self.imageView.image = nil; break; &#125;&#125;@end KolodaView的实现KolodaView类负责卡片的加载以及管理工作。你可以通过代码或者Interface Builder来实现。然后你就可以为其指定dataSource以及delegate(可选)。最后你应该实现dataSource中的如下方法： 1234567891011@protocol SwipeViewDataSource &lt;NSObject&gt;@required- (NSUInteger)swipeViewNumberOfCards:(SwipeView *)swipeView;- (UIView *)swipeView:(SwipeView *)swipeView cardAtIndex:(NSUInteger)index;- (OverlayView *)swipeView:(SwipeView *)swipeView cardOverlayAtIndex:(NSUInteger)index;@end 我们使用了代理方法而不是回调(block)的方式来获取相关数据。 几何解释还记得我们关于开发安卓Guillotine菜单动画的故事吗？在那个故事中我们的安卓工程师Dmytro Denysenko采用高中数学知识来计算一个自定义的差值。几何知识在我的 iOS 开发生涯中也发挥了很大的作用！ 动画过程中最有趣的一件事就是当用户在拖拽顶部卡片时，下面的卡片也会跟着移动。我想让Koloda动画更加灵活，所以我简单地指定了想要在屏幕上展示的卡片数，然后我就拿出纸就开始计算。 KolodaView需要展示位于顶层卡片之下的卡片正确的数量，然后让它们在动画开始的时候占据正确的位置。为了实现它，我需要计算所有卡片的frame，这个是通过给其中每个元素添加对应的序号来实现的。举个例子，第一个卡片视图的序号是[i]，那么第二个就是[i+1],第三个就是[i+2],以此类推。如下图所示，你可以清晰的看到第一张卡片的frame和size的计算过程。 代码如下： 123456789101112131415- (CGRect)frameForCardAtIndex:(NSUInteger)index&#123; CGFloat bottomOffset = 0; CGFloat topOffset = kBackgroundCardsTopMargin * (self.visibleCardsCount - 1); CGFloat xOffset = kBackgroundCardsLeftMargin * index; CGFloat scalePercent = kBackgroundCardsScalePercent; CGFloat width = CGRectGetWidth(self.frame) * pow(scalePercent, index); CGFloat height = (CGRectGetHeight(self.frame) - bottomOffset - topOffset) * pow(scalePercent, index); CGFloat multiplier = index &gt; 0 ? 1.0 : 0.0; CGRect previousCardFrame = index &gt; 0 ? [self frameForCardAtIndex:MAX(index - 1, 0)] : CGRectZero; CGFloat yOffset = (CGRectGetHeight(previousCardFrame) - height + previousCardFrame.origin.y + kBackgroundCardsTopMargin) * multiplier; CGRect frame = CGRectMake(xOffset, yOffset, width, height); return frame;&#125; 现在我们知道了序号、卡片frame以及动画结束的百分比，我们就可以很轻松的计算出当上一个卡片被滑出屏幕时下一个卡片应该出现的位置。之后，我们也可以实现一个百分比驱动动画（PercentDrivenAnimation）。最后我给这个简单易用的组件取了个有趣的名字–Koloda。任何开发者都可以自定义它，通过设置其内容视图以及遮罩视图。过些时候，我想实现自定义动画以及frame的计算方式，这样开发者们就可以使用他们自己别具一格的组件。KolodaView 的代码详见GitHub。 译者注：ObjC 版本可以参见Koloda-ObjC]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AVFoundation和 GPUImage初探]]></title>
    <url>%2F2014%2F08%2F24%2FAVFoundation-And-GPUImage%2F</url>
    <content type="text"><![CDATA[最近在做视频相关的东西，然后熟悉了一下AVFoundation框架，以及强大的开源库GPUImage。在这里记录这个过程中遇到的一些问题，以及解决的方法。 AVFoundation的一些基本概念根据苹果的官方文档，AVFoundation是用来播放和创建实时的视听媒体数据的框架，同时提供Objective-C接口来操作这些视听数据，比如编辑，旋转，重编码。本文着重讲的是视频的录制和编辑和GPUImage的一些简单使用，其他的都是一笔带过。来看下苹果文档的一个框架图。 相关类 AVAsset AVAssetTrack AVComposition AVVideoComposition AVAudioMix AVMutableAudioMixInputParameter AVMutableVideoCompositionInstrution AVMutableVideoCompositionLayerInstrution 简单的播放可以使用MPMoviePlayerController或者MPMovieViewController就行,简单的录制可以直接使用UIImagePickerController。同样简单的声音播放直接使用AVAudioPlayer，简单的录制直接使用AVAduioRecorder。如果你想要有更多的操作，可使用各种复杂的方式来控制播放，比如在同一时刻为同一个asset的不同片段使用不同的分辨率渲染，playitem来管理asset的呈现状态和方式,playitemtrack管理asset中的轨道（track）状态。 在AVFoudation框架中最核心的类就是AVAsset，他是由一系列的媒体数据组成的，包括但不限于:时间、大小(size)、标题、字幕等。其中每一个单独的媒体数据称为轨道(track)。同样剪辑操作中，AVMutableComposition是一个核心类。 这里又一个重要的东西就是CMTime,它是一个结构体，定义如下: typedef struct{ CMTimeValue value; CMTimeScale timescale; CMTimeFlags flags; CMTimeEpoch epoch;} CMTime;通常时间是等于value/timescale的，所以两个有相同时间的CMTime它们的timescale并不一定相同。关于更多CMTime的内容可以看这里。 进阶视频的录制这里用的是系统原生录制,关于录制通常用到的几个类就是AVCaptureDevice、AVCaptureSession、AVCaptureDeviceInput、AVCaptureOutput,同样，来看一张图。 一般来说，如果你想修改视频的相关信息，如拍摄地点等，可以拿到output的metadata来修改。大致代码如下: 1234567NSMutableArray *array = [output.metadta mutableCopy];AVMutableMetadataItem *item = [[AVMutableMetadataItem alloc] init];item.keyspace = ...;item.key = ...;item.value = ...;[array addObject:item];output.metadata = array; 如果录制时候想要得到指定的视频size必须先指定分辨率，像这样 1234567if ([session canSetSessionPreset:AVCaptureSessionPreset640x480])&#123; session.sessionPreset = AVCaptureSessionPreset640x480;&#125;else &#123; //设置失败&#125; 切换摄像头或其他输入源必须在beginConfiguration和commitConfiguration之间来处理，大致是这样 123456[session beginConfiguration];//移除某个输入源//再添加某个输入源//再为新添加的输入源进行必要的相关设置//...其他操作[session commitConfiguration]; 如果想对实时视频帧进行相关的渲染操作,通过 setSampleBufferDelegate:queue:方法来为output设置代理，同时必须指定queue，代理方法将会在这些queue上面被调用。可以在自己的类里面实现AVCaptureVideoDataOutput的协议方法,通过实现captureOutput:didOutputSampleBuffer:fromConnection:来拿到视频的每一帧，默认情况下这些视频帧会被用最有效的格式来输出到output,当然也可以在拍摄之前就为output进行相关设置。 123AVCaptureVideoDataOutput *videoDataOutput = [AVCaptureVideoDataOutput new];NSDictionary *newSettings =@&#123; (NSString *)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA) &#125;;videoDataOutput.videoSettings = newSettings; 说了这么多，感觉很虚，还是直接上代码，将以上部分衔接起来 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//自定义方法，小演示只添加了视频，没有添加声音，添加声音类似- (void)yourCustomMethodName&#123; AVCaptureSession *session = [[AVCaptureSession alloc] init]; if ([session canSetSessionPreset:AVCaptureSessionPreset640x480])&#123; session.sessionPreset = AVCaptureSessionPreset640x480; &#125; else &#123; //设置失败 &#125; AVCaptureDevice *device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo]; NSError *error = nil; AVCaptureDeviceInput *input = [AVCaptureDeviceInput deviceInputWithDevice:device error:&amp;error]; if (!input) &#123; // Handle the error appropriately. &#125; if(session canAddInput:input)&#123; [session addInput:input]; &#125; AVCaptureVideoDataOutput *output = [[AVCaptureVideoDataOutput alloc] init]; if(session canAddOutput:output)&#123; [session addOutput:output]; &#125; output.videoSettings =@&#123; (NSString *)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA) &#125;; //设置帧率(FPS),每秒15帧 output.minFrameDuration = CMTimeMake(1, 15); dispatch_queue_t queue = dispatch_queue_create("CustomQueue", NULL); [output setSampleBufferDelegate:self queue:queue]; dispatch_release(queue) NSString *mediaType = AVMediaTypeVideo; //用来显示录制的实时画面 AVCaptureVideoPreviewLayer *captureVideoPreviewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:session]; [self.view.layer addSublayer:captureVideoPreviewLayer]; //用户是否允许启用摄像头 [AVCaptureDevice requestAccessForMediaType:mediaType completionHandler:^(BOOL granted) &#123; if (granted) &#123; //Granted access to mediaType [self setDeviceAuthorized:YES]; [session startRunning]; &#125; else &#123; //Not granted access to mediaType dispatch_async(dispatch_get_main_queue(), ^&#123; [[[UIAlertView alloc] initWithTitle:@"AVCam!" message:@"AVCam doesn't have permission to use Camera, please change privacy settings" delegate:self cancelButtonTitle:@"OK" otherButtonTitles:nil] show]; [self setDeviceAuthorized:NO]; &#125;); &#125; &#125;];&#125;//协议方法,获取每一帧，将每一帧转换成图片，你也可以进行其他的渲染操作- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection &#123; UIImage *image = imageFromSampleBuffer(sampleBuffer);&#125; 上面演示了如何取得每一帧实时画面,如果想要直接存成视频可使用AVCaptureMovieFileOutput,如下 123456AVCaptureMovieFileOutput *movieFileOutput = [[AVCaptureMovieFileOutput alloc] init];NSURL *fileURL = ...; //存放位置//指定代理[aMovieFileOutput startRecordingToOutputFileURL:fileURL recordingDelegate:delete];//也可以为其指定outputSettings同样代理必须实现协议方法captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error:, 当然还有其他各种具体的设置，如对焦、曝光、闪光灯以及白平衡等等均可以通过KVO来设置，每次设置前都加一个判断，是否支持指定模式,在这里不做详细叙述了,这里你可以看到更多。 视频的剪辑视频的剪辑包括但不限于:裁剪、旋转(改变transform)、添加水印、添加字幕、合并等。关于剪辑，无非就是取出视频中的轨道(视频和音频),然后对轨道进行一系列的操作变可以得到各种想要的效果。首先我们先来看下面一张图 AVMutableComposition是整个视频剪辑过程中的一个核心，下面着重讲解这个类。AVMutableComposition和AVAsset一样含有多个视/音频轨道，但是更重要的是，它可以将多个AVAssetTrack合并到一起，比如在视频合并时，可以直接将多段视频拼接到一个轨道(AVMutableCompositonTrcak)，音频也一样。通过借助AVMutableVideoComposition和AVMutableAudioMix来设置每一段的视/音频的属性，从而达到想要的视听效果，比如视频切换处的淡入淡出，声音的渐变，字幕等等。关于上图的解释:首先通过将asset里面的轨道加载到composition的各轨道，然后通过audioMix和videoComposition对某个轨道进行对应操作,设置其相关属性。其中要用到的具体方法可以参见这里。 其中图中1，2，3用到的方法为 123456[1][mutableComposition addMutableTrackWithMediaType:AVMediaTypeVideo preferredTrackID:kCMPersistentTrackID_Invalid][2][AVMutableAudioMixInputParameters audioMixInputParametersWithTrack:mutableCompositionAudioTrack];`[3][AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:mutableCompositionVideoTrack] 关于视频的剪辑的代码可以参见苹果给出的官方Demo以及Raywendrich上的两篇文章1,2。 GPUImage什么?!你没听说过GPUImage?!那你赶紧去看看它的相关介绍。GPUImage是一个基于OpenGL ES的一个强大的图像/视频处理库,封装好了各种滤镜同时也可以编写自定义的滤镜。至于他到底是如何强大,用了就知道。在这篇文章不是为了介绍它，而是列出一些我在使用过程中遇到的问题和解决方法。 分段录制在使用GPUImageVideoCamera来录制的时候,可能需要分段录制,在GPUImage给出的视频录制Demo中直接只是录制一次，然而有时候需求可能是要录制多次，如果此时按照Demo的方法每次录制都要创建一个movieWriter,这样子的话每次都会在重新创建movieWriter并将它设置为videoCamera的audioEncodingTarget时候，界面都会卡顿一下，这是什么原因呢？因为videoCamera默认是不录制声音的，而每次创建movieWriter的时候都用到了movieWriter.hasAudioTrack = YES;,吊用这个之后videoCamera会自动去添加声音输入源,准备一些数据，所以这个过程会导致界面卡顿一下？这该怎么办呢？如果你有进到videoCamera的头文件去看的话你会发现这么一个方法和它的注释 1234567//Add audio capture to the session. Adding inputs and outputs freezes //the capture session momentarily, so you can use this method to add //the audio inputs and outputs early, if you’re going to set the //audioEncodingTarget later. Returns YES is the audio inputs and //outputs were added, or NO if they had already been added.-(BOOL)addAudioInputsAndOutputs; 注释的大意是:录制的时候添加声音,添加输入源和输出源会暂时会使录制暂时卡住,所以在要使用声音的情况下要先调用该方法来防止录制被卡住。这不刚好就解决了上面的这个问题吗？所以问题就迎刃而解了,因为没看到这个,走了不少弯路,浪费了好长时间。 关于分段录制,可能有这么一个需求就是所有片段都是存于一个文件中而不是录制完成后将各段合并到一个视频文件中。这两个东西或许会帮到你分段录制的实现,GPUImageExtend。前者是基于系统的分段录制的实现,后者是GPUImageMoiveWriter的一个子类。 所见即所得在录制的时候,使用GPUImageView来显示,因为给GPUImageView设置的大小是320*320的,如果不设置它的填充模式(fillMode)它是默认使用kGPUImageFillModePreserveAspectRatio即保持长宽比,其余空白处使用背景色填充,如果要设置成方形就得使用kGPUImageFillModePreserveAspectRatioAndFill,但是这个时候问题又来了假设你是用的录制分辨率是960x540,显示的画面则只会显示中间的540x540的画面,这个时候如果movieWriter的size设置为540x540,则最后保存的视频是失真的因为960被压到了540，整个画面变扁了。这个时候有两种解决方案 1.使用GPUImageCropFilter,通过设置其cropRegion来裁出中间540x540部分。关于cropRegion要注意它是一个CGRect,它对坐标系做了一个归一化处理,所以让所有的取值都在0.0~1.0范围内,比如960x540裁剪至中间540x540部分则cropRegion为(0,((960-540)/2)/960,1,540/960) 2.改变videoComposition的perferTransfom使其只显示中间的540x540。这样就完成了所见即所得。 关于GPUImage的实时滤镜添加或给已存在的视频添加滤镜,Demo都给出了详细过程,依葫芦画瓢即可。有一点要注意的是,在一些操作完成的时候注意removeTarget,还有就是在使用movieFile来播放已存在视频并添加滤镜的时候是没有声音的,这是这个库的一个缺陷,Github上有人提了这个issue和一些解决办法。同时在用movieFile处理视频的时候在切换滤镜的时候最好先cancelProcessing不然会有黑屏或卡顿现象出现。同样如果你是用老版本的GPUImage的时候,可能会遇到第一帧是红色的现象,有人提出这个issue后,作者修复了这个bug,切换到最新版的时候就不会有这种情况发生。发生这种情况的原因是视频掉帧,导致音频和视频不同步。 总结AVFoundation还是有很多东西去做深层次的挖掘,GPUImage也是一样,有了这个强大的库,解决一些事情节省了大量时间。这次仅仅是一个小小的尝试,对于很多东西都是浅尝则止,文中难免会有错误,欢迎在评论中指正。如果你在使用GPUImage和AVFoundation有什么好的心得或者对一些问题有相应的解决方案,不妨在评论中分享一下。]]></content>
      <categories>
        <category>框架学习</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>AVFoundation</tag>
        <tag>GPUImage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高效利用你的Xcode[译]]]></title>
    <url>%2F2014%2F07%2F23%2FUsing-Xcode-Efficiently%2F</url>
    <content type="text"><![CDATA[好莱坞电影里经常看到黑客们手指在键盘上飞速跳跃,同时终端上的代码也随着飞舞。如果你也想像电影里那样,那么你来对地方了。这篇教程将会教你在Xcode编程中更像程序员,你可以称之为魔法、疯狂的技术、好运当头或者黑客。毫无疑问,在学习完本教程之后,不管你怎么认为,都会感觉很酷,同时能更高效地运用Xcode,甚至可以通过这些新发现使你的代码免于毁灭。 原文地址 开始要看起来很酷,所以有一些必不可少的因素.下面列出来的是其中一部分 快速执行任务 精准 简洁美观的代码 要表现地更酷,你可以试着不用鼠标或者触摸板来完成教程中的每一个任务.学习之旅将从学习一些实用的Xcode功能开始,然后通过修复一些在CardTilt中的一些bug来训练。最后你将整理一下你的代码,使整个界面看起来更整洁。在学习该教程时,要记住:它不是教你做一个app,而是教你比以前更有效地利用Xcode来开发app。这篇教程建立在你对Xcode有一个基本的了解的基础上,然后着重于提高你的工作效率。每个人都有自己的编程习惯,本教程并非强制你形成某种风格。自始至终,本教程中你会看到某些命令的替代品,随着本教程的学习,请集中精力在提炼和形成你自己的编程风格,不要让微小的错误影响你。 如果你对于Xcode不是很熟悉,建议先学习下面两篇教程。(教程1和教程2) 下载 CardTilt-starter,然后就可以愉快地写代码了。 日常Xcode任务有一些在Xcode中你经常使用的技巧,这一部分让你更近距离的接触这些技巧,然后讲解一些潇洒应对它们的一些妙招。在这个过程中,你会在这些妙招的基础上发现使用它们的新方法。这些技巧将成为你编程工具腰带上的忍者之星。在Xcode中打开之前下载好的工程CardTilt,先不要急着去看代码,先将你Xcode的窗口和下图来一一对应。 是不是发现你的窗口和图中并不对应,先别着急。在下面介绍的快捷键部分,你将会学到如何轻松地显示以及隐藏这些对应的窗口。 下面是组成窗口的每一个独立区域的快速浏览: The Toolbar(工具栏): 你选择视图,运行app,在不同布局界面切换的地方 The Navigation Area(导航区): 导航你整个工程,警告,报错等的地方 The Editing Area(编辑区): 所有奇迹诞生的地方,包括它上方的Jump bar The Utility Area(工具区): 包含检测器和一些库 The Debugging Area(调试区): 包括调试窗口和变量检测器 上面列出的所有视图区域都是Xcode的必要组成部分,它们也是在你开发过程中可能需要用到的,开发过程中通常不需要将他们一次性同时显示出来,下面将介绍一些快捷键,将会教你快速显示/隐藏这些视图区域。 快捷键在这一部分,你将首先学到怎么掌握这些快捷键,得益于一些模式,最有效的快捷键非常容易记。 第一个需要知道的是Xcode的各区域与修饰键的关系,下面是一个快速浏览 Command (⌘):用来导航,控制导航区域 Alt (⎇): 控制右边的一些东西,比如Assistant Editor,utility editor Control: 编辑区域上的Jump bar的一些交互 第二个需要知道的时数字键和标签栏的关系,将数字键和上面提到的修饰键组合可以在标签页之间来回切换。通常数字键对应标签页的索引位置(从1开始),0通常用来显示/隐藏区域。它还能再直观一点吗? 下面是最常用的组合键: Command 1~ 8: 跳转到导航区的不同位置 Command 0 :显示/隐藏导航区 Command Alt 1~ 6:在不同检测器之间跳转 Command Alt 0: 显示/关闭工具区. Control Command Alt 1~4: 在不同库之间跳转 Control 1~ 6: 在Jump bar的不同标签页的跳转。 最后也是最简单的就是回车键,当它和Command组合使用时,可以是你在Xcode中不同编辑器来回切换. Command + Enter: 显示标准单窗口编辑器 Command Alt Enter:你可以猜下它的作用,它的功能是打开Assistant editor Command Alt Shift Enter: 打开版本控制编辑器 同样重要的是显示/隐藏调试区的快捷键是 Command + Shift + Y,要记住这个你可以通过这句话来记忆“Y is my code not working?”(译者注:Y谐音Why)。如果你忘记了一些快捷键,你可以在Xcode的菜单栏Navigate一项中找到大部分快捷键。在即将完成这一部分的学习之时,你会惊奇的发现你仅仅只是用了键盘就让Xcode发生这各种变换。 Xcode的行为使用快捷键来管理Xcode的界面却是挺棒,有没有想过更棒的事情?比如让Xcode自动转换到你想看到的界面。接下来我们将学到更酷的东西。 幸运的是,Xcode提供的Behaviors(行为)可以让你轻易地实现上面的事情。它们是一组定义好的有指定事件触发的动作,比如build一个工程。这里的动作的范围从改变界面到运行一个自定义脚本文件。来看一个例子,快速修改下载好的工程的CTAppDelegate.m文件,使其运行时会生成调试窗口输出,用下面的方法替代didFinishLaunchingWithOptions方法 1234567- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; [[UIApplication sharedApplication] setStatusBarHidden:YES]; // Override point for customization after application launch. NSLog(@&quot;Show me some output!&quot;); return YES;&#125; 运行程序,然后仔细观察调试区,你会发现调试区随着app运行而出现,如下所示 来看看是什么定义了上面的事件,在Xcode-&gt;Behaviors-&gt;Edit Behaviors打开Behavior偏好设置,在左侧你将看到所有事件集合,在右边是该事件可以触发的一些列动作。点击Running栏下的Generates output,然后发现它被设置成用来显示调试区。 一些推荐的行为根据你的开发环境,我推荐的两种不同的Generates output事件触发动作集。如果你有多个屏幕,试着使用第一种,如果是单显示器,试着调到第二种方法。 方法一如果你在两个或者多个屏幕上开发,把调试区放到第二屏幕是不是更加方便,你可以向下面这样设置 现在,运行程序,然后你会看到一个分离的窗口出现,将它放到你的第二屏幕上,是不是效率高了不少? 方法二如果是单屏,通过隐藏工具板以及设置输出窗口占据整个调试区使输出窗口的有效区域最大化,设置如下 然后运行程序,然后观察Xcode,看它是不是按照你的命令在执行。 当程序暂停的时候,你可能也想改变Xcode的行为,到Running栏下的Pauses事件,然后改变其设置,向下面这样: 现在无论何时你设置了断点,你将会得到一个新的名为fix的展示变量和输出窗口的标签页,然后自动导航到第一个issue。 你将要创建的最后一个行为是我个人最喜欢的一个,它是一个自定义行为—设置一个快捷键。当被触发的时候,它使Xcode转变到我指定的为下一次开发而优化的布局,名为Dev Mode。我们可以通过点击Behavior偏好设置的左下角的+,然后将其取名为Dev Mode,双击Dev Mode右边的Command (⌘)符号然后输入Command .来定义一个快捷键 接下来为该事件设置相应动作: 现在,只要你按下command .就会触发上面设置的动作,即出现一个相同的整洁的开发界面。 下面将介绍Xcode tab name,和行为配合起来使用堪称完美。 Xcode Tab Names(Xcode标签名):可以通过双击标签页的标题来修改标签页的名称,对于它本身来说是一个无用的功能,但是当它和行为结合起来使用时就变得非常强大了。在上面的第二个例子中,当改变Pauses行为时,命名了一个叫fix的标签页,这就意味着当行为被触发时,Xcode将会使用fix标签页(如果存在),如果不存在,它会新建一个名为fix的标签页。另一个例子就是多屏Starts行为,如果一个名为Debug的标签页在之前运行时被打开,它将会复用这个标签页而不是重新创建一个。用这种方式,你可以创建非常有趣的行为。 到现在为止,我们可以花点时间来回顾一下刚才的行为,不要着急,本教程会等着你。 小测验在接下来的部分,你将在测验中用到上面所学到的技巧,然后在CardTilt项目中学到一些新的技巧。 运行CardTilt项目中，你看到如下画面 它不是你期待看到的画面？是时候消灭这些bug了！ 锁定bugapp似乎在加载数据时出现了问题，你的任务就是消灭它们。打开CTMainViewController.m文件然后进入开发模式Dev Mode，快捷键为之前设置的command。注意viewDidload方法中的前几行 123self.dataSource = [[CTTableViewDataSource alloc] init];self.view.dataSource = self.dataSource;self.view.delegate = self; 看起来CTTableViewDataSource实现了UITableViewDataSource协议，为tableview提供了数据。是时候展现你Xcode的技术了，按住command键，同时点击CTTableViewDataSource在编辑器中来打开CTTableViewDataSource.h。CTTableViewDataSource.m应该已经在你的Assistant Editor，如果不是这样的话，打开顶部的Jump Bar，像下图一一样切换到Assistant Editor的counterparts模式。 翻看代码，你会发现数组members装载数据，loadData方法从bundle中加载数据至数组members。在assistant editor右边任意位置鼠标右击，选择Open in Primary Editor，就会在Primary Editor中打开CTTableViewDataSource.m文件，下面动画是该步骤的展示： 为了看起来更酷炫，你可以在不用鼠标的情况下完成上面的所有事情，步骤如下： 1.同时按住Command + Shift + O，在输入框中输入CTMainViewController.m，然后回车来打开该文件。 2.Command + . 进入Enter Dev模式 。 3.将鼠标放在 CTTableViewDataSource 上，然后按住Command + Control + J，跳转至CTTableViewDataSource定义处。 4.按住 Command + J, -&gt; 然后按下回车，来转换 assistant editor 的焦点 5.按住 ctrl +4 来下拉 Jump Bar，然后使用方向键和回车键来选择 counterparts 6.按住 Command + Alt，在 primary editor 中打开 CTTableViewDataSource.m 文件 7.上面的结果步骤看起来不呢么高效，但是它让你看起来很酷。 修复bug在self.members = json[@”Team”];打上断点来确定数据是否都被装载到数组members当中，然后运行程序。 如果对于基本的设置断点和调试不太熟悉，可以先看看这篇教程。 就像你之前在Xcode行为看到的一样，Generates output将首先被触发，紧接着Pause行为被触发。因为你之前在Pause有过自定义设置，所以Xcode会新建一个名为fix的标签页，它专为调试而设。 将目光切换到变量检测器variable inspector，你会发现数组members是nil，在loadData方法数组members被填充，代码如下 12NSDictionary *json = [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:&amp;error];self.members = json[@&quot;Team&quot;]; 在变量检测器中查看json，看其是否被正确加载，你会发现数据中的第一个值是@”RWTeam”而不是@”Team”，当加载数组members时，这个值是错的，找到了一个bug。 让我们按下面步骤来修复这个bug： 使用command + .来进入开发模式 按住Command + Option + J跳至filter bar然后输入teammember 然后按住Alt同时点击TeamMembers.json在assistant editor来打开它 最后，使用”Team”来替换”RWTeam” 下图是上面四步的一个动画 现在移除断点，然后运行程序，它看起来应该像这个样子。 是不是看起来比之前要好一点了，但是还是有一些bug，比如Ray和Brian的标题描述栏不见了。接下来我们通过修复这些bug来学到更多酷炫的技巧。 加速你应该已经知道UITableViewCells在tableView:cellForRowAtIndexPath:方法中被加载，所以用Open Quickly来导航到该方法，然后按照下面步骤： 按下Command + Shift + O来呼出Open Quickly 输入cellForRow 按下回车来打开它 按住command然后点击setupWithDictionary来跳转至其定义处，然后你会发现一些用来加载描述的代码 12NSString *aboutText = dictionary[@&quot;about&quot;]; // Should this be aboot? self.aboutLabel.text = [aboutText stringByReplacingOccurrencesOfString:@&quot;\\n&quot; withString:@&quot;\n&quot;]; 它使用dictionary[@”about”]中的数据来加载label。 接下来呼出Open Quickly，然后打开TeamMembers.json，使用alt + command在Assistant Editor中打开。检查about的值，然后你会发现有人将about拼写成了aboot，我们可以使用全局的Find and Replace来修复这个bug。当然你可以在文件中直接做这件事，但是使用find navigate看起来更酷。打开find navigate，然后通过顶部的jump bar切换到替换(replace)模式，输入aboot,然后回车。 在TeamMembers.json文件之外还有一个地方使用到了aboot，别担心，选中CTCardCell.m的搜索结果，然后按下Delete，将鼠标移至replace filed，然后输入about，点击Replace All，一切完成。整个过程看起来是这个样子的： 进阶技巧:使用 Command + Shift + Option + F 来打开 Find navigator 的替换模式，如果你嫌麻烦，也可以使用 Command + Shift + F 来打开 Find navigator 的查找模式，如果你还嫌麻烦，使用 command + 3 来打开 Find navigator，然后开启查找或者替换模式，选择一种最适合自己的方式就好。 运行程序，看起来是这样的 让设计师高兴今天的调试任务到此就结束了，给自己一点掌声，然后开始运行程序。在你将它展示给别人之前，需要先确定app的界面是完美的。尤其当这个人是非常认真的设计师的时候，这一部分教你一些关于interface builder的技巧，让你变得更酷。 打开Mainstoryboard.storyboard，通常你想在打开interface builder的同时打开standard editor和工具区(utilities area)，所以我们可以自定义一个新的叫做IB Mode的行为，当你在看下面的自定义发放之前，试着自己创建一个然后自定义，不必要完全一致。 我将这个模式的快捷键设置为Command Option .，现在你将看到一个舒服的Interface Builder界面，看看CTCardCell。首先你想让mainView处于ContentView的正中央。有两种技巧可以完成这个需求： 按住Control + Shift，然后在mainView的任意位置鼠标左击，你将看到一个弹出视图让你选择在光标下的所有视图，如下图所示： 这个方法让你轻松的就能选中mainView，尽管cardbg遮住了它。选中mainView之后，按住Alt然后在ContentView的边缘移动鼠标，来看它们之间的间隔。下面是这个过程的一个动画： 原来对其并不是那么优雅，看起来也不是很酷。为了解决这个，我们可以调整视图的大小。点击Editor-&gt;Canvas-&gt;Live Autoresizing来使子视图在父视图尺寸改变的时候强制调整大小。按住Alt同时拖拽mainView的一角，直到每边的距离为15. 拖拽是像素点级别的技巧，你可以尝试不同的调整的处理方法，就像下面动画一样。在很多情况下，更倾向于使用Size Inspector来调整复杂的布局，而非用鼠标来拖拽。 试着使用相同的技巧来对齐titleLabel、locationLabel、aboutLabel,让他们竖直方向上的间隔为0。按住Alt来查看鼠标移动时，三个label之间的间隔。有发现三个label的左边缘并没有对齐吗？设计师肯定想让nameLabel和webLabel靠左对齐。使用Vertical Guide可以昂我们轻松完成这个任务。选中cardbg，然后点击菜单栏的Editor-&gt;Add Vertical Guide，这个步骤的快捷键是Command |，horizontal guide的快捷键是Command -，这两个快捷键是最可视化的。当视图上有了vertical guide之后，将其从cardbg的左边缘拖10个点。然后所有视图将会紧贴vertical guide，对的非常整齐，继续为其他的label进行对其操作。 Xcode并不那么完美，有时候可能在你创建guideline的时候出现一些问题，可以打开其他文件然后再切回到storyboard页面，然后storyboard会被重新加载，这个时候问题一般会自动解决。让你更酷的建议：所有的视图能紧贴在guideline上才是最好的，guideline没有必要在同一个层级。 下图是上面对齐过程的一个回放： 我敢打赌你现在迫不及待的想把你做的展示给你的设计师看！ 提升和超越上面的步骤让你得到了一个实用的app，同时让你的设计师也感到很满意，那么接下来我们要做的就是让代码变得更为简洁。 快速打开(Command + Shift + O)CTCardCell.m，记得进入Dev Mode(Command .)，你应该不会忘了这些快捷键吧。 看下CTCardCell.m顶部凌乱的属性列表 1234567891011121314@property (weak, nonatomic) IBOutlet UILabel *locationLabel;@property (strong, nonatomic) NSString *website;@property (weak, nonatomic) IBOutlet UIButton *fbButton;@property (weak, nonatomic) IBOutlet UIImageView *fbImage;@property (strong, nonatomic) NSString *twitter;@property (weak, nonatomic) IBOutlet UIButton *twButton;@property (weak, nonatomic) IBOutlet UILabel *webLabel;@property (weak, nonatomic) IBOutlet UIImageView *profilePhoto;@property (strong, nonatomic) NSString *facebook;@property (weak, nonatomic) IBOutlet UIImageView *twImage;@property (weak, nonatomic) IBOutlet UILabel *aboutLabel;@property (weak, nonatomic) IBOutlet UIButton *webButton;@property (weak, nonatomic) IBOutlet UILabel *nameLabel;@property (weak, nonatomic) IBOutlet UILabel *titleLabel; 在这部分，你将创建一个自定义服务以执行脚本命令来实现属性的快速整齐地排列。 如果对于这些脚本命令还不熟悉，它们是相当好理解的。排序(sort)是按照字母顺序来的，uniq是会删除所有重复的行数。uniq在这里可能派不上用场，但是用它来管理#import，那是极好的。 Mac OS X允许你创建整个操作系统全局通用的服务，你将用它来创建一个用在Xcode中的脚本服务，按如下步骤来设置 使用Spotlight来搜索Automator，并打开它然后点击File-&gt;New，并选择服务(service)一项在Actions筛选栏，输入shell，然后双击运行shell脚本Run Shell Script在新添加的服务的菜单栏上,检查Output replaces selected text将脚本内容切换至sort | uniq同时按下command s，将服务保存为 Sort &amp; Uniq最终的窗口看起来是这个样子： 切回到Xcode，然后选中CTCardCell.m中的那片混乱的属性区域，右击，选择Services -&gt; Sort &amp; Uniq，然后观察执行之后代码是多么的整洁。你可以看下面的一个示意图： 代码片段进行到这里，意味着那些基本的可以让你看起来酷酷的调试任务已经告一段落了，接下来我希望你觉得更酷。你可定想学更多技巧，幸运的是，这是最后分享的一个技巧。 你之前可能已经使用过Xcode的代码片段(Code Snippets)功能了，一些常见的是for in片段和dispatch_after片段。在这一部分，你将学会如何创建自定义的代码片段，当你重用这些代码片段时，看起来非常棒。你将创建的是获取单例的代码片段。 如果你不熟悉单例模式，可以看看这个教程。 下面可能是你使用单例模式的常用代码模板 12345678+ (instancetype)sharedObject &#123; static id _sharedInstance = nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;oncePredicate, ^&#123; _sharedInstance = [[self alloc] init]; &#125;); return _sharedInstance;&#125; 非常酷的是这份片段也包含了dispatch_oncep片段。 在工程CardTilt创建一个名为继承自NSObject名为SingletonObject的新类，你不需要为它做任何事，除了作为拖拽代码片段的一个地方。 按下面步骤： 在@implementation 的下一行粘贴上面的代码到SingletonObject.m 用快捷键Command Option Control 2来打开代码片段库，在代码片段库中你会看到默认的包含在Xcode中的代码片段库。 选中整个+sharedObject方法，将其拖拽到代码片段库中。看起来是这样的： 新创建的代码片段将会在代码片段库的最底部，你可以将其拖拽到任何你想拖拽的文件当中去，让我们来尝试一下。 双击刚刚新建的代码片段，然后点击edit.弹出的视图非常使用，实际上它们都很重要，所以做个简短的解释。 Title and Summary：代码片段库中该代码片段的名字和简述 Platform and Language:代码片段匹配的平台和编程语言 Completion Shortcut:在Xcode中输入的快捷键 Completion Scopes:代码片段作用的范围，这对于保持代码片段库整洁来说十极好的。向下面一样填充里面的属性： 令牌当你加入令牌时，代码片段将会变得非常强大，因为它允许你在片段中标记代码，而不需要硬编码。通过使用Tab键使得他们非常容易修改，就像自动补全一样。 在片段中仅仅只要输入&lt;#TokenName#&gt;就可以添加一个令牌，创建一个令牌使用shared&lt;#ObjectName#&gt;替代sharedObject，看起来像这样： 点击Done来保存该片段，然后来用用它。 在SingletonObject.m文件中输入singleton accessor，然后当它出现的时候使用自动补全 对于经常使用的代码来说，创建一个代码片段是非常实用的。 何去何从总结一下在这个教程中你所学到的东西： 使用快捷键来改变Xcode的布局 使用自定义的行为来改变Xcode的布局 使用assistant editor 在Xcode中快速打开某文件 在Find navigator删除搜索到的结果 在Interface Builder使用快捷键和guideline来对齐视图 创建一个在Xcode中使用的服务 创建并使用自定义的代码片段 最重要的是你知道怎么去成为一名Xcode大师 上面列出来的内容都很简单对吧？在你的朋友面前展示这些炫酷的技巧，你的朋友一定会惊呆也会理解你的兴奋。还有很多方法可以提高你的Xcode的效率，比如： 使用Doxygen风格的注释 使用Xcode插件 下一步就是去寻找新的酷炫的技巧，我希望你能享受整个教程的学习过程，如果你有任何问题、评论、或者想分享你所知道的炫酷技巧，请在下面评论中指出。]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最近随想及学期总结]]></title>
    <url>%2F2014%2F06%2F21%2FRecent-Thoughts%2F</url>
    <content type="text"><![CDATA[今天6.21号，学校一年一届的毕业晚会——同歌同行如期进行，这也预示着我下一年也即将滚蛋,外面正进行着很High的泼水节,今年不像前两年那样去混进毕业游行队伍,觉得明年就到自己了,今年就不去凑热闹了.。昨天院里的毕业晚会，看了即将离开的学长学姐的各种有节操没节操的表演，觉得四年过的真的太快。回来的路上，jb说明年毕业晚会你也上去弹唱一首吧，感觉好伤感。 这学期也马上要结束了，感觉学期初的计划只实现了一半。前期一直在忙着准备找实习，各种充电，从数据结构到算法，从C到Java,从Objective-C到iOS开发。感觉自己需要学的东西太多，而以前积累的知识完全不够。初期的网易终面被刷、去哪儿网笔试跪了、阿里内推电话面试之后没了下文、腾讯笔试没过、华为一面过后莫名其妙地没了下文，一系列的失败被拒让我一度陷入一个迷茫期，同时开始反省自己，然后一步步调整。五月过后，各大互联网公司基本已经结束了实习生的招聘，由于不想跟学校安排的实习，所以报了一个老师的实验室。看着课题是智慧老人系统，看着感觉比较对自己的兴趣，因为前期一直在做一个基于BLE4.0的智能家居的iOS客户端，觉着智能及自动化是未来的一个趋势。但是过去向老师进一步了解后，发现需要做的和我想的完全背道而驰，现在还在纠结要不要继续和他做下去。之后，又一家互联网公司到学校开宣讲会，以及现场笔试，笔试时感觉比较顺利，都是一些很基础的东西，虽然我的基础也并不扎实，但还是过了笔试，收到了第二天面试的通知。第二天的技术面和终面表现得都还可以，和面试官也很聊的来，两位面试官人都很nice。最后也收到了该公司的实习offer，感觉比较幸运。报的岗位是iOS，正对自己的兴趣，所以暑假过去要好好表现。 后期就是准备考试,感觉大三以来基本没听过课,都是沉浸在自己的世界里,看编程方面的书,看iOS的API文档。突然感觉自己的兴趣和专业已没多大联系了,这是不是一种悲哀呢?前期学业成绩感觉就那样了吧，达到了最低底线没有挂科，都是70左右在徘徊。接下来这几天也马上要考试,又得准备抱抱佛脚了,不得不先放放原来定的每天一个Session的计划了,等考完之后,再继续。 这学期的面试以及和一些人的接触过程中,有一些印象深刻的切身体会,那就是牛逼的人他们的说话方式都很有型，让人感觉什么事在他们眼中都不算问题。其实他们如今的对自己经历的一种轻描淡写甚至一笔带过，都是在经历了牛逼之前那段黑暗的迷茫期的磨练和铺垫后的一种释然。 接下来暑假期待完成的事有: 实习到岗前,做一个小型的应用,争取上线。 实习期间,多多学习,去熟悉一个完整的大型的App的开发流程,好好表现争取转正。 加强基础,为秋招做准备。]]></content>
      <categories>
        <category>扯淡集</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杭州网易行]]></title>
    <url>%2F2014%2F03%2F19%2FInterview-In-NetEase%2F</url>
    <content type="text"><![CDATA[周三接到网易电话，说上次电话面试通过了，让我周末过去杭州总部面试，于是周末就去了趟杭州。这篇文章是关于网易这次面试的相关内容和自己面试后的感想，写出来和大家分享一下。 面试过程3.4号接到网易的电话，说预约第二天下午三点进行电话面试，然后自己就开始准备自我介绍什么的。这里有个乌龙事件，之前投了份网易游戏的实习生，原来以为是游戏实习生的面试，几天之后接到网易游戏部的“虽然您很优秀…”的邮件，才知道原来游戏是招至少硕士学历的，这次电话面试并不是网易游戏的面试（后来才想起是之前投的网易iOS开发工程师实习生的职位，真囧~~）。下面是第二天电话面试的大致内容，记得不是很清楚了，我大致还原一下当时的情景。忽略一些客气语，下面直接进入正题。 面试官（以下以Q代替）：你学习iOS多长时间了？我（下面以A代替）：十个月的样子。Q：你了解MRC和ARC吗？A：对他们都有一定的了解，但用的更多的是ARC，当然也知道MRC的规则及用法，也有做过相关Demo，由于开始学习iOS的时候ARC已经成为一种趋势，所以用的更多的是ARC。Q：好的。你熟悉autorelease吗？谈谈它和ARC的区别是什么？A：autorelease是将对象添加到NSAutoReleasePool里面，然后在调用[pool drain]方法后，所有在释放池里面的对象均被release。而ARC看起来的效果是一样的，但是实质是不一样的，ARC是系统在适当时候来释放一个对象的。Q：嗯。你了解NSObject和NSObject Protocol吗？他们有什么区别，为什么要有NSobject Protocol？A：NSObject几乎是iOS开发过程中所有类的根类，NSObject协议是为了方便一些并没有继承自NSObject的自定义类，来实现NSObject的一些方法，因为二者的方法大部分是一样的。Q：那你知道哪些类是不继承自NSObject的？以及这样做的原因是什么？A：据我目前见到的情况来看，貌似没有，但肯定有这种类。至于这样做的原因我不太清楚。（面试完后google了一下，大概了解了相关情况）Q：你了解运行时吗？A：了解一点点。Q：嗯，没事，那你说说你了解的。A：运行时就是在运行时来进行判断，比如内省。像respondeToXXX这些方法应该都是运行时才执行的。我知道的大概也就这么多了。Q：你用过哪些开源库？A：暑假做一个游戏客户端的时候用过CocoaAsyncSocket。Q：你有仔细看过它的源码吗？你认为它的哪些方面可以优化呢？A：当时项目比较紧，所以直接拿过来就用了，就看了一些自己需要用到的方法的实现。优化的话，暂时还没有想过。Q：那如果你现在再去看这个开源库的时候你觉得你会学到哪些东西？A：这个库是分TCP和UDP的，当时我们用的是TCP，这次如果再去看的话，应该对UDP也会有一定的了解和学习，同时也可以考虑一些可以优化的地方。Q：对于其他的比较经典的关于网络方面的开源库还用过哪些？A：AFNetworking，ASIHttp。Q：嗯，其他的开源库呢？A：用过那个在ios5，6下实现ios7扁平风格的控件的库，其他的都不记得名字了。Q：你了解越狱吗？该怎么判断设备是否越狱？A：了解一点点。您说的是只用代码判断吗？代码的话我不太清楚。（面试后google了一下，大致思想是检测是否多出越狱的文件目录，网上现成的代码也有，随便一搜就能搞定）Q：了解copy和mutableCopy吗？谈谈二者的区别A：了解。copy只是指针的复制，属于浅拷贝，mutableCopy是深拷贝。（之后他举了个例子，忘记了，反正就是NSString和NSMutableString的一些东西。如果你有疑问，可以看看我之前的文章—&gt;OC内存管理学习）Q：怎么判断一个类是否遵循某个协议？A：可以用respondTo协议里的某个方法来实现。Q：还有没有其他的方法呢？A：其他的应该有但是我不知道。因为我最常用的就是上面的这个方法。Q：假如我有一个对象不想实现系统默认的方法，我能够做到吗？A：可以用分类（categrey）吧，（迟疑片刻后想想不对），应该不行。（面试之后，自己再想了下应该可以复写其父类方法就行，不知道对不对）Q：你用过GCD和NSOperation吗？它们常用的场景是什么？谈谈你的看法。A：都用过。NSOperation是对GCD的封装，属于类级别的，GCD是底层的属于C级别的。GCD的效率可能会更高，因为基本上全是执行block。Q：你平时用哪种方式呢？A：一般图片加载用的是GCD，而其他下载任务用的是NSOperation。Q：GCD能够随时停止吗？NSOperation呢？如果能的话又是调用什么方法呢？A：GCD由于调用的是block，所以它一旦开始在执行完之前是不能停止或取消的。而Operation是可以的，通过KVO即可。当然如果要取消的话，我记得有个方法，名字貌似是close？（面完后查了下是cancel）之后就是换了一个人，问了下我的相关情况和实习时间的安排，然后让我等电话通知。五天之后，接到电话，说让我周六下午去杭州面试。然后问了下费用问题，是不报销路费的，本来不打算去了，回来看看车费也不贵，于是想想觉得还是去吧。就算不过，也当长次经验还可以顺带去西湖看看。坐了一晚的火车，第二天到网易大厦，一进大厅感觉自己是土鳖进城（哎，没见过世面）。下午一点到，在大厅等了45分钟，就有人过来叫我去面试，没想到这次还是技术面，本以为是HR面了。进到玻璃间，面试官先问了我的一些情况，怎么来的，来这之后住哪里，看你精神不太好啊。我回“坐了通宵火车”等等。听声音感觉是和上一次电面的是同一个。Q：上次面完之后你有什么感想？面完之后有没有写blog什么的。A：感觉自己很多方面的知识很薄弱，有待提高，blog倒是还没整理好，只是网上查了一下上次那些不知道的。Q：那现在你对那些问题有了什么新的认识？A：然后我就说了一下我对于那些知识的一个总结。Q：有没有相关的项目经验呢？A：帮一个公司做过一个类似QQ游戏大厅的客户端。实现登录以及各个游戏的在线人数显示，主要是从安卓端到iOS端的移植。Q：那你对安卓应该也有所了解吧，说说他们之间的区别？A：。。。谈了下自己的认识。Q：除了这些，你自己平时有没有做过小的东西来玩一玩？A：我掏出iTouch，然后拿出几个月前写的计算器给他看，然后介绍了下这个计算器实现的功能。Q：（把玩了一下）嗯，看起来还不错，主要精力应该是花在了解析字符串上吧，UI有点。。。A：确实，几乎都是字符串的解析，然后通过用数组来模拟栈进而实现括号的匹配。UI设计当时确实没怎么在意。（关于计算器，源代码戳这里）Q：这个好像是单机的，有没有做过网络方面的？A：有过，去年的时候加校内的iOS团队，然后他们给我的任务是做一个RSS音乐播放器，主要实现XML的解析，然后下载，还有就是播放器的实现。 然后我也记不清还问了哪些问题，紧接着他拿出一张纸，说这里有两个题目，你看下。先做第一题。一看全是逻辑题，突然觉得自己智商不够用。 1.你到了一个十字路口，不知道该往哪边走。路口有两个人，一人只说真话，一人只说假话，但不知道谁说真话，谁说假话。问：你如何才能只问其中一个人问题，就能知道该走哪条路。 2.你到了一个十字路口，不知道该往哪边走。一条路通往真话村，一条通往假话村，真话村的人只讲真话，假话村的人只讲假话。这个时候你发现路口有一个人，很显然他不是真话村就是假话村的村民，现在你如何只问他一个问题，就能知道那条路通往假话村。 看到第一题我想，这种题目应该是问其中一个人自相矛盾的问题，然后通过回答的内容来得出答案。虽然点子是对的，但是就是不知道怎么提问。这时候面试官在旁边说，你可以把你的想法说出来，然后我就说了一些。。但是又被自己否定了。然后他就开始提示我，一步步把我往答案的方向带，最后终于在他的点拨下得出了答案。第二题也是一样的情况，只不过一开始他说，这个题目我不会再给你提示了。然后。。我又开始想，好几分钟后，他又开始提示了，这样，又得出了答案。最后他拿出一个算法题出来让我写，大致就是数电里面的摩根定理，比如NOT AND A，B转化为NOT A OR NOT B这样子。。我一开始说可以用栈来实现，但是仔细想想又不好确定，然后他又提示了，你看看二叉树会不会比栈方便些。大致思路如下 AND（not） OR / \ ---&gt; / \ A B NOT NOT / \ A B 就是把前面有NOT的AND，将NOT作为它的tag，然后操作数分别作为其左右孩子，这样进一步转化，将AND（not）转换成OR，not下移，操作数随之移动。到最后，not均被移到底层，即可实现摩根定律。然后就问我为什么要从事iOS开发？这之后就问我实习时间，然后问我还有没有什么疑问，说结果到时候会通知我。之后就是”Say GoodBye”了。 一些感受这次面试之后总结了一下，发现自己的基础知识掌握的还不是很牢固，项目经验匮乏。尤其是逻辑推理题，自己的思路还不是很清晰，有待于训练。然后觉得很多面试，笔试有些片面，用这种算法题来考。如果有大量时间的话，那些刷题的人对于这些问题岂不是分分钟就解决了，工作后上手项目如果不能灵活运用是不是和当初的选拔目的相违背了。然后仔细想想，这也是没办法的办法，只能通过这种方式来筛选。这里仅仅是个人观点，如果让你觉得不爽请忽略。这两次面试过程中自己都没有紧张感产生，觉得不可思议，可能都是自己比较熟悉的东西，然后现场的气氛也很好的缘故吧，希望这种状态能延续下去。最后，其实面试官人很好，很nice，在我回答不上的时候一直提示我。更重要的一点，此人有点像一初中同学，一见面就有种亲切感。]]></content>
      <categories>
        <category>扯淡集</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>原创</tag>
      </tags>
  </entry>
</search>