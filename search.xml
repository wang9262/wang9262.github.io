<?xml version="1.0" encoding="UTF-8"?><search><entry><title>杭州网易行</title><link href="/posts/Interview-In-NetEase"/><url>/posts/Interview-In-NetEase</url><content type="html"><![CDATA[<p>周三接到网易电话，说上次电话面试通过了，让我周末过去杭州总部面试，于是周末就去了趟杭州。这篇文章是关于网易这次面试的相关内容和自己面试后的感想，写出来和大家分享一下。</p><h3>面试过程</h3><p>3.4号接到网易的电话，说预约第二天下午三点进行电话面试，然后自己就开始准备自我介绍什么的。这里有个乌龙事件，之前投了份网易游戏的实习生，原来以为是游戏实习生的面试，几天之后接到网易游戏部的“虽然您很优秀…”的邮件，才知道原来游戏是招至少硕士学历的，这次电话面试并不是网易游戏的面试（后来才想起是之前投的网易iOS开发工程师实习生的职位，真囧~~）。 下面是第二天电话面试的大致内容，记得不是很清楚了，我大致还原一下当时的情景。忽略一些客气语，下面直接进入正题。</p><blockquote><p>面试官（以下以Q代替）：你学习iOS多长时间了？ 我（下面以A代替）：十个月的样子。 Q：你了解MRC和ARC吗？ A：对他们都有一定的了解，但用的更多的是ARC，当然也知道MRC的规则及用法，也有做过相关Demo，由于开始学习iOS的时候ARC已经成为一种趋势，所以用的更多的是ARC。 Q：好的。你熟悉autorelease吗？谈谈它和ARC的区别是什么？ A：autorelease是将对象添加到NSAutoReleasePool里面，然后在调用[pool drain]方法后，所有在释放池里面的对象均被release。而ARC看起来的效果是一样的，但是实质是不一样的，ARC是系统在适当时候来释放一个对象的。 Q：嗯。你了解NSObject和NSObject Protocol吗？他们有什么区别，为什么要有NSobject Protocol？ A：NSObject几乎是iOS开发过程中所有类的根类，NSObject协议是为了方便一些并没有继承自NSObject的自定义类，来实现NSObject的一些方法，因为二者的方法大部分是一样的。 Q：那你知道哪些类是不继承自NSObject的？以及这样做的原因是什么？ A：据我目前见到的情况来看，貌似没有，但肯定有这种类。至于这样做的原因我不太清楚。（面试完后google了一下，大概了解了相关情况） Q：你了解运行时吗？ A：了解一点点。 Q：嗯，没事，那你说说你了解的。 A：运行时就是在运行时来进行判断，比如内省。像respondeToXXX这些方法应该都是运行时才执行的。我知道的大概也就这么多了。 Q：你用过哪些开源库？ A：暑假做一个游戏客户端的时候用过CocoaAsyncSocket。 Q：你有仔细看过它的源码吗？你认为它的哪些方面可以优化呢？ A：当时项目比较紧，所以直接拿过来就用了，就看了一些自己需要用到的方法的实现。优化的话，暂时还没有想过。 Q：那如果你现在再去看这个开源库的时候你觉得你会学到哪些东西？ A：这个库是分TCP和UDP的，当时我们用的是TCP，这次如果再去看的话，应该对UDP也会有一定的了解和学习，同时也可以考虑一些可以优化的地方。 Q：对于其他的比较经典的关于网络方面的开源库还用过哪些？ A：AFNetworking，ASIHttp。 Q：嗯，其他的开源库呢？ A：用过那个在ios5，6下实现ios7扁平风格的控件的库，其他的都不记得名字了。 Q：你了解越狱吗？该怎么判断设备是否越狱？ A：了解一点点。您说的是只用代码判断吗？代码的话我不太清楚。（面试后google了一下，大致思想是检测是否多出越狱的文件目录，网上现成的代码也有，随便一搜就能搞定） Q：了解copy和mutableCopy吗？谈谈二者的区别 A：了解。copy只是指针的复制，属于浅拷贝，mutableCopy是深拷贝。（之后他举了个例子，忘记了，反正就是NSString和NSMutableString的一些东西。如果你有疑问，可以看看我之前的文章—&gt;OC内存管理学习） Q：怎么判断一个类是否遵循某个协议？ A：可以用respondTo协议里的某个方法来实现。 Q：还有没有其他的方法呢？ A：其他的应该有但是我不知道。因为我最常用的就是上面的这个方法。 Q：假如我有一个对象不想实现系统默认的方法，我能够做到吗？ A：可以用分类（categrey）吧，（迟疑片刻后想想不对），应该不行。（面试之后，自己再想了下应该可以复写其父类方法就行，不知道对不对） Q：你用过GCD和NSOperation吗？它们常用的场景是什么？谈谈你的看法。 A：都用过。NSOperation是对GCD的封装，属于类级别的，GCD是底层的属于C级别的。GCD的效率可能会更高，因为基本上全是执行block。 Q：你平时用哪种方式呢？ A：一般图片加载用的是GCD，而其他下载任务用的是NSOperation。 Q：GCD能够随时停止吗？NSOperation呢？如果能的话又是调用什么方法呢？ A：GCD由于调用的是block，所以它一旦开始在执行完之前是不能停止或取消的。而Operation是可以的，通过KVO即可。当然如果要取消的话，我记得有个方法，名字貌似是close？（面完后查了下是cancel） 之后就是换了一个人，问了下我的相关情况和实习时间的安排，然后让我等电话通知。 五天之后，接到电话，说让我周六下午去杭州面试。然后问了下费用问题，是不报销路费的，本来不打算去了，回来看看车费也不贵，于是想想觉得还是去吧。就算不过，也当长次经验还可以顺带去西湖看看。 坐了一晚的火车，第二天到网易大厦，一进大厅感觉自己是土鳖进城（哎，没见过世面）。下午一点到，在大厅等了45分钟，就有人过来叫我去面试，没想到这次还是技术面，本以为是HR面了。 进到玻璃间，面试官先问了我的一些情况，怎么来的，来这之后住哪里，看你精神不太好啊。我回“坐了通宵火车”等等。听声音感觉是和上一次电面的是同一个。 Q：上次面完之后你有什么感想？面完之后有没有写blog什么的。 A：感觉自己很多方面的知识很薄弱，有待提高，blog倒是还没整理好，只是网上查了一下上次那些不知道的。 Q：那现在你对那些问题有了什么新的认识？ A：然后我就说了一下我对于那些知识的一个总结。 Q：有没有相关的项目经验呢？ A：帮一个公司做过一个类似QQ游戏大厅的客户端。实现登录以及各个游戏的在线人数显示，主要是从安卓端到iOS端的移植。 Q：那你对安卓应该也有所了解吧，说说他们之间的区别？ A：。。。谈了下自己的认识。 Q：除了这些，你自己平时有没有做过小的东西来玩一玩？ A：我掏出iTouch，然后拿出几个月前写的计算器给他看，然后介绍了下这个计算器实现的功能。 Q：（把玩了一下）嗯，看起来还不错，主要精力应该是花在了解析字符串上吧，UI有点。。。 A：确实，几乎都是字符串的解析，然后通过用数组来模拟栈进而实现括号的匹配。UI设计当时确实没怎么在意。（关于计算器，源代码戳这里） Q：这个好像是单机的，有没有做过网络方面的？ A：有过，去年的时候加校内的iOS团队，然后他们给我的任务是做一个RSS音乐播放器，主要实现XML的解析，然后下载，还有就是播放器的实现。</p></blockquote><p>然后我也记不清还问了哪些问题，紧接着他拿出一张纸，说这里有两个题目，你看下。先做第一题。一看全是逻辑题，突然觉得自己智商不够用。</p><blockquote><p>1.你到了一个十字路口，不知道该往哪边走。路口有两个人，一人只说真话，一人只说假话，但不知道谁说真话，谁说假话。问：你如何才能只问其中一个人问题，就能知道该走哪条路。</p></blockquote><blockquote><p>2.你到了一个十字路口，不知道该往哪边走。一条路通往真话村，一条通往假话村，真话村的人只讲真话，假话村的人只讲假话。这个时候你发现路口有一个人，很显然他不是真话村就是假话村的村民，现在你如何只问他一个问题，就能知道那条路通往假话村。</p></blockquote><p>看到第一题我想，这种题目应该是问其中一个人自相矛盾的问题，然后通过回答的内容来得出答案。虽然点子是对的，但是就是不知道怎么提问。这时候面试官在旁边说，你可以把你的想法说出来，然后我就说了一些。。但是又被自己否定了。然后他就开始提示我，一步步把我往答案的方向带，最后终于在他的点拨下得出了答案。第二题也是一样的情况，只不过一开始他说，这个题目我不会再给你提示了。然后。。我又开始想，好几分钟后，他又开始提示了，这样，又得出了答案。 最后他拿出一个算法题出来让我写，大致就是数电里面的摩根定理，比如NOT AND A，B转化为NOT A OR NOT B这样子。。我一开始说可以用栈来实现，但是仔细想想又不好确定，然后他又提示了，你看看二叉树会不会比栈方便些。大致思路如下</p><p>AND（not） OR /  ---&gt; / <br> A B NOT NOT / <br> A B<br>就是把前面有NOT的AND，将NOT作为它的tag，然后操作数分别作为其 左右孩子，这样进一步转化，将AND（not）转换成OR，not下移，操 作数随之移动。到最后，not均被移到底层，即可实现摩根定律。 然后就问我为什么要从事iOS开发？这之后就问我实习时间，然后问我还有没有什么疑问，说结果到时候会通知我。之后就是”Say GoodBye”了。</p><h3>一些感受</h3><p>这次面试之后总结了一下，发现自己的基础知识掌握的还不是很牢固，项目经验匮乏。尤其是逻辑推理题，自己的思路还不是很清晰，有待于训练。然后觉得很多面试，笔试有些片面，用这种算法题来考。如果有大量时间的话，那些刷题的人对于这些问题岂不是分分钟就解决了，工作后上手项目如果不能灵活运用是不是和当初的选拔目的相违背了。然后仔细想想，这也是没办法的办法，只能通过这种方式来筛选。这里仅仅是个人观点，如果让你觉得不爽请忽略。这两次面试过程中自己都没有紧张感产生，觉得不可思议，可能都是自己比较熟悉的东西，然后现场的气氛也很好的缘故吧，希望这种状态能延续下去。 最后，其实面试官人很好，很nice，在我回答不上的时候一直提示我。更重要的一点，此人有点像一初中同学，一见面就有种亲切感。</p>]]></content><tag>杂谈</tag><tag>原创</tag></entry><entry><title>最近随想及学期总结</title><link href="/posts/Recent-Thoughts"/><url>/posts/Recent-Thoughts</url><content type="html"><![CDATA[<p>今天6.21号，学校一年一届的毕业晚会——同歌同行如期进行，这也预示着我下一年也即将滚蛋,外面正进行着很High的泼水节,今年不像前两年那样去混进毕业游行队伍,觉得明年就到自己了,今年就不去凑热闹了.。昨天院里的毕业晚会，看了即将离开的学长学姐的各种有节操没节操的表演，觉得四年过的真的太快。回来的路上，jb说明年毕业晚会你也上去弹唱一首吧，感觉好伤感。</p><p>这学期也马上要结束了，感觉学期初的计划只实现了一半。前期一直在忙着准备找实习，各种充电，从数据结构到算法，从C到Java,从Objective-C到iOS开发。感觉自己需要学的东西太多，而以前积累的知识完全不够。初期的网易终面被刷、去哪儿网笔试跪了、阿里内推电话面试之后没了下文、腾讯笔试没过、华为一面过后莫名其妙地没了下文，一系列的失败被拒让我一度陷入一个迷茫期，同时开始反省自己，然后一步步调整。五月过后，各大互联网公司基本已经结束了实习生的招聘，由于不想跟学校安排的实习，所以报了一个老师的实验室。看着课题是智慧老人系统，看着感觉比较对自己的兴趣，因为前期一直在做一个基于BLE4.0的智能家居的iOS客户端，觉着智能及自动化是未来的一个趋势。但是过去向老师进一步了解后，发现需要做的和我想的完全背道而驰，现在还在纠结要不要继续和他做下去。之后，又一家互联网公司到学校开宣讲会，以及现场笔试，笔试时感觉比较顺利，都是一些很基础的东西，虽然我的基础也并不扎实，但还是过了笔试，收到了第二天面试的通知。第二天的技术面和终面表现得都还可以，和面试官也很聊的来，两位面试官人都很nice。最后也收到了该公司的实习offer，感觉比较幸运。报的岗位是iOS，正对自己的兴趣，所以暑假过去要好好表现。</p><p>后期就是准备考试,感觉大三以来基本没听过课,都是沉浸在自己的世界里,看编程方面的书,看iOS的API文档。突然感觉自己的兴趣和专业已没多大联系了,这是不是一种悲哀呢?前期学业成绩感觉就那样了吧，达到了最低底线没有挂科，都是70左右在徘徊。接下来这几天也马上要考试,又得准备抱抱佛脚了,不得不先放放原来定的每天一个Session的计划了,等考完之后,再继续。</p><p>这学期的面试以及和一些人的接触过程中,有一些印象深刻的切身体会,那就是牛逼的人他们的说话方式都很有型，让人感觉什么事在他们眼中都不算问题。其实他们如今的对自己经历的一种轻描淡写甚至一笔带过，都是在经历了牛逼之前那段黑暗的迷茫期的磨练和铺垫后的一种释然。</p><p>接下来暑假期待完成的事有:</p><ul><li>实习到岗前,做一个小型的应用,争取上线。</li><li>实习期间,多多学习,去熟悉一个完整的大型的App的开发流程,好好表现争取转正。</li><li>加强基础,为秋招做准备。</li></ul>]]></content><tag>杂谈</tag><tag>原创</tag></entry><entry><title>高效利用你的Xcode[译]</title><link href="/posts/Using-Xcode-Efficiently"/><url>/posts/Using-Xcode-Efficiently</url><content type="html"><![CDATA[<p>好莱坞电影里经常看到黑客们手指在键盘上飞速跳跃,同时终端上的代码也随着飞舞。如果你也想像电影里那样,那么你来对地方了。这篇教程将会教你在Xcode编程中更像程序员,你可以称之为魔法、疯狂的技术、好运当头或者黑客。毫无疑问,在学习完本教程之后,不管你怎么认为,都会感觉很酷,同时能更高效地运用Xcode,甚至可以通过这些新发现使你的代码免于毁灭。</p><p><a href="http://www.raywenderlich.com/72021/supercharging-xcode-efficiency" target="_blank">原文地址</a></p><h3>开始</h3><p>要看起来很酷,所以有一些必不可少的因素.下面列出来的是其中一部分</p><ul><li>快速执行任务</li><li>精准</li><li>简洁美观的代码</li></ul><p>要表现地更酷,你可以试着不用鼠标或者触摸板来完成教程中的每一个任务.学习之旅将从学习一些实用的Xcode功能开始,然后通过修复一些在CardTilt中的一些bug来训练。最后你将整理一下你的代码,使整个界面看起来更整洁。在学习该教程时,要记住:它不是教你做一个app,而是教你比以前更有效地利用Xcode来开发app。这篇教程建立在你对Xcode有一个基本的了解的基础上,然后着重于提高你的工作效率。每个人都有自己的编程习惯,本教程并非强制你形成某种风格。自始至终,本教程中你会看到某些命令的替代品,随着本教程的学习,请集中精力在提炼和形成你自己的编程风格,不要让微小的错误影响你。</p><p>如果你对于Xcode不是很熟悉,建议先学习下面两篇教程。(<a href="http://www.raywenderlich.com/38557/learn-to-code-ios-apps-1-welcome-to-programming" target="_blank">教程1</a>和<a href="http://www.raywenderlich.com/1797/ios-tutorial-how-to-create-a-simple-iphone-app-part-1" target="_blank">教程2</a>)</p><p>下载 <a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/05/CardTilt-starter.zip" target="_blank">CardTilt-starter</a>,然后就可以愉快地写代码了。</p><h3>日常Xcode任务</h3><p>有一些在Xcode中你经常使用的技巧,这一部分让你更近距离的接触这些技巧,然后讲解一些潇洒应对它们的一些妙招。在这个过程中,你会在这些妙招的基础上发现使用它们的新方法。这些技巧将成为你编程工具腰带上的忍者之星。在Xcode中打开之前下载好的工程CardTilt,先不要急着去看代码,先将你Xcode的窗口和下图来一一对应。</p><img class="lazyload" data-src="http://ww1.sinaimg.cn/large/ba81ca29gw1evcbnfyp6vj20jg0cydi3.jpg"/><p>是不是发现你的窗口和图中并不对应,先别着急。在下面介绍的快捷键部分,你将会学到如何轻松地显示以及隐藏这些对应的窗口。</p><p>下面是组成窗口的每一个独立区域的快速浏览:</p><ul><li>The Toolbar(工具栏): 你选择视图,运行app,在不同布局界面切换的地方</li><li>The Navigation Area(导航区): 导航你整个工程,警告,报错等的地方</li><li>The Editing Area(编辑区): 所有奇迹诞生的地方,包括它上方的Jump bar</li><li>The Utility Area(工具区): 包含检测器和一些库</li><li>The Debugging Area(调试区): 包括调试窗口和变量检测器</li></ul><p>上面列出的所有视图区域都是Xcode的必要组成部分,它们也是在你开发过程中可能需要用到的,开发过程中通常不需要将他们一次性同时显示出来,下面将介绍一些快捷键,将会教你快速显示/隐藏这些视图区域。</p><h3>快捷键</h3><p>在这一部分,你将首先学到怎么掌握这些快捷键,得益于一些模式,最有效的快捷键非常容易记。</p><p>第一个需要知道的是Xcode的各区域与修饰键的关系,下面是一个快速浏览</p><ul><li>Command (⌘):用来导航,控制导航区域</li><li>Alt (⎇): 控制右边的一些东西,比如Assistant Editor,utility editor</li><li>Control: 编辑区域上的Jump bar的一些交互</li></ul><p>第二个需要知道的时数字键和标签栏的关系,将数字键和上面提到的修饰键组合可以在标签页之间来回切换。通常数字键对应标签页的索引位置(从1开始),0通常用来显示/隐藏区域。它还能再直观一点吗?</p><p>下面是最常用的组合键:</p><ul><li>Command 1~ 8: 跳转到导航区的不同位置</li><li>Command 0 :显示/隐藏导航区</li><li>Command Alt 1~ 6:在不同检测器之间跳转</li><li>Command Alt 0: 显示/关闭工具区.</li><li>Control Command Alt 1~4: 在不同库之间跳转</li><li>Control 1~ 6: 在Jump bar的不同标签页的跳转。</li></ul><img class="lazyload" data-src="http://ww2.sinaimg.cn/large/ba81ca29gw1evcbo88ow9j20jg0cywfq.jpg"/><p>最后也是最简单的就是回车键,当它和Command组合使用时,可以是你在Xcode中不同编辑器来回切换.</p><ul><li>Command + Enter: 显示标准单窗口编辑器</li><li>Command Alt Enter:你可以猜下它的作用,它的功能是打开Assistant editor</li><li>Command Alt Shift Enter: 打开版本控制编辑器</li></ul><p>同样重要的是显示/隐藏调试区的快捷键是 Command + Shift + Y,要记住这个你可以通过这句话来记忆“Y is my code not working?”(译者注:Y谐音Why)。如果你忘记了一些快捷键,你可以在Xcode的菜单栏Navigate一项中找到大部分快捷键。在即将完成这一部分的学习之时,你会惊奇的发现你仅仅只是用了键盘就让Xcode发生这各种变换。</p><img class="lazyload" data-src="http://ww4.sinaimg.cn/large/ba81ca29gw1evcbox6qvog20jg0cdtjr.gif"/><h3>Xcode的行为</h3><p>使用快捷键来管理Xcode的界面却是挺棒,有没有想过更棒的事情?比如让Xcode自动转换到你想看到的界面。接下来我们将学到更酷的东西。</p><p>幸运的是,Xcode提供的Behaviors(行为)可以让你轻易地实现上面的事情。它们是一组定义好的有指定事件触发的动作,比如build一个工程。这里的动作的范围从改变界面到运行一个自定义脚本文件。来看一个例子,快速修改下载好的工程的CTAppDelegate.m文件,使其运行时会生成调试窗口输出,用下面的方法替代didFinishLaunchingWithOptions方法</p><pre data-language="undefined" class="hljs"><code>
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    [[UIApplication sharedApplication] setStatusBarHidden:YES];
    // Override point for customization after application launch.
    NSLog(@"Show me some output!");
    return YES;
}
</code></pre><p>运行程序,然后仔细观察调试区,你会发现调试区随着app运行而出现,如下所示</p><img class="lazyload" data-src="http://ww3.sinaimg.cn/large/ba81ca29gw1evcbphsi0bg20ko0cge81.gif"/><p>来看看是什么定义了上面的事件,在Xcode-&gt;Behaviors-&gt;Edit Behaviors打开Behavior偏好设置,在左侧你将看到所有事件集合,在右边是该事件可以触发的一些列动作。点击Running栏下的Generates output,然后发现它被设置成用来显示调试区。</p><img class="lazyload" data-src="http://ww4.sinaimg.cn/large/ba81ca29gw1evccgo1totj20ix0dw41j.jpg"/><h4>一些推荐的行为</h4><p>根据你的开发环境,我推荐的两种不同的Generates output事件触发动作集。如果你有多个屏幕,试着使用第一种,如果是单显示器,试着调到第二种方法。</p><h5>方法一</h5><p>如果你在两个或者多个屏幕上开发,把调试区放到第二屏幕是不是更加方便,你可以向下面这样设置</p><img class="lazyload" data-src="http://ww3.sinaimg.cn/large/ba81ca29gw1evccho04c6j20ix0dw779.jpg"/><p>现在,运行程序,然后你会看到一个分离的窗口出现,将它放到你的第二屏幕上,是不是效率高了不少?</p><h5>方法二</h5><p>如果是单屏,通过隐藏工具板以及设置输出窗口占据整个调试区使输出窗口的有效区域最大化,设置如下</p><img class="lazyload" data-src="http://ww2.sinaimg.cn/large/ba81ca29gw1evcbqrikydj20ix0dw779.jpg"/><p>然后运行程序,然后观察Xcode,看它是不是按照你的命令在执行。</p><img class="lazyload" data-src="http://ww1.sinaimg.cn/large/ba81ca29gw1evcbregci2g20ko0cgb29.gif"/><p>当程序暂停的时候,你可能也想改变Xcode的行为,到Running栏下的Pauses事件,然后改变其设置,向下面这样:</p><img class="lazyload" data-src="http://ww2.sinaimg.cn/large/ba81ca29gw1evcbrx8dbgj20i20dwacl.jpg"/><p>现在无论何时你设置了断点,你将会得到一个新的名为fix的展示变量和输出窗口的标签页,然后自动导航到第一个issue。</p><p>你将要创建的最后一个行为是我个人最喜欢的一个,它是一个自定义行为—设置一个快捷键。当被触发的时候,它使Xcode转变到我指定的为下一次开发而优化的布局,名为Dev Mode。我们可以通过点击Behavior偏好设置的左下角的+,然后将其取名为Dev Mode,双击Dev Mode右边的Command (⌘)符号然后输入Command .来定义一个快捷键</p><img class="lazyload" data-src="http://ww2.sinaimg.cn/large/ba81ca29gw1evcbsaehung206n01pt8s.gif"/><p>接下来为该事件设置相应动作:</p><img class="lazyload" data-src="http://ww3.sinaimg.cn/large/ba81ca29gw1evcbsoiwkdj20i20dwaci.jpg"/><p>现在,只要你按下command .就会触发上面设置的动作,即出现一个相同的整洁的开发界面。</p><p>下面将介绍Xcode tab name,和行为配合起来使用堪称完美。</p><p>Xcode Tab Names(Xcode标签名):可以通过双击标签页的标题来修改标签页的名称,对于它本身来说是一个无用的功能,但是当它和行为结合起来使用时就变得非常强大了。 在上面的第二个例子中,当改变Pauses行为时,命名了一个叫fix的标签页,这就意味着当行为被触发时,Xcode将会使用fix标签页(如果存在),如果不存在,它会新建一个名为fix的标签页。 另一个例子就是多屏Starts行为,如果一个名为Debug的标签页在之前运行时被打开,它将会复用这个标签页而不是重新创建一个。 用这种方式,你可以创建非常有趣的行为。</p><p>到现在为止,我们可以花点时间来回顾一下刚才的行为,不要着急,本教程会等着你。</p><h3>小测验</h3><p>在接下来的部分,你将在测验中用到上面所学到的技巧,然后在CardTilt项目中学到一些新的技巧。</p><p>运行CardTilt项目中，你看到如下画面</p><img class="lazyload" data-src="http://ww3.sinaimg.cn/large/ba81ca29gw1evcbt784ipj20c20jkjtx.jpg"/><p>它不是你期待看到的画面？是时候消灭这些bug了！</p><h4>锁定bug</h4><p>app似乎在加载数据时出现了问题，你的任务就是消灭它们。打开CTMainViewController.m文件然后进入开发模式Dev Mode，快捷键为之前设置的command。注意viewDidload方法中的前几行</p><pre data-language="undefined" class="hljs"><code>
self.dataSource = [[CTTableViewDataSource alloc] init];
self.view.dataSource = self.dataSource;
self.view.delegate = self;
</code></pre><p>看起来CTTableViewDataSource实现了UITableViewDataSource协议，为tableview提供了数据。是时候展现你Xcode的技术了，按住command键，同时点击CTTableViewDataSource在编辑器中来打开CTTableViewDataSource.h。CTTableViewDataSource.m应该已经在你的Assistant Editor，如果不是这样的话，打开顶部的Jump Bar，像下图一一样切换到Assistant Editor的counterparts模式。</p><img class="lazyload" data-src="http://ww2.sinaimg.cn/large/ba81ca29gw1evcbtr4c4aj20cd0cn76b.jpg"/><p>翻看代码，你会发现数组members装载数据，loadData方法从bundle中加载数据至数组members。在assistant editor右边任意位置鼠标右击，选择Open in Primary Editor，就会在Primary Editor中打开CTTableViewDataSource.m文件，下面动画是该步骤的展示：</p><img class="lazyload" data-src="http://ww2.sinaimg.cn/large/ba81ca29gw1evcbtr4c4aj20cd0cn76b.jpg"/><p>为了看起来更酷炫，你可以在不用鼠标的情况下完成上面的所有事情，步骤如下：</p><ul><li>1.同时按住Command + Shift + O，在输入框中输入CTMainViewController.m，然后回车来打开该文件。</li><li>2.Command + . 进入Enter Dev模式 。</li><li>3.将鼠标放在 CTTableViewDataSource 上，然后按住Command + Control + J，跳转至CTTableViewDataSource定义处。</li><li>4.按住 Command + J, -&gt; 然后按下回车，来转换 assistant editor 的焦点</li><li>5.按住 ctrl +4 来下拉 Jump Bar，然后使用方向键和回车键来选择 counterparts</li><li>6.按住 Command + Alt，在 primary editor 中打开 CTTableViewDataSource.m 文件</li><li>7.上面的结果步骤看起来不呢么高效，但是它让你看起来很酷。</li></ul><h4>修复bug</h4><p>在self.members = json[@"Team"];打上断点来确定数据是否都被装载到数组members当中，然后运行程序。</p><p>如果对于基本的设置断点和调试不太熟悉，可以先看看<a href="http://www.raywenderlich.com/video-tutorials" target="_blank">这篇教程</a>。</p><p>就像你之前在Xcode行为看到的一样，Generates output将首先被触发，紧接着Pause行为被触发。因为你之前在Pause有过自定义设置，所以Xcode会新建一个名为fix的标签页，它专为调试而设。</p><p>将目光切换到变量检测器variable inspector，你会发现数组members是nil，在loadData方法数组members被填充，代码如下</p><pre data-language="undefined" class="hljs"><code>
NSDictionary *json = [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:&error];
self.members = json[@"Team"];

</code></pre><p>在变量检测器中查看json，看其是否被正确加载，你会发现数据中的第一个值是@"RWTeam"而不是@"Team"，当加载数组members时，这个值是错的，找到了一个bug。</p><p>让我们按下面步骤来修复这个bug：</p><ul><li>使用command + .来进入开发模式</li><li>按住Command + Option + J跳至filter bar然后输入teammember</li><li>然后按住Alt同时点击TeamMembers.json在assistant editor来打开它</li><li>最后，使用"Team"来替换"RWTeam"</li></ul><p>下图是上面四步的一个动画</p><img class="lazyload" data-src="http://ww2.sinaimg.cn/large/ba81ca29gw1evcbuh3yqrg20jg0bcu0y.gif"/><p>现在移除断点，然后运行程序，它看起来应该像这个样子。</p><img class="lazyload" data-src="http://ww4.sinaimg.cn/large/ba81ca29gw1evcbv2p9w1j20c20jkq5c.jpg"/><p>是不是看起来比之前要好一点了，但是还是有一些bug，比如Ray和Brian的标题描述栏不见了。接下来我们通过修复这些bug来学到更多酷炫的技巧。</p><h3>加速</h3><p>你应该已经知道<code>UITableViewCells在tableView:cellForRowAtIndexPath:</code>方法中被加载，所以用Open Quickly来导航到该方法，然后按照下面步骤：</p><ul><li>按下Command + Shift + O来呼出Open Quickly</li><li>输入cellForRow</li><li>按下回车来打开它</li></ul><p>按住command然后点击setupWithDictionary来跳转至其定义处，然后你会发现一些用来加载描述的代码</p><pre data-language="undefined" class="hljs"><code>
NSString *aboutText = dictionary[@"about"]; // Should this be aboot?
 self.aboutLabel.text = [aboutText stringByReplacingOccurrencesOfString:@"\\n" withString:@"\n"];
</code></pre><p>它使用dictionary[@"about"]中的数据来加载label。</p><p>接下来呼出Open Quickly，然后打开TeamMembers.json，使用alt + command在Assistant Editor中打开。检查about的值，然后你会发现有人将about拼写成了aboot，我们可以使用全局的Find and Replace来修复这个bug。当然你可以在文件中直接做这件事，但是使用find navigate看起来更酷。打开find navigate，然后通过顶部的jump bar切换到替换(replace)模式，输入aboot,然后回车。</p><img class="lazyload" data-src="http://ww4.sinaimg.cn/large/ba81ca29gw1evcbvqwkkyj20c20jkq5c.jpg"/><p>在TeamMembers.json文件之外还有一个地方使用到了aboot，别担心，选中CTCardCell.m的搜索结果，然后按下Delete，将鼠标移至replace filed，然后输入about，点击Replace All，一切完成。整个过程看起来是这个样子的：</p><img class="lazyload" data-src="http://ww1.sinaimg.cn/large/ba81ca29gw1evcbxo000lg20jg0bc1l2.gif"/><p>进阶技巧:使用 Command + Shift + Option + F 来打开 Find navigator 的替换模式，如果你嫌麻烦，也可以使用 Command + Shift + F 来打开 Find navigator 的查找模式，如果你还嫌麻烦，使用 command + 3 来打开 Find navigator，然后开启查找或者替换模式，选择一种最适合自己的方式就好。</p><p>运行程序，看起来是这样的</p><img class="lazyload" data-src="http://ww4.sinaimg.cn/large/ba81ca29gw1evcbymqx48j20ah0hs76r.jpg"/><h3>让设计师高兴</h3><p>今天的调试任务到此就结束了，给自己一点掌声，然后开始运行程序。在你将它展示给别人之前，需要先确定app的界面是完美的。尤其当这个人是非常认真的设计师的时候，这一部分教你一些关于interface builder的技巧，让你变得更酷。</p><p>打开Mainstoryboard.storyboard，通常你想在打开interface builder的同时打开standard editor和工具区(utilities area)，所以我们可以自定义一个新的叫做IB Mode的行为，当你在看下面的自定义发放之前，试着自己创建一个然后自定义，不必要完全一致。</p><img class="lazyload" data-src="http://ww4.sinaimg.cn/large/ba81ca29gw1evcbz07ee7j20gj0cewgq.jpg"/><p>我将这个模式的快捷键设置为Command Option .，现在你将看到一个舒服的Interface Builder界面，看看CTCardCell。首先你想让mainView处于ContentView的正中央。有两种技巧可以完成这个需求：</p><ul><li>按住Control + Shift，然后在mainView的任意位置鼠标左击，你将看到一个弹出视图让你选择在光标下的所有视图，如下图所示：</li></ul><img class="lazyload" data-src="http://ww2.sinaimg.cn/large/ba81ca29gw1evcbzzrf1dj205i0980t5.jpg"/><p>这个方法让你轻松的就能选中mainView，尽管cardbg遮住了它。选中mainView之后，按住Alt然后在ContentView的边缘移动鼠标，来看它们之间的间隔。下面是这个过程的一个动画：</p><img class="lazyload" data-src="http://ww4.sinaimg.cn/large/ba81ca29gw1evcc0nbf2vg20jg0avtcl.gif"/><p>原来对其并不是那么优雅，看起来也不是很酷。为了解决这个，我们可以调整视图的大小。点击Editor-&gt;Canvas-&gt;Live Autoresizing来使子视图在父视图尺寸改变的时候强制调整大小。按住Alt同时拖拽mainView的一角，直到每边的距离为15.</p><p>拖拽是像素点级别的技巧，你可以尝试不同的调整的处理方法，就像下面动画一样。在很多情况下，更倾向于使用Size Inspector来调整复杂的布局，而非用鼠标来拖拽。</p><img class="lazyload" data-src="/images/blogimg/Xcode/SC4-IB21.gif"/><p>试着使用相同的技巧来对齐titleLabel、locationLabel、aboutLabel,让他们竖直方向上的间隔为0。按住Alt来查看鼠标移动时，三个label之间的间隔。有发现三个label的左边缘并没有对齐吗？设计师肯定想让nameLabel和webLabel靠左对齐。使用Vertical Guide可以昂我们轻松完成这个任务。选中cardbg，然后点击菜单栏的Editor-&gt;Add Vertical Guide，这个步骤的快捷键是Command |，horizontal guide的快捷键是Command -，这两个快捷键是最可视化的。当视图上有了vertical guide之后，将其从cardbg的左边缘拖10个点。然后所有视图将会紧贴vertical guide，对的非常整齐，继续为其他的label进行对其操作。</p><p>Xcode并不那么完美，有时候可能在你创建guideline的时候出现一些问题，可以打开其他文件然后再切回到storyboard页面，然后storyboard会被重新加载，这个时候问题一般会自动解决。 让你更酷的建议：所有的视图能紧贴在guideline上才是最好的，guideline没有必要在同一个层级。</p><p>下图是上面对齐过程的一个回放：</p><img class="lazyload" data-src="http://ww4.sinaimg.cn/large/ba81ca29gw1evcc0nbf2vg20jg0avtcl.gif"/><p>我敢打赌你现在迫不及待的想把你做的展示给你的设计师看！</p><h3>提升和超越</h3><p>上面的步骤让你得到了一个实用的app，同时让你的设计师也感到很满意，那么接下来我们要做的就是让代码变得更为简洁。</p><p>快速打开(Command + Shift + O)CTCardCell.m，记得进入Dev Mode(Command .)，你应该不会忘了这些快捷键吧。</p><p>看下CTCardCell.m顶部凌乱的属性列表</p><pre data-language="undefined" class="hljs"><code>
@property (weak, nonatomic) IBOutlet UILabel *locationLabel;
@property (strong, nonatomic) NSString *website;
@property (weak, nonatomic) IBOutlet UIButton *fbButton;
@property (weak, nonatomic) IBOutlet UIImageView *fbImage;
@property (strong, nonatomic) NSString *twitter;
@property (weak, nonatomic) IBOutlet UIButton *twButton;
@property (weak, nonatomic) IBOutlet UILabel *webLabel;
@property (weak, nonatomic) IBOutlet UIImageView *profilePhoto;
@property (strong, nonatomic) NSString *facebook;
@property (weak, nonatomic) IBOutlet UIImageView *twImage;
@property (weak, nonatomic) IBOutlet UILabel *aboutLabel;
@property (weak, nonatomic) IBOutlet UIButton *webButton;
@property (weak, nonatomic) IBOutlet UILabel *nameLabel;
@property (weak, nonatomic) IBOutlet UILabel *titleLabel;
</code></pre><p>在这部分，你将创建一个自定义服务以执行脚本命令来实现属性的快速整齐地排列。</p><p>如果对于这些脚本命令还不熟悉，它们是相当好理解的。排序(sort)是按照字母顺序来的，uniq是会删除所有重复的行数。uniq在这里可能派不上用场，但是用它来管理#import，那是极好的。</p><p>Mac OS X允许你创建整个操作系统全局通用的服务，你将用它来创建一个用在Xcode中的脚本服务，按如下步骤来设置</p><p>使用Spotlight来搜索Automator，并打开它 然后点击File-&gt;New，并选择服务(service)一项 在Actions筛选栏，输入shell，然后双击运行shell脚本Run Shell Script 在新添加的服务的菜单栏上,检查Output replaces selected text 将脚本内容切换至sort | uniq 同时按下command s，将服务保存为 Sort &amp; Uniq 最终的窗口看起来是这个样子：</p><img class="lazyload" data-src="http://ww2.sinaimg.cn/large/ba81ca29gw1evcc32vbs0j20o70icjv5.jpg"/><p>切回到Xcode，然后选中CTCardCell.m中的那片混乱的属性区域，右击，选择Services -&gt; Sort &amp; Uniq，然后观察执行之后代码是多么的整洁。你可以看下面的一个示意图：</p><img class="lazyload" data-src="http://ww2.sinaimg.cn/large/ba81ca29gw1evccbende3g20jg0avgrn.gif"/><h3>代码片段</h3><p>进行到这里，意味着那些基本的可以让你看起来酷酷的调试任务已经告一段落了，接下来我希望你觉得更酷。你可定想学更多技巧，幸运的是，这是最后分享的一个技巧。</p><p>你之前可能已经使用过Xcode的代码片段(Code Snippets)功能了，一些常见的是for in片段和dispatch_after片段。在这一部分，你将学会如何创建自定义的代码片段，当你重用这些代码片段时，看起来非常棒。你将创建的是获取单例的代码片段。</p><p>如果你不熟悉单例模式，可以看看这个教程。</p><p>下面可能是你使用单例模式的常用代码模板</p><pre data-language="undefined" class="hljs"><code>
+ (instancetype)sharedObject {
  static id _sharedInstance = nil;
  static dispatch_once_t oncePredicate;
  dispatch_once(&oncePredicate, ^{
    _sharedInstance = [[self alloc] init];
  });
  return _sharedInstance;
}
</code></pre><p>非常酷的是这份片段也包含了dispatch_oncep片段。</p><p>在工程CardTilt创建一个名为继承自NSObject名为SingletonObject的新类，你不需要为它做任何事，除了作为拖拽代码片段的一个地方。</p><p>按下面步骤：</p><ul><li>在@implementation 的下一行粘贴上面的代码到SingletonObject.m</li><li>用快捷键Command Option Control 2来打开代码片段库，在代码片段库中你会看到默认的包含在Xcode中的代码片段库。</li><li>选中整个+sharedObject方法，将其拖拽到代码片段库中。 看起来是这样的：</li></ul><img class="lazyload" data-src="http://ww4.sinaimg.cn/large/ba81ca29gw1evcc9d8yleg20q60fm7b5.gif"/><p>新创建的代码片段将会在代码片段库的最底部，你可以将其拖拽到任何你想拖拽的文件当中去，让我们来尝试一下。</p><p>双击刚刚新建的代码片段，然后点击edit.弹出的视图非常使用，实际上它们都很重要，所以做个简短的解释。</p><ul><li>Title and Summary：代码片段库中该代码片段的名字和简述</li><li>Platform and Language:代码片段匹配的平台和编程语言</li><li>Completion Shortcut:在Xcode中输入的快捷键</li><li>Completion Scopes:代码片段作用的范围，这对于保持代码片段库整洁来说十极好的。 向下面一样填充里面的属性：</li></ul><img class="lazyload" data-src="http://ww1.sinaimg.cn/large/ba81ca29gw1evcc9ud0gbj20bn07z75y.jpg"/><h4>令牌</h4><p>当你加入令牌时，代码片段将会变得非常强大，因为它允许你在片段中标记代码，而不需要硬编码。通过使用Tab键使得他们非常容易修改，就像自动补全一样。</p><p>在片段中仅仅只要输入<#TokenName#>就可以添加一个令牌，创建一个令牌使用 shared<#ObjectName#>替代 sharedObject，看起来像这样：

![](http://ww2.sinaimg.cn/large/ba81ca29gw1evccacwhcvj20bm080t9s.jpg)

点击 Done 来保存该片段，然后来用用它。

在 SingletonObject.m 文件中输入 singleton accessor，然后当它出现的时候使用自动补全

![](http://ww4.sinaimg.cn/large/ba81ca29gw1evccaulztkg20b108ydh0.gif)

对于经常使用的代码来说，创建一个代码片段是非常实用的。

### 何去何从

总结一下在这个教程中你所学到的东西：

- 使用快捷键来改变 Xcode 的布局
- 使用自定义的行为来改变 Xcode 的布局
- 使用 assistant editor
- 在 Xcode 中快速打开某文件
- 在 Find navigator 删除搜索到的结果
- 在 Interface Builder 使用快捷键和 guideline 来对齐视图
- 创建一个在 Xcode 中使用的服务
- 创建并使用自定义的代码片段
- 最重要的是你知道怎么去成为一名 Xcode 大师

上面列出来的内容都很简单对吧？在你的朋友面前展示这些炫酷的技巧，你的朋友一定会惊呆也会理解你的兴奋。还有很多方法可以提高你的 Xcode 的效率，比如：

[使用 Doxygen 风格的注释](http://www.raywenderlich.com/66395/documenting-in-xcode-with-headerdoc-tutorial)

[使用 Xcode 插件](http://nshipster.com/xcode-plugins/)

下一步就是去寻找新的酷炫的技巧，我希望你能享受整个教程的学习过程，如果你有任何问题、评论、或者想分享你所知道的炫酷技巧，请在下面评论中指出。

</p>]]></content><tag>Xcode</tag><tag>翻译</tag></entry><entry><title>AVFoundation和 GPUImage初探</title><link href="/posts/AVFoundation-And-GPUImage"/><url>/posts/AVFoundation-And-GPUImage</url><content type="html"><![CDATA[<p>最近在做视频相关的东西，然后熟悉了一下AVFoundation框架，以及强大的开源库GPUImage。在这里记录这个过程中遇到的一些问题，以及解决的方法。</p><h3>AVFoundation的一些基本概念</h3><p>根据苹果的官方文档，AVFoundation是用来播放和创建实时的视听媒体数据的框架，同时提供Objective-C接口来操作这些视听数据，比如编辑，旋转，重编码。本文着重讲的是视频的录制和编辑和GPUImage的一些简单使用，其他的都是一笔带过。来看下苹果文档的一个框架图。</p><img class="lazyload" data-src="/oldimages/2019-11-21-15743465315046.jpg"/><h4>相关类</h4><ul><li><code>AVAsset</code></li><li><code>AVAssetTrack</code></li><li><code>AVComposition</code></li><li><code>AVVideoComposition</code></li><li><code>AVAudioMix</code></li><li><code>AVMutableAudioMixInputParameter</code></li><li><code>AVMutableVideoCompositionInstrution</code></li><li><code>AVMutableVideoCompositionLayerInstrution</code></li></ul><p>简单的播放可以使用MPMoviePlayerController或者MPMovieViewController就行,简单的录 制可以直接使用UIImagePickerController。同样简单的声音播放直接使用AVAudioPlayer，简单的录制直接使用AVAduioRecorder。如果你想要有更多的操作，可使用各种复杂的方式来控制播放，比如在同一时刻为同一个asset的不同片段使用不同的分辨率渲染，playitem来管理asset的呈现状态和方式,playitemtrack管理asset中的轨道（track）状态。</p><p>在AVFoudation框架中最核心的类就是AVAsset，他是由一系列的媒体数据组成的，包括但不限于:时间、大小(size)、标题、字幕等。其中每一个单独的媒体数据称为轨道(track)。同样剪辑操作中，AVMutableComposition是一个核心类。</p><img class="lazyload" data-src="/oldimages/2019-11-21-15743465478505.jpg"/><p>这里又一个重要的东西就是CMTime,它是一个结构体，定义如下:</p><p>typedef struct { CMTimeValue value;<br> CMTimeScale timescale;<br> CMTimeFlags flags;<br> CMTimeEpoch epoch;<br>} CMTime; 通常时间是等于value/timescale的，所以两个有相同时间的CMTime它们的timescale并不一定相同。关于更多CMTime的内容可以看<a href="https://developer.apple.com/library/ios/documentation/CoreMedia/Reference/CMTime/Reference/reference.html#//apple_ref/doc/uid/TP40009748" target="_blank">这里</a>。</p><h3>进阶</h3><h4>视频的录制</h4><p>这里用的是系统原生录制,关于录制通常用到的几个类就是AVCaptureDevice、 AVCaptureSession、AVCaptureDeviceInput、AVCaptureOutput,同样，来看一张图。</p><img class="lazyload" data-src="/oldimages/2019-11-21-15743465626129.jpg"/><p>一般来说，如果你想修改视频的相关信息，如拍摄地点等，可以拿到output的metadata来修改。大致代码如下:</p><pre data-language="ObjectiveC" class="hljs"><code><span class="hljs-built_in">NSMutableArray</span> *array = [output.metadta mutableCopy];
<span class="hljs-built_in">AVMutableMetadataItem</span> *item = [[<span class="hljs-built_in">AVMutableMetadataItem</span> alloc] init];
item.keyspace = ...;
item.key = ...;
item.value = ...;
[array addObject:item];
output.metadata = array;
</code></pre><p>如果录制时候想要得到指定的视频size必须先指定分辨率，像这样</p><pre data-language="undefined" class="hljs"><code>
if ([session canSetSessionPreset:AVCaptureSessionPreset640x480]){ 

    session.sessionPreset = AVCaptureSessionPreset640x480;
}
else {
    //设置失败
}
</code></pre><p>切换摄像头或其他输入源必须在beginConfiguration和commitConfiguration之间来处理，大致是这样</p><pre data-language="undefined" class="hljs"><code>
[session beginConfiguration];
//移除某个输入源
//再添加某个输入源
//再为新添加的输入源进行必要的相关设置
//...其他操作
[session commitConfiguration];
</code></pre><p>如果想对实时视频帧进行相关的渲染操作,通过 setSampleBufferDelegate:queue:方法来为output设置代理，同时必须指定queue，代理方法将会在这些queue上面被调用。可以在自己的类里面实现AVCaptureVideoDataOutput的协议方法,通过实现 captureOutput:didOutputSampleBuffer:fromConnection:来拿到视频的每一帧，默认情况下这些视频帧会被用最有效的格式来输出到output,当然也可以在拍摄之前就为output进行相关设置。</p><pre data-language="undefined" class="hljs"><code>
AVCaptureVideoDataOutput *videoDataOutput = [AVCaptureVideoDataOutput new];
NSDictionary *newSettings =@{ (NSString *)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA) };
videoDataOutput.videoSettings = newSettings;
</code></pre><p>说了这么多，感觉很虚，还是直接上代码，将以上部分衔接起来</p><pre data-language="ObjectiveC" class="hljs"><code><span class="hljs-comment">//自定义方法，小演示只添加了视频，没有添加声音，添加声音类似</span>
- (<span class="hljs-keyword">void</span>)yourCustomMethodName{
    <span class="hljs-built_in">AVCaptureSession</span> *session = [[<span class="hljs-built_in">AVCaptureSession</span> alloc] init];
    <span class="hljs-keyword">if</span> ([session canSetSessionPreset:<span class="hljs-built_in">AVCaptureSessionPreset640x480</span>]){ 

            session.sessionPreset = <span class="hljs-built_in">AVCaptureSessionPreset640x480</span>;
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">//设置失败</span>
        }
    <span class="hljs-built_in">AVCaptureDevice</span> *device =
            [<span class="hljs-built_in">AVCaptureDevice</span> defaultDeviceWithMediaType:<span class="hljs-built_in">AVMediaTypeVideo</span>];

    <span class="hljs-built_in">NSError</span> *error = <span class="hljs-literal">nil</span>;
    <span class="hljs-built_in">AVCaptureDeviceInput</span> *input =
            [<span class="hljs-built_in">AVCaptureDeviceInput</span> deviceInputWithDevice:device error:&amp;error];
    <span class="hljs-keyword">if</span> (!input) {
        <span class="hljs-comment">// Handle the error appropriately.</span>
    }
    <span class="hljs-keyword">if</span>(session canAddInput:input){
        [session addInput:input];
    }
    <span class="hljs-built_in">AVCaptureVideoDataOutput</span> *output = [[<span class="hljs-built_in">AVCaptureVideoDataOutput</span> alloc] init];
    <span class="hljs-keyword">if</span>(session canAddOutput:output){
        [session addOutput:output];
    }
    output.videoSettings =@{ (<span class="hljs-built_in">NSString</span> *)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA) };
    <span class="hljs-comment">//设置帧率(FPS),每秒15帧</span>
    output.minFrameDuration = <span class="hljs-built_in">CMTimeMake</span>(<span class="hljs-number">1</span>, <span class="hljs-number">15</span>);
    <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">"CustomQueue"</span>, <span class="hljs-literal">NULL</span>);
    [output setSampleBufferDelegate:<span class="hljs-keyword">self</span> queue:queue];
    dispatch_release(queue)
    <span class="hljs-built_in">NSString</span> *mediaType = <span class="hljs-built_in">AVMediaTypeVideo</span>;

 <span class="hljs-comment">//用来显示录制的实时画面</span>
    <span class="hljs-built_in">AVCaptureVideoPreviewLayer</span> *captureVideoPreviewLayer = [[<span class="hljs-built_in">AVCaptureVideoPreviewLayer</span> alloc] initWithSession:session];
    [<span class="hljs-keyword">self</span>.view.layer addSublayer:captureVideoPreviewLayer];

    <span class="hljs-comment">//用户是否允许启用摄像头</span>
    [<span class="hljs-built_in">AVCaptureDevice</span> requestAccessForMediaType:mediaType completionHandler:^(<span class="hljs-built_in">BOOL</span> granted) {
        <span class="hljs-keyword">if</span> (granted)
        {
            <span class="hljs-comment">//Granted access to mediaType</span>
            [<span class="hljs-keyword">self</span> setDeviceAuthorized:<span class="hljs-literal">YES</span>];
            [session startRunning];
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">//Not granted access to mediaType</span>
            <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
            [[[<span class="hljs-built_in">UIAlertView</span> alloc] initWithTitle:<span class="hljs-string">@"AVCam!"</span>
                                        message:<span class="hljs-string">@"AVCam doesn't have permission to use Camera, please change privacy settings"</span>
                                       delegate:<span class="hljs-keyword">self</span>
                              cancelButtonTitle:<span class="hljs-string">@"OK"</span>
                              otherButtonTitles:<span class="hljs-literal">nil</span>] show];
                    [<span class="hljs-keyword">self</span> setDeviceAuthorized:<span class="hljs-literal">NO</span>];
            });
        }
    }];
}

<span class="hljs-comment">//协议方法,获取每一帧，将每一帧转换成图片，你也可以进行其他的渲染操作</span>
- (<span class="hljs-keyword">void</span>)captureOutput:(<span class="hljs-built_in">AVCaptureOutput</span> *)captureOutput
         didOutputSampleBuffer:(<span class="hljs-built_in">CMSampleBufferRef</span>)sampleBuffer
         fromConnection:(<span class="hljs-built_in">AVCaptureConnection</span> *)connection {

    <span class="hljs-built_in">UIImage</span> *image = imageFromSampleBuffer(sampleBuffer);
}
</code></pre><p>上面演示了如何取得每一帧实时画面,如果想要直接存成视频可使用AVCaptureMovieFileOutput,如下</p><pre data-language="undefined" class="hljs"><code>
AVCaptureMovieFileOutput *movieFileOutput = [[AVCaptureMovieFileOutput alloc] init];
NSURL *fileURL = ...;    //存放位置
//指定代理
[aMovieFileOutput startRecordingToOutputFileURL:fileURL recordingDelegate:delete];
//也可以为其指定outputSettings
同样代理必须实现协议方法captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error:,
</code></pre><p>当然还有其他各种具体的设置，如对焦、曝光、闪光灯以及白平衡等等均可以通过KVO来设置，每次设置前都加一个判断，是否支持指定模式,在这里不做详细叙述了,这里你可以看到<a href="https://developer.apple.com/library/ios/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/04_MediaCapture.html#//apple_ref/doc/uid/TP40010188-CH5-SW14" target="_blank">更多</a>。</p><h4>视频的剪辑</h4><p>视频的剪辑包括但不限于:裁剪、旋转(改变transform)、添加水印、添加字幕、合并等。关于剪辑，无非就是取出视频中的轨道(视频和音频),然后对轨道进行一系列的操作变可以得到各种想要的效果。首先我们先来看下面一张图</p><img class="lazyload" data-src="/oldimages/2019-11-21-15743465991142.jpg"/><p>AVMutableComposition是整个视频剪辑过程中的一个核心，下面着重讲解这个类。AVMutableComposition和AVAsset一样含有多个视/音频轨道，但是更重要的是，它可以将多个AVAssetTrack合并到一起，比如在视频合并时，可以直接将多段视频拼接到一个轨道(AVMutableCompositonTrcak)，音频也一样。通过借助AVMutableVideoComposition和AVMutableAudioMix来设置每一段的视/音频的属性，从而达到想要的视听效果，比如视频切换处的淡入淡出，声音的渐变，字幕等等。 关于上图的解释:首先通过将asset里面的轨道加载到composition的各轨道，然后通过audioMix和videoComposition对某个轨道进行对应操作,设置其相关属性。其中要用到的具体方法可以参见<a href="https://developer.apple.com/library/ios/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/03_Editing.html#//apple_ref/doc/uid/TP40010188-CH8-SW1" target="_blank">这里</a>。</p><p>其中图中1，2，3用到的方法为</p><pre data-language="undefined" class="hljs"><code>
[1]
[mutableComposition addMutableTrackWithMediaType:AVMediaTypeVideo preferredTrackID:kCMPersistentTrackID_Invalid]
[2]
[AVMutableAudioMixInputParameters audioMixInputParametersWithTrack:mutableCompositionAudioTrack];`
[3]
[AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:mutableCompositionVideoTrack]
</code></pre><p>关于视频的剪辑的代码可以参见苹果给出的官方<a href="https://developer.apple.com/library/ios/samplecode/AVSimpleEditoriOS/Introduction/Intro.html#//apple_ref/doc/uid/DTS40012797" target="_blank">Demo</a>以及Raywendrich上的两篇文章<a href="http://www.raywenderlich.com/13418/how-to-play-record-edit-videos-in-ios" target="_blank">1</a>,<a href="http://www.raywenderlich.com/30200/avfoundation-tutorial-adding-overlays-and-animations-to-videos" target="_blank">2</a>。</p><h3>GPUImage</h3><p>什么?!你没听说过GPUImage?!那你赶紧去看看它的<a href="https://github.com/BradLarson/GPUImage/blob/master/README.md#overview" target="_blank">相关介绍</a>。GPUImage是一个基于OpenGL ES的一个强大的图像/视频处理库,封装好了各种滤镜同时也可以编写自定义的滤镜。至于他到底是如何强大,用了就知道。在这篇文章不是为了介绍它，而是列出一些我在使用过程中遇到的问题和解决方法。</p><h4>分段录制</h4><p>在使用GPUImageVideoCamera来录制的时候,可能需要分段录制,在GPUImage给出的视频录制Demo中直接只是录制一次，然而有时候需求可能是要录制多次，如果此时按照Demo的方法每次录制都要创建一个movieWriter,这样子的话每次都会在重新创建movieWriter并将它设置为videoCamera的audioEncodingTarget时候，界面都会卡顿一下，这是什么原因呢？因为videoCamera默认是不录制声音的，而每次创建movieWriter的时候都用到了movieWriter.hasAudioTrack = YES;,吊用这个之后videoCamera会自动去添加声音输入源,准备一些数据，所以这个过程会导致界面卡顿一下？这该怎么办呢？如果你有进到videoCamera的头文件去看的话你会发现这么一个方法和它的注释</p><pre data-language="undefined" class="hljs"><code>
//Add audio capture to the session. Adding inputs and outputs freezes 
//the capture session momentarily, so you can use this method to add 
//the audio inputs and outputs early, if you’re going to set the 
//audioEncodingTarget later. Returns YES is the audio inputs and 
//outputs were added, or NO if they had already been added.

-(BOOL)addAudioInputsAndOutputs;
</code></pre><p>注释的大意是:录制的时候添加声音,添加输入源和输出源会暂时会使录制暂时卡住,所以在要使用声音的情况下要先调用该方法来防止录制被卡住。这不刚好就解决了上面的这个问题吗？所以问题就迎刃而解了,因为没看到这个,走了不少弯路,浪费了好长时间。</p><p>关于分段录制,可能有这么一个需求就是所有片段都是存于一个文件中而不是录制完成后将各段合并到一个视频文件中。这两个东西或许会帮到你<a href="http://blog.csdn.net/whf727/article/details/18702643" target="_blank">分段录制的实现</a>,<a href="https://github.com/leanlyne/GPUImageExtend" target="_blank">GPUImageExtend</a>。前者是基于系统的分段录制的实现,后者是GPUImageMoiveWriter的一个子类。</p><h4>所见即所得</h4><p>在录制的时候,使用GPUImageView来显示,因为给GPUImageView设置的大小是320*320的,如果不设置它的填充模式(fillMode)它是默认使用kGPUImageFillModePreserveAspectRatio即保持长宽比,其余空白处使用背景色填充,如果要设置成方形就得使用kGPUImageFillModePreserveAspectRatioAndFill,但是这个时候问题又来了假设你是用的录制分辨率是960x540,显示的画面则只会显示中间的540x540的画面,这个时候如果movieWriter的size设置为540x540,则最后保存的视频是失真的因为960被压到了540，整个画面变扁了。这个时候有两种解决方案</p><ul><li>1.使用GPUImageCropFilter,通过设置其cropRegion来裁出中间540x540部分。关于cropRegion要注意它是一个CGRect,它对坐标系做了一个归一化处理,所以让所有的取值都在0.0~1.0范围内,比如960x540裁剪至中间540x540部分则cropRegion为(0,((960-540)/2)/960,1,540/960)</li><li>2.改变videoComposition的perferTransfom使其只显示中间的540x540。 这样就完成了所见即所得。</li></ul><p>关于GPUImage的实时滤镜添加或给已存在的视频添加滤镜,Demo都给出了详细过程,依葫芦画瓢即可。有一点要注意的是,在一些操作完成的时候注意removeTarget,还有就是在使用movieFile来播放已存在视频并添加滤镜的时候是没有声音的,这是这个库的一个缺陷,Github上有人提了这个<a href="https://github.com/BradLarson/GPUImage/issues/458" target="_blank">issue</a>和<a href="https://gist.github.com/pgodino/3819907" target="_blank">一些解决办法</a>。同时在用movieFile处理视频的时候在切换滤镜的时候最好先cancelProcessing不然会有黑屏或卡顿现象出现。同样如果你是用老版本的GPUImage的时候,可能会遇到第一帧是红色的现象,有人提出这个issue后,作者修复了这个bug,切换到最新版的时候就不会有这种情况发生。发生这种情况的原因是视频掉帧,导致音频和视频不同步。</p><h3>总结</h3><p>AVFoundation还是有很多东西去做深层次的挖掘,GPUImage也是一样,有了这个强大的库,解决一些事情节省了大量时间。这次仅仅是一个小小的尝试,对于很多东西都是浅尝则止,文中难免会有错误,欢迎在评论中指正。如果你在使用GPUImage和AVFoundation有什么好的心得或者对一些问题有相应的解决方案,不妨在评论中分享一下。</p>]]></content><tag>AVFoundation</tag><tag>GPUImage</tag><tag>原创</tag></entry><entry><title>如何创建一个类似 Tinder 的交互动画[译]</title><link href="/posts/How-We-Built-Tinder-Like-Koloda-Animation-in-Swift-Chinese-Translation"/><url>/posts/How-We-Built-Tinder-Like-Koloda-Animation-in-Swift-Chinese-Translation</url><content type="html"><![CDATA[<p>有时候我认为 Tinder 不仅仅让人们遇见彼此，更多的是它引领了一种交互设计趋势。所以我们非常肯定地说 Tinder 已经完成了他的历史使命，可以安心等待着下一个 Tinder 出现。</p><p>原文:<a href="https://yalantis.com/blog/how-we-built-tinder-like-koloda-in-swift/" target="_blank">How We Built Tinder-Like Koloda Animation in Swift</a></p><p>Tinder 的右滑喜欢，左滑忽略不仅仅在约会（pao）应用中很流行，在购物 App 中也很流行，比如<a href="https://fancy.com/about" target="_blank">Fancy</a>，也是像 Tinder 一样是滑动喜欢的形式。他们之所以才用这种交互形式是因为这种卡片式的交互确实深得用户欢心。卡片上的内容吸引了用户的注意力促使他们去进行一系列操作，进而提高了用户参与度。 还有许多不同种类 App 也是用这种像 Tinder 一样的卡片式滑动交互的例子，比如<a href="https://liveuptop.com/" target="_blank">Uptop</a>，就连谷歌浏览器 iOS 客户端也是用这种卡片形式来管理书签。</p><img class="lazyload" data-src="/oldimages/content_1__1_.gif"/><p>我们把卡片式布局以及基于滑动的交互作为今年的交互设计趋势，我们的<a href="https://yalantis.com/blog/7-up-to-date-mobile-app-design-trends-2015/" target="_blank">这篇文章</a>有相关介绍。之后我们的设计师Dmitry Goncharov创建了一个类似 Tinder 交互的动画，实际上他是故意这么做的。 我们把我们的这种类似 Tinder 基于卡片式的动画命名为<code>Koloda</code>，在乌克兰语中它的意思是甲板（卡片），听起来非常有趣。这个组件能够被不同 app 使用，如果加上约会（pao）地点的话，甚至在 Tinder 中也很实用。Dmitriy提出了这个概念，我们的iOS工程师实现了这个想法。详见<a href="https://github.com/Yalantis/Koloda" target="_blank">GitHub</a>。（译者注：Objective-C 版详见<a href="https://github.com/wang9262/Koloda-ObjC" target="_blank">这里</a>）。</p><h2>我们如何实现 Koloda 动画</h2><p>&gt;- by Eugene Andreyev</p><p>Tinder的滑动喜欢界面被许多不同的 App 借鉴，也有一些现成的库来给开发者使用。首先，我看了<a href="https://github.com/modocache/MDCSwipeToChoose" target="_blank">MDCSwipeToChoose</a>以及<a href="https://github.com/cwRichardKim/TinderSimpleSwipeCards" target="_blank">TinderSimpleSwipeCards</a>，事实证明，它们并不能完美的实现我的需求。 我想要的动画要非常简单而且方便，就像UITableView 那样由数据源来驱动。因此，我创建了一个自定义组件来构建这个动画。主要分为如下三个部分：</p><ul><li>DraggableCardView：用来展示内容的卡片式图</li></ul><ul><li>OverlayView：遮罩视图，根据用户手势方向（左、右）来动态改变</li><li>KolodaView：用来控制加载和卡片之间的交互的视图 <img class="lazyload" data-src="/oldimages/content_2__1_.gif"/></li></ul><h2>DraggableCardView的实现</h2><p>正如我前面提到的那样，<code>DraggableCardView</code>是用来展示内容的卡片视图。网上有很多教程阐述了 Tinder 滑动动画的原理，我选择了其中一种解决方案，做了一些改动，然后利用<code>UIPanGestureRecognizer</code> 和 <code>CGAffineTransform</code>实现了 <code>DraggableCardView</code>。部分代码如下：</p><pre data-language="objc" class="hljs"><code><span class="hljs-comment">//译者注：原文是用 swift 写的，我索性翻译成了 OC，下同</span>

- (<span class="hljs-keyword">void</span>)panGestureRecognized:(<span class="hljs-built_in">UIPanGestureRecognizer</span> *)pan
{
    <span class="hljs-keyword">self</span>.xDistanceFromCenter = [pan translationInView:<span class="hljs-keyword">self</span>].x;
    <span class="hljs-keyword">self</span>.yDistanceFromCenter = [pan translationInView:<span class="hljs-keyword">self</span>].y;
    <span class="hljs-built_in">CGPoint</span> location = [pan locationInView:<span class="hljs-keyword">self</span>];
    <span class="hljs-keyword">switch</span> (pan.state) {
        <span class="hljs-keyword">case</span> <span class="hljs-built_in">UIGestureRecognizerStateBegan</span>:
        {
            <span class="hljs-keyword">self</span>.originalLocation = <span class="hljs-keyword">self</span>.center;
            <span class="hljs-keyword">self</span>.dragBegin = <span class="hljs-literal">YES</span>;
            
            <span class="hljs-keyword">self</span>.animationDirection = location.y &gt;= <span class="hljs-keyword">self</span>.frame.size.height / <span class="hljs-number">2</span> ? <span class="hljs-number">-1.0</span> : <span class="hljs-number">1.0</span>;
            
            <span class="hljs-keyword">self</span>.layer.shouldRasterize = <span class="hljs-literal">YES</span>;

        }
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-built_in">UIGestureRecognizerStateChanged</span>:
        {
            <span class="hljs-built_in">CGFloat</span> rotationStrength = MIN(<span class="hljs-keyword">self</span>.xDistanceFromCenter / <span class="hljs-keyword">self</span>.frame.size.width, kRotationMax);
            <span class="hljs-built_in">CGFloat</span> rotationAngle = <span class="hljs-keyword">self</span>.animationDirection * kDefaultRotationAngle * rotationStrength;
            <span class="hljs-built_in">CGFloat</span> scaleStrength = <span class="hljs-number">1</span> - ((<span class="hljs-number">1</span> - kScaleMin) * fabs(rotationStrength));
            <span class="hljs-built_in">CGFloat</span> scale = MAX(scaleStrength, kScaleMin);
            
            <span class="hljs-keyword">self</span>.layer.rasterizationScale = scale * [<span class="hljs-built_in">UIScreen</span> mainScreen].scale;
            
            <span class="hljs-built_in">CGAffineTransform</span> transform = <span class="hljs-built_in">CGAffineTransformMakeRotation</span>(rotationAngle);
            <span class="hljs-built_in">CGAffineTransform</span> scaleTransform = <span class="hljs-built_in">CGAffineTransformScale</span>(transform, scale, scale);
            
            <span class="hljs-keyword">self</span>.transform = scaleTransform;
            <span class="hljs-keyword">self</span>.center = <span class="hljs-built_in">CGPointMake</span>(<span class="hljs-keyword">self</span>.originalLocation.x + <span class="hljs-keyword">self</span>.xDistanceFromCenter,
                                      <span class="hljs-keyword">self</span>.originalLocation.y + <span class="hljs-keyword">self</span>.yDistanceFromCenter);
            [<span class="hljs-keyword">self</span> updateOverlayWithFinishPercent:<span class="hljs-keyword">self</span>.xDistanceFromCenter / <span class="hljs-keyword">self</span>.frame.size.width];
            <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.delegate respondsToSelector:<span class="hljs-keyword">@selector</span>(cardView:draggedWithFinishPercent:)]) {
                [<span class="hljs-keyword">self</span>.delegate cardView:<span class="hljs-keyword">self</span> draggedWithFinishPercent:MIN(fabs(<span class="hljs-keyword">self</span>.xDistanceFromCenter * <span class="hljs-number">100</span> / <span class="hljs-keyword">self</span>.frame.size.width), <span class="hljs-number">100</span>)];
            }
        }
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-built_in">UIGestureRecognizerStateEnded</span>:
        {
            [<span class="hljs-keyword">self</span> swipeMadeAction];
            <span class="hljs-keyword">self</span>.layer.shouldRasterize = <span class="hljs-literal">NO</span>;
        }
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">break</span>;
    }
}
</code></pre><p>当用户拖拽最前面的卡片视图时,它就离事件触发边缘越来越近，当达到触发边缘时，它就从屏幕中消失了。到触发边缘的距离用百分比来表示。在顶部卡片视图被拖拽的过程中，底部的卡片也会有相应的动作，要么是放大要么是缩小。换而言之，顶层和底层的动画是同步的。 同样遮罩也会在移动的时候实时更新，在实时更新动画过程中，它的透明度从5%（几乎不可见）到100%（清晰可见）。</p><p>为了防止卡片边缘变得锯齿化，我使用了<code>layer</code>的<code>shouldRasterize</code>属性。同时我也要考虑到当卡片没有被拖拽到触发点时如何重置它的状态。我使用了 <code>Facebook</code> 的 <a href="https://github.com/facebook/pop" target="_blank">Pop</a>框架来设置其重置状态以及恢复上一步(undo)的动画。如果你有印象的话，所有<a href="https://www.facebook.com/paper" target="_blank">Paper</a>应用中的动画和过渡转换动画都是使用这个框架来完成的。它支持动态弹性动画，也允许创建任何物理现实中的交互动画，可喜的是它仅仅只需要很少的几行代码就可以实现。</p><h2>OverlayView的实现</h2><p><code>OverlayView</code>是在顶部卡片 View 进行动画时被添加上去的，它只有一个名为<code>overlayState</code>的属性，这个属性有两个可选值：当用户拖动卡片到左边，<code>overlayState</code>就添加一个红色的遮罩到卡片视图上，反之用户拖拽到右边，这个属性被设置为另一个可选值，使得卡片的遮罩变成绿色。（译者注：我在把代码翻译成 OC 时对变量名做了些许改动，<code>overlayState</code>改成了<code>type</code>，具体参见 GitHub，下同）。 为了实现遮罩的自定义行为，我们可以继承<code> OverlayView</code>，然后重载<code>overlayState</code>的<code> didSet</code>方法。大致代码如下：</p><pre data-language="objc" class="hljs"><code><span class="hljs-comment">//.h</span>
<span class="hljs-meta">#import <span class="hljs-meta-string">&lt;UIKit/UIKit.h&gt;</span></span>
<span class="hljs-meta">#import <span class="hljs-meta-string">"OverlayView.h"</span></span>

<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">CustomOverlayView</span> : <span class="hljs-title">OverlayView</span></span>

<span class="hljs-keyword">@end</span>
<span class="hljs-comment">//.m</span>
<span class="hljs-meta">#import <span class="hljs-meta-string">"CustomOverlayView.h"</span></span>

<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">CustomOverlayView</span> ()</span>
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">IBOutlet</span> <span class="hljs-built_in">UIImageView</span> *imageView;

<span class="hljs-keyword">@end</span>

<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">CustomOverlayView</span></span>

- (<span class="hljs-keyword">void</span>)setType:(OverlayType)type
{
    <span class="hljs-keyword">switch</span> (type) {
        <span class="hljs-keyword">case</span> OverlayTypeLeft:

            <span class="hljs-keyword">self</span>.imageView.image = [<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@"noOverlayImage"</span>];
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> OverlayTypeRight:
            <span class="hljs-keyword">self</span>.imageView.image = [<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@"yesOverlayImage"</span>];
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> OverlayTypeNone:
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">self</span>.imageView.image = <span class="hljs-literal">nil</span>;
            <span class="hljs-keyword">break</span>;
    }
}

<span class="hljs-keyword">@end</span>
</code></pre><h2>KolodaView的实现</h2><p><code>KolodaView</code>类负责卡片的加载以及管理工作。你可以通过代码或者<code>Interface Builder</code>来实现。然后你就可以为其指定<code> dataSource</code>以及<code> delegate</code>(可选)。最后你应该实现<code> dataSource</code>中的如下方法：</p><pre data-language="objc" class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">SwipeViewDataSource</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span>

<span class="hljs-keyword">@required</span>
- (<span class="hljs-built_in">NSUInteger</span>)swipeViewNumberOfCards:(SwipeView *)swipeView;
- (<span class="hljs-built_in">UIView</span> *)swipeView:(SwipeView *)swipeView
          cardAtIndex:(<span class="hljs-built_in">NSUInteger</span>)index;
- (OverlayView *)swipeView:(SwipeView *)swipeView
        cardOverlayAtIndex:(<span class="hljs-built_in">NSUInteger</span>)index;

<span class="hljs-keyword">@end</span>
</code></pre><p>我们使用了代理方法而不是回调(block)的方式来获取相关数据。</p><h2>几何解释</h2><p>还记得我们关于开发安卓<code>Guillotine</code>菜单动画的<a href="https://yalantis.com/blog/how-we-developed-the-guillotine-menu-animation-for-android/" target="_blank">故事</a>吗？在那个故事中我们的安卓工程师Dmytro Denysenko采用高中数学知识来计算一个自定义的差值。几何知识在我的 iOS 开发生涯中也发挥了很大的作用！</p><p>动画过程中最有趣的一件事就是当用户在拖拽顶部卡片时，下面的卡片也会跟着移动。我想让<code>Koloda</code>动画更加灵活，所以我简单地指定了想要在屏幕上展示的卡片数，然后我就拿出纸就开始计算。</p><img class="lazyload" data-src="/oldimages/2019-11-21-15743471268387.jpg"/><p><code>KolodaView</code>需要展示位于顶层卡片之下的卡片正确的数量，然后让它们在动画开始的时候占据正确的位置。为了实现它，我需要计算所有卡片的<code>frame</code>，这个是通过给其中每个元素添加对应的序号来实现的。举个例子，第一个卡片视图的序号是[i]，那么第二个就是[i+1],第三个就是[i+2],以此类推。 如下图所示，你可以清晰的看到第一张卡片的<code>frame</code>和<code>size</code>的计算过程。</p><img class="lazyload" data-src="/oldimages/2019-11-21-15743471496282.jpg"/><p>代码如下：</p><pre data-language="objc" class="hljs"><code>- (<span class="hljs-built_in">CGRect</span>)frameForCardAtIndex:(<span class="hljs-built_in">NSUInteger</span>)index
{
    <span class="hljs-built_in">CGFloat</span> bottomOffset = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">CGFloat</span> topOffset = kBackgroundCardsTopMargin * (<span class="hljs-keyword">self</span>.visibleCardsCount - <span class="hljs-number">1</span>);
    <span class="hljs-built_in">CGFloat</span> xOffset = kBackgroundCardsLeftMargin * index;
    <span class="hljs-built_in">CGFloat</span> scalePercent = kBackgroundCardsScalePercent;
    <span class="hljs-built_in">CGFloat</span> width = <span class="hljs-built_in">CGRectGetWidth</span>(<span class="hljs-keyword">self</span>.frame) * pow(scalePercent, index);
    <span class="hljs-built_in">CGFloat</span> height = (<span class="hljs-built_in">CGRectGetHeight</span>(<span class="hljs-keyword">self</span>.frame) - bottomOffset - topOffset) * pow(scalePercent, index);
    <span class="hljs-built_in">CGFloat</span> multiplier = index &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>;
    <span class="hljs-built_in">CGRect</span> previousCardFrame = index &gt; <span class="hljs-number">0</span> ? [<span class="hljs-keyword">self</span> frameForCardAtIndex:MAX(index - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)] : <span class="hljs-built_in">CGRectZero</span>;
    <span class="hljs-built_in">CGFloat</span> yOffset = (<span class="hljs-built_in">CGRectGetHeight</span>(previousCardFrame) - height + previousCardFrame.origin.y
                       + kBackgroundCardsTopMargin) * multiplier;
    <span class="hljs-built_in">CGRect</span> frame = <span class="hljs-built_in">CGRectMake</span>(xOffset, yOffset, width, height);
    <span class="hljs-keyword">return</span> frame;
}
</code></pre><p>现在我们知道了序号、卡片<code>frame</code>以及动画结束的百分比，我们就可以很轻松的计算出当上一个卡片被滑出屏幕时下一个卡片应该出现的位置。之后，我们也可以实现一个百分比驱动动画（PercentDrivenAnimation）。 最后我给这个简单易用的组件取了个有趣的名字--Koloda。任何开发者都可以自定义它，通过设置其内容视图以及遮罩视图。过些时候，我想实现自定义动画以及<code>frame</code>的计算方式，这样开发者们就可以使用他们自己别具一格的组件。 KolodaView 的代码详见<a href="https://github.com/Yalantis/Koloda" target="_blank">GitHub</a>。</p><p>&gt;- 译者注：ObjC 版本可以参见<a href="https://github.com/wang9262/Koloda-ObjC" target="_blank">Koloda-ObjC</a></p>]]></content><tag>翻译</tag></entry><entry><title>Koloda动画第二版[译]</title><link href="/posts/Koloda-Second-Version"/><url>/posts/Koloda-Second-Version</url><content type="html"><![CDATA[<p>一个月前，我们发布了<a href="https://yalantis.com/blog/how-we-built-tinder-like-koloda-in-swift/" target="_blank">how we developed Tinder-like Koloda in Swift</a>([如何创建一个类似 Tinder 的交互动画[译]](http://0.0.0.0:4000/2015/08/21/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BC%20Tinder%20%E7%9A%84%E4%BA%A4%E4%BA%92%E5%8A%A8%E7%94%BB/))。在开发者与设计师社区这个动画都受到强烈的欢迎，所以我们决定继续改善它。</p><p>原文：<a href="https://yalantis.com/blog/koloda-tinder-like-animation-version-2-prototyping-in-pixate-and-development-in-swift/" target="_blank">Koloda Tinder-Like Animation Version 2.</a></p><p>从我们发布第一个简单的 Koloda 动画后，我们的设计师Dmitry Goncharov坚持要实现他的下一个想法。同样，我们的 iOS 开发工程师，Koloda 动画创建者Eugene Andreyev承诺要让 frame 计算更加自定义化来让更多开发者在我们的 Koloda 动画上制作他们别具一格的组件。 所以这是 Koloda 故事的第二章。这一次我们将同时讨论设计和开发。同时你也可以在<a href="https://dribbble.com/shots/2189960-Koloda-Tinder-Like-component-for-IOS-Available-on-GitHub" target="_blank">Dribble</a>以及<a href="https://github.com/Yalantis/Koloda" target="_blank">GitHub</a>上查看该动画。</p><h2>我们如何用 Pixate 制作 Koloda 原型</h2><p>&gt;- by Dmitry Goncharov</p><p>我被 Tinder-like 这个概念所鼓舞，决定详细阐述把 Koloda 转变为不同寻常动画的最原始的想法。可喜的是，几个小时后我有了一个新的想法。我的想法是去除底部层级，从背景中来加载下一个卡片。我在 PS 中设计了一个实物模型，然后在<a href="http://www.pixate.com/" target="_blank">Pixate</a>中制作了原型。Pixate 是一个类似 InVisio、Marver、Origami 的设计工具。尽管在 Pixate 中设计原型比在 InVisio 中花了更多时间，但是Pixate做出的原型更加像一个原生应用。这个原型重造了我想要的卡片行为。</p><img class="lazyload" data-src="media/content_pixate.gif" alt="content_pixate"/><p>现在让我们来讲一下其中的过程。Pixate 工具栏中包含了layers、action kit、以及animations。在资源加载完成出现在 artboard 上后，你就可以在layer上开始工作了，然后继续创建交互。一开始我需要让卡片水平移动然后当他们跨越临界点时从屏幕当中飞出。在简单的动画帮助下，我实现了这个过程。同样我也让卡片改变它的透明度和在交互过程中进行旋转。</p><p>然后我要让一个新的卡片按照就像它从背景中加载一样出现，所以我需要对其进行拉伸和缩放。我设置了缩放比为3.5倍到1倍，3.5倍是卡片在背景中的大小。</p><p><a href="https://yalantis.com/media/content/ckeditor/2015/08/11/tips.png" target="_blank"></a></p><p>为了有更好的效果，我加了一些弹性动画，然后它就大功告成了。至此，原型设计就完成了，接下来就是开发的事情了。下面我想总结一下我对 Pixate 的总体印象。 优点：</p><ul><li>在移动设备上预览</li><li>原型处理简单</li><li>不需要有特定的动画基础知识</li><li>原型看起来更像原生 App</li><li>工程共享更加方便（可导出到电脑，外链，二维码）</li></ul><p>缺点：</p><ul><li>一个原型没有囊括整个 App 的功能，只是展示独立的功能和交互</li><li>一个单独的 artboard 不能容纳原型的所有界面</li><li>不能将原型导出为代码</li><li>web 端应用有 bug</li><li>基础的 asset kit 非常有限</li><li>动画没有时间线</li></ul><p>尽管有这么些缺点，但是 Pixate 是一个强大的工具，它能够设计师设计原生可点击的原型，创建导航模式以及屏幕间的交互。最重要的是，它能够让整个团队明白工程开发的整体方向。你可以观看<a href="https://www.youtube.com/channel/UCi0aGwdVsX6O4yw5JxpNGgQ" target="_blank">Jared Lodwick</a>的视频教程来了解更多。</p><p>现在你已经知道一些关于 Koloda 的原型设计过程，是时候来谈谈我们如何开发出第二版动画的。</p><h2>我们如何开发 Koloda v.2</h2><blockquote><p>by Eugene Andreyev</p></blockquote><p>第一版和第二版动画的最主要的区别就是卡片的布局。新版动画中最前的卡片被放置在屏幕中间，下面的卡片在背景中拉伸。底部卡片不会随顶部卡片移动而做出响应，而是在顶层卡片被滑出时出现在屏幕中，出现过程中有一个弹性特效。 得益于 Dima 的原型，第二版更加容易开发。首先，Pixate 允许查看原型的所有交互，其次我可以通过 Pixate 来查看所有应用到的变化，以及它们的顺序。然后简单地讲它们写进代码中，不需要人为调整。 最后，第二版 Koloda 是一个旅行 app 的一部分，不像第一版那样全是摇滚。</p><p>第一版：</p><img class="lazyload" data-src="media/content_koloda_v1.gif" alt="content<em>koloda</em>v1"/><h2>Koloda v.2的实现</h2><p>为了实现 Dima 设计的动画，我需要用不同的方式来放置卡片，所以我将<a href="http://vonglo.me/2015/08/21/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BC%20Tinder%20%E7%9A%84%E4%BA%A4%E4%BA%92%E5%8A%A8%E7%94%BB/" target="_blank">上一篇文章</a>(KolodaView实现那一段)中的<code>frameForCardAtIndex</code>暴露在头文件中。在 KolodaView 的子类中我复写了这个方法，然后按如下方式来放置卡片：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">frameForCardAtIndex</span><span class="hljs-params">(index: UInt)</span></span> -&gt; <span class="hljs-type">CGRect</span> {

       <span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span> {

           <span class="hljs-keyword">let</span> bottomOffset:<span class="hljs-type">CGFloat</span> = defaultBottomOffset

           <span class="hljs-keyword">let</span> topOffset:<span class="hljs-type">CGFloat</span> = defaultTopOffset

           <span class="hljs-keyword">let</span> xOffset:<span class="hljs-type">CGFloat</span> = defaultHorizontalOffset

           <span class="hljs-keyword">let</span> width = <span class="hljs-type">CGRectGetWidth</span>(<span class="hljs-keyword">self</span>.frame ) - <span class="hljs-number">2</span> * defaultHorizontalOffset

           <span class="hljs-keyword">let</span> height = width * defaultHeightRatio

           <span class="hljs-keyword">let</span> yOffset:<span class="hljs-type">CGFloat</span> = topOffset

           <span class="hljs-keyword">let</span> frame = <span class="hljs-type">CGRect</span>(x: xOffset, y: yOffset, width: width, height: height)

           <span class="hljs-keyword">return</span> frame

       } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> index == <span class="hljs-number">1</span> {

           <span class="hljs-keyword">let</span> horizontalMargin = -<span class="hljs-keyword">self</span>.bounds.width * backgroundCardHorizontalMarginMultiplier

           <span class="hljs-keyword">let</span> width = <span class="hljs-keyword">self</span>.bounds.width * backgroundCardScalePercent

           <span class="hljs-keyword">let</span> height = width * defaultHeightRatio

           <span class="hljs-keyword">return</span> <span class="hljs-type">CGRect</span>(x: horizontalMargin, y: <span class="hljs-number">0</span>, width: width, height: height)

       }

       <span class="hljs-keyword">return</span> <span class="hljs-type">CGRectZero</span>

   }
</code></pre><p>发生了什么？我将 frontCard放置在KolodaView中间，然后拉伸背景卡片为其原始大小的1.5倍。</p><img class="lazyload" data-src="media/15743481476006.jpg"/><h2>背景卡片的弹性动画</h2><p>因为背景卡片以弹性动画的方式出现，以及在移动过程中改变透明度，我写了一个新的代理方法：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-type">KolodaView</span> - <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">kolodaBackgroundCardAnimation</span><span class="hljs-params">(koloda: KolodaView)</span></span> -&gt; <span class="hljs-type">POPPropertyAnimation?</span>
</code></pre><p>在这个方法中，POPAnimation 被创建用来传给 Koloda。然后当用户滑动卡片时， Koloda 用它来给 frame 的改变做动画。如果代理方法返回 nil，意味着 Koloda 使用默认的动画。</p><p>下面代码就是这个代理方法的实现</p><pre data-language="Swift" class="hljs"><code> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">kolodaBackgroundCardAnimation</span><span class="hljs-params">(koloda: KolodaView)</span></span> -&gt; <span class="hljs-type">POPPropertyAnimation?</span> {

       <span class="hljs-keyword">let</span> animation = <span class="hljs-type">POPSpringAnimation</span>(propertyNamed: kPOPViewFrame)

       animation.springBounciness = frameAnimationSpringBounciness

       animation.springSpeed = frameAnimationSpringSpeed

       <span class="hljs-keyword">return</span> animation

   }
</code></pre><h2>怎样阻止背景卡片移动？</h2><p>同样我也添加了一个新的代理方法在新版的 Koloda 中</p><pre data-language="Swift" class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">kolodaShouldMoveBackgroundCard</span><span class="hljs-params">(koloda: KolodaView)</span></span> -&gt; <span class="hljs-type">Bool</span>
</code></pre><p>如果返回 false就意味着交互动画被禁用，背景卡片不会随着顶层卡片移动而移动。</p><p>下面就是返回 false 时的动画效果：</p><img class="lazyload" data-src="media/content_static_bg.gif" alt="content<em>static</em>bg"/><p>这是返回 true 的动画效果</p><img class="lazyload" data-src="media/content_v2.gif" alt="content_v2"/><p>希望你能喜欢第二版的 Koloda，尽情使用它吧！</p><ul><li><a href="https://dribbble.com/shots/2189960-Koloda-Tinder-Like-component-for-IOS-Available-on-GitHub" target="_blank">Dribbble</a></li><li><a href="https://github.com/Yalantis/Koloda" target="_blank">GitHub</a></li></ul>]]></content><tag>翻译</tag></entry><entry><title>UICollectionView自定义布局之风火轮[译]</title><link href="/posts/A-Spinning-Wheel-Layout"/><url>/posts/A-Spinning-Wheel-Layout</url><content type="html"><![CDATA[<p>现在有许多极具创造力的网站，几周前我碰巧浏览到一个名为<a href="http://fff.cmiscm.com/" target="_blank">Form Follows Function</a>的网站，上面有各种交互动画。其中最吸引我的是网站上的导航转轮，转轮由各种交互体验海报组成。</p><img class="lazyload" data-src="/oldimages/2019-11-21-15742622027530.jpg"/><p>原文：<a href="http://www.raywenderlich.com/107687/uicollectionview-custom-layout-tutorial-spinning-wheel" target="_blank">UICollectionView Custom Layout Tutorial: A Spinning Wheel</a></p><p>本教程将讲解如何使用自定义的 <code>UICollectionViewFlowLayout</code> 来再现那个导航风火轮。在开始之前，希望你有对 2D 转换、<code>UICollectionView</code> 及其自定义布局的基本知识。如果你对这些还不是很熟悉，推荐你先看看下面几篇教程。</p><ul><li><a href="http://www.raywenderlich.com/78550/beginning-ios-collection-views-swift-part-1" target="_blank">UICollectionView Tutorial Part 1: Getting Started</a></li><li><a href="http://www.raywenderlich.com/78551/beginning-ios-collection-views-swift-part-2" target="_blank">UICollectionView Tutorial Part 2: Reusable Views and Cell Selection</a></li><li><a href="http://www.raywenderlich.com/video-tutorials#collectionview" target="_blank">Video Series: Collection Views</a></li><li><a href="http://www.raywenderlich.com/video-tutorials#CCVL" target="_blank">Video Series: Custom Collection View Layouts</a></li></ul><p>通过学习该教程，你将了解到：</p><ul><li>从头开始创建自定义<code>collectionView</code>的布局，而不是使用 <code>UICollectionViewFlowLayout</code>作为你的基类。</li><li>view 在其 bounds 之外绕某点旋转</li></ul><p>那么现在，让我们开搞吧。</p><h2>开始</h2><p>首先下载<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2015/06/CircularCollectionView-Starter.zip" target="_blank">模板</a>，在 Xcode 中打开，运行。你将看到一系列 cell，每个代表<a href="http://www.raywenderlich.com/store" target="_blank">书城</a>中的一本书。</p><img class="lazyload" data-src="/oldimages/2019-11-21-15742622193056.jpg"/><p>下面我们来看看工程目录结构，有一个 CollectionViewController、一个自定义 Cell，cell 中有一个 imageView。然后 VC 被这些 Cell填充。我们的任务就是创建一个UICollectionViewLayout子类来将这些 Cell 按照圆弧排列。</p><h2>理论知识</h2><p>下图是一个带有 cell 的风火轮。黄色区域是 iPhone 的屏幕，蓝色圆角矩形是 cell，红色虚线是你将要放置 cell 的圆弧。</p><img class="lazyload" data-src="/oldimages/2019-11-21-15742622298263.jpg"/><p>你需要三个参数来创建这种排列：</p><ul><li>1.圆弧半径（radius）</li><li>2.每个 cell 之间的角度（anglePerItem）</li><li>3.每个 cell 的角位置</li></ul><p>你可能已经注意到，并非所有 cell 在屏幕当中能正常显示。</p><p>假设第0个 cell 的角度为 <code>x</code> 度，那么第1个 cell 的角位置为 <code>x + anglePerItem</code>,第二个为<code>x + anglePerItem * 2</code>，以此类推。第 n 个的角位置的计算公式如下：</p><pre data-language="undefined" class="hljs"><code>
angle_for_i = x + (i * anglePerItem)
</code></pre><p>下图展示的是角坐标系。0度代表中心，顺时针方向为正，逆时针方向为负。所以0度角的 cell 将处在正中央，完全垂直的方向。</p><img class="lazyload" data-src="/oldimages/2019-11-21-15742622407382.jpg"/><p>现在你对理论知识有了一个全面的理解，让我们开始撸代码吧。</p><h2>Circular Collection View Layout</h2><p>新建一个 swift 文件，取名CircularCollectionViewLayout，继承自UICollectionViewLayout。</p><img class="lazyload" data-src="/oldimages/2019-11-21-15742622925513.jpg"/><p>点击下一步、创建。这个UICollectionViewLayout的子类将包含所有与位置相关的代码。 因为CircularCollectionViewLayout继承自UICollectionViewLayout而不是UICollectionViewFlowLayout，所以你需要处理所有布局过程而不是简单调用 super 中的实现。</p><p>我发现 FlowLayout 非常适合网格视图而非圆形布局。 在CircularCollectionViewLayout中，新建两个属性<code>itemSize</code>和<code>radius</code>。</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">let</span> itemSize = <span class="hljs-type">CGSize</span>(width: <span class="hljs-number">133</span>, height: <span class="hljs-number">173</span>)
 
<span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">500</span> {
  <span class="hljs-keyword">didSet</span> {
    invalidateLayout()
  }
}
</code></pre><p>当半径改变时你需要重新计算所有值，所以要在 <code>didSet</code> 中调用<code>invalidateLayout()</code>。在 radius 声明下面紧接着<code>anglePerItem</code>的定义：</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">var</span> anglePerItem: <span class="hljs-type">CGFloat</span> {
  <span class="hljs-keyword">return</span> atan(itemSize.width / radius)
}
</code></pre><p><code>anglePerItem</code>可以是你想要的任何值，但是公式要确保 cell 不要被分散的太开。 下一步，实现<code>collectionViewContentSize()</code>来声明你的 collectionView 的内容有多大：</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">collectionViewContentSize</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">CGSize</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-type">CGSize</span>(width: <span class="hljs-type">CGFloat</span>(collectionView!.numberOfItemsInSection(<span class="hljs-number">0</span>)) * itemSize.width,
      height: <span class="hljs-type">CGRectGetHeight</span>(collectionView!.bounds))
}
</code></pre><p>内容高度与 collectionView 高度一致，但是宽度是<code>itemSize.width * numberOfItems</code>。 现在打开<code> Main.storyboard</code>，选中视图大纲中的Collection View，如下图所示</p><img class="lazyload" data-src="/oldimages/2019-11-21-15742625946308.jpg"/><p>打开Attributes Inspector，将其 Layout 设置为自定义，将其 Class 设置为CircularCollectionViewLayout。</p><img class="lazyload" data-src="/oldimages/2019-11-21-15742626021736.jpg"/><p>运行程序，你将发现除了一个可滑动区域外，屏幕上没有任何东西。但是它就是你想要的，因为这确保你正确地将 collectionView 的 Layout 设置为你自定义的 Class 即 CircularCollectionViewLayout。</p><img class="lazyload" data-src="/oldimages/2019-11-21-15742626135318.jpg"/><h2>自定义布局属性</h2><p>除了新建一个新的布局子类，你还要新建一个继承自UICollectionViewLayoutAttributes的类来存储角位置以及锚点（anchorPoint）。 把下面代码加到CircularCollectionViewLayout.swift这个文件中，将其放在CircularCollectionViewLayout类声明上面。</p><pre data-language="swift" class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircularCollectionViewLayoutAttributes</span>: <span class="hljs-title">UICollectionViewLayoutAttributes</span> </span>{
  <span class="hljs-comment">// 1</span>
  <span class="hljs-keyword">var</span> anchorPoint = <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0.5</span>, y: <span class="hljs-number">0.5</span>)
  <span class="hljs-keyword">var</span> angle: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">0</span> {
    <span class="hljs-comment">// 2 </span>
    <span class="hljs-keyword">didSet</span> {
      zIndex = <span class="hljs-type">Int</span>(angle * <span class="hljs-number">1000000</span>)
      transform = <span class="hljs-type">CGAffineTransformMakeRotation</span>(angle)
    }
  }
  <span class="hljs-comment">// 3</span>
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">copyWithZone</span><span class="hljs-params">(zone: NSZone)</span></span> -&gt; <span class="hljs-type">AnyObject</span> {
    <span class="hljs-keyword">let</span> copiedAttributes: <span class="hljs-type">CircularCollectionViewLayoutAttributes</span> = 
        <span class="hljs-keyword">super</span>.copyWithZone(zone) <span class="hljs-keyword">as</span>! <span class="hljs-type">CircularCollectionViewLayoutAttributes</span>
    copiedAttributes.anchorPoint = <span class="hljs-keyword">self</span>.anchorPoint
    copiedAttributes.angle = <span class="hljs-keyword">self</span>.angle
    <span class="hljs-keyword">return</span> copiedAttributes
  }
}
</code></pre><ul><li>1.我们需要一个锚点，因为旋转是围绕锚点而非中心。</li><li>2.当设置角度（angle）的时候，在内部设置其 transform 旋转 angle 弧度。同时我们想要右边的 cell 覆盖在左边的 cell 上，这个可以通过设置 zIndex 来实现。因为角度用弧度表示，我们将其扩大 1,000,000倍来确保相邻的值不会被四舍五入成同一个 zIndex 值，zIndex 是 Int 型的。</li><li>3.复写copyWithZone()来遵循NSCopying协议，因为在 collectionView 布局时，内部会拷贝布局属性。复写这个方法来确保复制过程中，<code>anchorPoint</code> 和 <code>angle</code>两个属性也会被拷贝。</li></ul><p>下面我们回到CircularCollectionViewLayout中来实现 layoutAttributesClass()方法。</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">override</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">func</span> <span class="hljs-title">layoutAttributesClass</span>() -&gt; <span class="hljs-title">AnyClass</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-type">CircularCollectionViewLayoutAttributes</span>.<span class="hljs-keyword">self</span>
}
</code></pre><p>这一步是为了告知 collecttionView 你将使用CircularCollectionViewLayoutAttributes而不是默认的UICollectionViewLayoutAttributes。 为了持有布局属性，在所有属性声明之后创建一个名为<code>attributesList</code>的数组。</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">var</span> attributesList = [<span class="hljs-type">CircularCollectionViewLayoutAttributes</span>]()
</code></pre><h2>Preparing the Layout</h2><p>当 collectionView 第一次展示在屏幕上时，Layout 的<code> prepareLayout()</code>方法将被调用。在每次布局生效时这个方法也会被调用。 这是布局过程中最重要的方法之一，因为这是创建和存储布局属性的入口。在CircularCollectionViewLayout添加如下代码：</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">prepareLayout</span><span class="hljs-params">()</span></span> {
  <span class="hljs-keyword">super</span>.prepareLayout()
 
  <span class="hljs-keyword">let</span> centerX = collectionView!.contentOffset.x + (<span class="hljs-type">CGRectGetWidth</span>(collectionView!.bounds) / <span class="hljs-number">2.0</span>)
  attributesList = (<span class="hljs-number">0</span>..&lt;collectionView!.numberOfItemsInSection(<span class="hljs-number">0</span>)).<span class="hljs-built_in">map</span> { (i) 
      -&gt; <span class="hljs-type">CircularCollectionViewLayoutAttributes</span> <span class="hljs-keyword">in</span>
    <span class="hljs-comment">// 1</span>
    <span class="hljs-keyword">let</span> attributes = <span class="hljs-type">CircularCollectionViewLayoutAttributes</span>(forCellWithIndexPath: <span class="hljs-type">NSIndexPath</span>(forItem: i,
        inSection: <span class="hljs-number">0</span>))
    attributes.size = <span class="hljs-keyword">self</span>.itemSize
    <span class="hljs-comment">// 2</span>
    attributes.center = <span class="hljs-type">CGPoint</span>(x: centerX, y: <span class="hljs-type">CGRectGetMidY</span>(<span class="hljs-keyword">self</span>.collectionView!.bounds))
    <span class="hljs-comment">// 3</span>
    attributes.angle = <span class="hljs-keyword">self</span>.anglePerItem*<span class="hljs-type">CGFloat</span>(i)
    <span class="hljs-keyword">return</span> attributes
  }
}
</code></pre><p>简单来说，我们便利每一个 item，然后执行闭包。下面我们一行行来解释：</p><ul><li>1.为每个 IndexPath 创建一个CircularCollectionViewLayoutAttributes实例，然后设置其大小（size）</li><li>2.将 item 放在屏幕中间</li><li>按弧度来旋转每个 item，旋转量为<code>anglePerItem * i</code></li></ul><p>&gt;方法中的 map 是 Swift 标准库中的一部分，它创建了一个新的数组，数组中存储的是闭包的执行结果。你可以在<a href="http://www.raywenderlich.com/82599/swift-functional-programming-tutorial" target="_blank">这篇文章</a>中了解更多。</p><p>我们还需要实现下面的方法，这些方法返回在给定矩形区域中的 item 布局属性，以及给定的 indexpath 的 item 布局属性。collectionView 在布局过程中将会多次调用这些方法，在用户滑动 collectionView 也会触发这些方法。为了保证其高效性，我们在<code>prepareLayout()</code>方法中缓存了这些布局属性。把下面代码加到<code>prepareLayout()</code>下面：</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">layoutAttributesForElementsInRect</span><span class="hljs-params">(rect: CGRect)</span></span> -&gt; [<span class="hljs-type">AnyObject</span>]? {
  <span class="hljs-keyword">return</span> attributesList
}
 
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">layoutAttributesForItemAtIndexPath</span><span class="hljs-params">(indexPath: NSIndexPath)</span></span> 
    -&gt; <span class="hljs-type">UICollectionViewLayoutAttributes!</span> {
  <span class="hljs-keyword">return</span> attributesList[indexPath.row]
}
</code></pre><p>第一个方法简单返回了整个布局属性数组，第二个方法返回了指定的 indexpath 对应的布局属性。这个方法非常 OK 因为我们的 item 数目比较小，但是通常我们会遍历数组来判断布局属性的 frame 是否与给定的矩形区域相交，然后返回与给定区域相交的布局属性。这使得 collectionView 在屏幕上只绘制这些 item，或者将要出现在屏幕上的 item。</p><p>运行，你会看到所有 cell 出现在屏幕上，但是它们是围绕自身来旋转而非外部的某个点。虽然它不是非常急需的效果，但是如果能做到确实挺酷的，你觉得呢？</p><img class="lazyload" data-src="/oldimages/2019-11-21-15742626594604.jpg"/><p>你能猜到为什么会这样吗？</p><h2>有人说是锚点吗？</h2><p>你还记得上面我们说的 cell 的锚点吗？你还没有设置过它，上面的旋转效果远没达到我们希望得到的效果。</p><img class="lazyload" data-src="/oldimages/2019-11-21-15742626864285.jpg"/><p>锚点是 CALayer 的一个属性，所有的旋转和缩放都是围绕着它而发生的。锚点的默认值是 center，就像上面的运行结果那样。 真正的锚点的 x 值应该为0.5，y 值应该为<code>radius + (itemSize.height / 2)</code>，因为锚点是在归一化坐标系中定义的，所以你要除以<code>itemSize.height</code>。</p><img class="lazyload" data-src="/oldimages/2019-11-21-15742626990183.jpg"/><p>回到<code>prepareLayout()</code>，然后再 <code>centerX</code> 的定义下面定义<code>anchorPointY</code>：</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">let</span> anchorPointY = ((itemSize.height / <span class="hljs-number">2.0</span>) + radius) / itemSize.height
</code></pre><p>在<code>map(_:)</code>闭包中的 return 上方添加如下代码：</p><pre data-language="swift" class="hljs"><code>attributes.anchorPoint = <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0.5</span>, y: anchorPointY)
</code></pre><p>接着打开open CircularCollectionViewCell.swift，然后复写<code>applyLayoutAttributes(_:)</code> ：</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">applyLayoutAttributes</span><span class="hljs-params">(layoutAttributes: UICollectionViewLayoutAttributes!)</span></span> {
  <span class="hljs-keyword">super</span>.applyLayoutAttributes(layoutAttributes)
  <span class="hljs-keyword">let</span> circularlayoutAttributes = layoutAttributes <span class="hljs-keyword">as</span>! <span class="hljs-type">CircularCollectionViewLayoutAttributes</span>
  <span class="hljs-keyword">self</span>.layer.anchorPoint = circularlayoutAttributes.anchorPoint
  <span class="hljs-keyword">self</span>.center.y += (circularlayoutAttributes.anchorPoint.y - <span class="hljs-number">0.5</span>) * <span class="hljs-type">CGRectGetHeight</span>(<span class="hljs-keyword">self</span>.bounds)
}
</code></pre><p>这里你用父类实现来使用默认属性如 center 和 transform 但是因为锚点（anchorPoint）是一个自定义属性，我们需要手动使用它，同样我们也更新了 center.y 来补偿圆形布局中的anchorPoint.y变化。</p><p>运行程序，你会看到所有的 cell 按照圆形来布局了，但是滑动的过程中...等一下，发生了什么？它们被移出了屏幕而不是旋转！？</p><p>这使得找到想要的书变得非常困难。</p><img class="lazyload" data-src="/oldimages/2019-11-21-15742627247360.gif"/><h2>改善滑动效果</h2><p>最具挑战性的布局 item 任务已经完成了，可喜可贺！:]</p><img class="lazyload" data-src="/oldimages/2019-11-21-15742627484536.jpg"/><p>现在需要做的就是改变角度值来实现滑动。</p><p>回到CircularCollectionViewLayout，然后在底部添加下面代码：</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shouldInvalidateLayoutForBoundsChange</span><span class="hljs-params">(newBounds: CGRect)</span></span> -&gt; <span class="hljs-type">Bool</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
}
</code></pre><p>该方法返回 true 告知 collectionView 在滑动时布局失效，然后它会调用<code>prepareLayout()</code>，进而使用更新后的角位置重新计算 cell 的布局。angle被定义为第0个 item 的角位置。你将要通过把contentOffset.x转换成一个合适的角度值来实现滑动。</p><p>滑动过程中，<code>contentOffset.x</code>从 0 到<code>collectionViewContentSize().width - CGRectGetWidth(collectionView!.bounds)</code>变化。将<code>contentOffset.x</code>的极值定义为<code>maxContentOffset</code>，当其为 0 时，让第 0 个item 处在中心，当其为极值时（即maxContentOffset），让最后一个 item 处在屏幕中心，这就意味着最后一个 item 的角位置会变为 0 。</p><img class="lazyload" data-src="/oldimages/2019-11-21-15742627839952.jpg"/><p>想象一下右边的场景，如果你是用<code>angle_for_last_item = 0</code>来解决下面等式你会得到：</p><pre data-language="undefined" class="hljs"><code>
angle_for_last_item = angle_for_zero_item + (totalItems - 1) * anglePerItem
0 = angle_for_zero_item + (totalItems - 1) * anglePerItem
angle_for_zero_item = -(totalItems - 1) * anglePerItem
</code></pre><p>定义<code>-(totalItems - 1) * anglePerItem</code>为<code>angleAtExtreme</code>，如下所示：</p><pre data-language="swift" class="hljs"><code>contentOffset.x = <span class="hljs-number">0</span>, angle = <span class="hljs-number">0</span>
contentOffset.x = maxContentOffset, angle = angleAtExtreme
</code></pre><p>由上面，使用下面的公式非常容易计算任意<code>contentOffset.x</code>对应的角度：</p><pre data-language="undefined" class="hljs"><code>
angle = -angleAtExtreme * contentOffset.x / maxContentOffset
</code></pre><p>脑海中回想以下这些算式，把下面代码添加到 itemSize 的声明下：</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">var</span> angleAtExtreme: <span class="hljs-type">CGFloat</span> {
  <span class="hljs-keyword">return</span> collectionView!.numberOfItemsInSection(<span class="hljs-number">0</span>) &gt; <span class="hljs-number">0</span> ? 
    -<span class="hljs-type">CGFloat</span>(collectionView!.numberOfItemsInSection(<span class="hljs-number">0</span>) - <span class="hljs-number">1</span>) * anglePerItem : <span class="hljs-number">0</span>
}
<span class="hljs-keyword">var</span> angle: <span class="hljs-type">CGFloat</span> {
  <span class="hljs-keyword">return</span> angleAtExtreme * collectionView!.contentOffset.x / (collectionViewContentSize().width - 
    <span class="hljs-type">CGRectGetWidth</span>(collectionView!.bounds))
}
</code></pre><p>接下来使用</p><pre data-language="swift" class="hljs"><code>attributes.angle = <span class="hljs-keyword">self</span>.angle + (<span class="hljs-keyword">self</span>.anglePerItem * <span class="hljs-type">CGFloat</span>(i))
</code></pre><p>来替换<code>prepareLayout()</code>中的</p><pre data-language="swift" class="hljs"><code>attributes.angle = (<span class="hljs-keyword">self</span>.anglePerItem * <span class="hljs-type">CGFloat</span>(i))
</code></pre><p>这一步添加为每个 item 添加了角度值，这样 item 的角度值不在是一个常量，而是一个与<code>contentOffset.x</code>有着函数关系的值。 运行程序，在屏幕上滑动，你将发现所有 item 按照你想要的方式在滑动。干得漂亮！</p><img class="lazyload" data-src="/oldimages/2019-11-21-15742628030765.gif"/><h2>加分环节:优化</h2><p>你已经成功的重现了风火轮导航，现在可以在拍拍自己肩膀说一句干得漂亮，然后架着二郎腿享受这美好时光。但是在存在优化空间的情况（滑动丝滑般流畅）下你为什么要停下来呢？ 在<code>prepareLayout()</code>中为每个 item 创建了一个CircularCollectionViewLayoutAttributes实例，但是不是所有的 item 都会立刻展示在屏幕上。那些离屏的 item，你可以完全跳过对它们的计算，也不必创建CircularCollectionViewLayoutAttributes实例。 但是有一个棘手的问题是：我们需要确定哪些 item 正在屏幕上显示，哪些是离屏的。如下图所示，在 (-θ, θ)范围之外的所有 item 都是离屏的。</p><img class="lazyload" data-src="/oldimages/2019-11-21-15742628334079.jpg"/><p>举个栗子，为了计算三角形 ABC 中的 θ 角，可以使用下面公式：</p><pre data-language="undefined" class="hljs"><code>
tanθ = (collectionView.width / 2) / (radius + (itemSize.height / 2) - (collectionView.height / 2))
</code></pre><p>在<code>prepareLayout()</code>中的<code>anchorPointY</code>下一行加入如下代码：</p><pre data-language="swift" class="hljs"><code><span class="hljs-comment">// 1 </span>
<span class="hljs-keyword">let</span> theta = atan2(<span class="hljs-type">CGRectGetWidth</span>(collectionView!.bounds) / <span class="hljs-number">2.0</span>, 
    radius + (itemSize.height / <span class="hljs-number">2.0</span>) - (<span class="hljs-type">CGRectGetHeight</span>(collectionView!.bounds) / <span class="hljs-number">2.0</span>))
<span class="hljs-comment">// 2</span>
<span class="hljs-keyword">var</span> startIndex = <span class="hljs-number">0</span>
<span class="hljs-keyword">var</span> endIndex = collectionView!.numberOfItemsInSection(<span class="hljs-number">0</span>) - <span class="hljs-number">1</span> 
<span class="hljs-comment">// 3</span>
<span class="hljs-keyword">if</span> (angle &lt; -theta) {
  startIndex = <span class="hljs-type">Int</span>(floor((-theta - angle) / anglePerItem))
}
<span class="hljs-comment">// 4</span>
endIndex = <span class="hljs-built_in">min</span>(endIndex, <span class="hljs-type">Int</span>(ceil((theta - angle) / anglePerItem)))
<span class="hljs-comment">// 5</span>
<span class="hljs-keyword">if</span> (endIndex &lt; startIndex) {
  endIndex = <span class="hljs-number">0</span>
  startIndex = <span class="hljs-number">0</span>
}
</code></pre><p>这一步我们做了什么？</p><ul><li>1.使用反正切函数计算theta角</li><li>2.初始化<code>startIndex</code>及<code>endIndex</code></li><li>3.如果第0个 item 的角位置小于 <code>-theta</code>，那么它就是离屏的，屏上第 1 个 item 的 <code>index</code> 将为 <code>-θ</code> 与 <code>angle</code> 的差值再除以 <code>anglePerItem</code></li><li>4.同样的，屏幕上最后一个 item 是<code>θ</code> 与 <code>angle</code> 的差值再除以 <code>anglePerItem</code>，min 是保证<code>endIndex</code>不会越界</li><li>5.最后做了一个容错处理，防止在快速滑动时所有 cell 都离屏时导致 <code>endIndex</code>小于 <code>startIndex</code>的情况</li></ul><p>下图把上面的计算过程可视化：</p><img class="lazyload" data-src="/oldimages/2019-11-21-15742628443820.jpg"/><p>既然我们知道了哪些正在显示，哪些是离屏的，我们需要更新用来计算布局属性的起始和结束的 index。使用</p><pre data-language="swift" class="hljs"><code>attributesList = (startIndex...endIndex).<span class="hljs-built_in">map</span> { (i) 
    -&gt; <span class="hljs-type">CircularCollectionViewLayoutAttributes</span> <span class="hljs-keyword">in</span>
</code></pre><p>来替换<code>prepareLayout()</code>中的：</p><pre data-language="swift" class="hljs"><code>attributesList = (<span class="hljs-number">0</span>..&lt;collectionView!.numberOfItemsInSection(<span class="hljs-number">0</span>)).<span class="hljs-built_in">map</span> { (i) 
    -&gt; <span class="hljs-type">CircularCollectionViewLayoutAttributes</span> <span class="hljs-keyword">in</span>
</code></pre><p>运行程序，你会发现视觉上没有明显变化，因为所有的改变仅仅影响离屏的 item。我们可以打开 Xcode <a href="http://www.raywenderlich.com/98356/view-debugging-in-xcode-6" target="_blank">内置的视图层级查看器</a></p><p>因为创建了更少的变量，你应该可以看到性能的提升。</p><img class="lazyload" data-src="/oldimages/2019-11-21-15742628535614.jpg"/><h2>何去何从</h2><p>你可以<a href="https://koenig-media.raywenderlich.com/uploads/2015/06/CircularCollectionView-Final.zip" target="_blank">在此</a>下载完整代码。</p><img class="lazyload" data-src="/oldimages/2019-11-21-15742628626003.jpg"/><p>恭喜，你已经成功使用了自定义的 Layout 来实现一个导航风火轮。在这篇教程中你应该学到不少东西，包括如何旋转 view、改变锚点、从头创建自定义的 Layout 以及如何优化让它变得更好。 你可以更改<code>radius</code>和<code>anglePerItem</code>来进一步了解它们是如何来改变最终的圆形布局排列的。这篇教程主要是改变2D 的 transform，你也可以使用3D transform 来创建更有趣的效果。 同样你也可以通过复写<code>argetContentOffsetForProposedContentOffset(_:withScrollingVelocity:)</code>方法来实现snapping行为。 我相信你已经开始跃跃欲试了吧？如果你遇到问题，可以参考下面的代码：</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">targetContentOffsetForProposedContentOffset</span><span class="hljs-params">(proposedContentOffset: CGPoint, withScrollingVelocity velocity: CGPoint)</span></span> -&gt; <span class="hljs-type">CGPoint</span> {
  <span class="hljs-keyword">var</span> finalContentOffset = proposedContentOffset
  <span class="hljs-keyword">let</span> factor = -angleAtExtreme/(collectionViewContentSize().width - 
      <span class="hljs-type">CGRectGetWidth</span>(collectionView!.bounds))
  <span class="hljs-keyword">let</span> proposedAngle = proposedContentOffset.x*factor
  <span class="hljs-keyword">let</span> ratio = proposedAngle/anglePerItem
  <span class="hljs-keyword">var</span> multiplier: <span class="hljs-type">CGFloat</span>
  <span class="hljs-keyword">if</span> (velocity.x &gt; <span class="hljs-number">0</span>) {
    multiplier = ceil(ratio)
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (velocity.x &lt; <span class="hljs-number">0</span>) {
    multiplier = floor(ratio)
  } <span class="hljs-keyword">else</span> {
    multiplier = round(ratio)
  }
  finalContentOffset.x = multiplier*anglePerItem/factor
  <span class="hljs-keyword">return</span> finalContentOffset
}
</code></pre><p>如果你有任何疑问、评论或者炫技，请加入下面的讨论。</p>]]></content><tag>UICollectionView</tag><tag>翻译</tag></entry><entry><title>如何创建一个翻书动画(Part 1)[译]</title><link href="/posts/How-to-Create-an-iOS-Book-Open-Animation-part-one-translation"/><url>/posts/How-to-Create-an-iOS-Book-Open-Animation-part-one-translation</url><content type="html"><![CDATA[<p>在这个分两部分的教程系列中，你将开发一个漂亮的 iOS 打开及翻书动画，类似于<a href="https://www.fiftythree.com/paper" target="_blank">Paper by FiftyThree</a>：</p><blockquote><p>2019.11.21 update 本文中图片和资源相关链接可能已失效，如需查阅，请查看原文</p></blockquote><ul><li>第一部分，你将学习如何自定义 UICollectionViewLayout，然后使用景深和阴影来让 app 看起来更加真实。</li><li><a href="http://www.raywenderlich.com/?p=97690" target="_blank">第二部分</a>(<a href="http://t.cn/Ry2rYj5" target="_blank">译文</a>)，你将学习创建自定义的转场动画，然后集成手势来创建自然、简洁的 view 之间的转场。</li></ul><p>原文：<a href="http://www.raywenderlich.com/94565/how-to-create-an-ios-book-open-animation-part-1" target="_blank">How to Create an iOS Book Open Animation: Part 1</a></p><img class="lazyload" data-src="/oldimages/BookOpening.gif"/><p>本教程主要针对于进阶中的开发者，讲解一些自定义转场以及自定义 collectionView Layout 相关的知识。 如果你之前没有用过 collectionView，那么建议你先看看其他关于 collectionView 的<a href="http://www.raywenderlich.com/tutorials" target="_blank">教程</a>。</p><blockquote><p>感谢<a href="https://twitter.com/hegedus90" target="_blank">Attila Hegedüs</a>创建了这个棒棒哒示例工程。</p></blockquote><h2>开始</h2><p>下载<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2015/05/Starter-Paper1.zip" target="_blank">模板</a>，解压，在 Xcode 中打开。使用模拟器运行程序，将得到如下画面：</p><img class="lazyload" data-src="/oldimages/VN_paperAnimation2.gif"/><p>这个应用已经初具其功能，你可以滑动书库然后选中你喜欢的书来翻阅。上一次你一页一页翻看书籍是什么时候？在现有对 collectionView 了解的基础上，你可以美化页面视图。</p><h2>工程结构</h2><p>下面是快速对初始工程重要方面的一个简要描述： Data Model 文件夹包含三个文件：</p><ul><li>Books.plist：包含样书数据。每本书都含有一个图片封面以及一系列的书页图片</li><li>BookStore.swift：单例，主要工作就是从 Books.plist 中加载数据然后创建 Book 对象。</li><li>Book.swift：存储书本相关信息的类</li></ul><p>Books 文件夹包含两个文件： - BooksViewController.swift：UICollectionViewController的子类，主要负责展示书单 - BookCoverCell.swift：展示所有书的封面，在BooksViewController使用。</p><p>Book 文件夹包含下面几个文件：</p><ul><li>BookViewController.swift：也是UICollectionViewController的子类，用来展示BooksViewController中选中的某一本书的内容页面</li><li>BookPageCell.swift：用来展示书的所有页面，在BookViewController中使用。</li></ul><p>最后一个文件夹 Helper 中包含：</p><ul><li>UIImage+Helpers.swift：是 UIImage 的一个扩展。里面有两个工具方法，一个用来圆角化图片，另一个用来缩放图片到指定大小。</li></ul><p>以上就是整个工程的目录结构。现在让我们开始撸代码吧！</p><h2>自定义 Book 布局</h2><p>首先你需要为BooksViewController的 collectionView复写默认的布局，默认布局显示3个大的书本封面，它们几乎占据整个屏幕。你需要缩小它们来让它看起来更舒服，像这样：</p><img class="lazyload" data-src="/oldimages/VN_AnimationBooksScrolling.gif"/><p>在你滑动的过程中，最接近屏幕中心的封面将会变大一些来表示它当前被选中。继续滑动，封面将会变小，这意味着你将它移到一边即远离屏幕中心。 在 AppBooks 下创建一个名为 Layout 的分组，然后右击 Layout 文件夹选择新建文件，然后创建一个继承自UICollectionViewFlowLayout的子类，取名为BooksLayout，语言为 Swift。 接下来你需要告诉BooksViewController的 collectionView 使用你新建的 Layout。 打开Main.storyboard，选中BooksViewController的Collection View然后在右侧的Attributes Inspector将 layout 设置为 Custom，Class 设置为 BooksLayout，如下图所示：</p><img class="lazyload" data-src="/oldimages/VN_BooksLayoutStoryboard.png"/><p>打开BooksLayout.swift，在BooksLayout类声明上面添加如下代码：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> <span class="hljs-type">PageWidth</span>: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">362</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> <span class="hljs-type">PageHeight</span>: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">568</span>
</code></pre><p>这两个常量将被用来设置 cell 的 size。 接着添加下面初始化方法：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-keyword">required</span> <span class="hljs-keyword">init</span>(coder aDecoder: <span class="hljs-type">NSCoder</span>) {
  <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(coder: aDecoder)
 
  scrollDirection = <span class="hljs-type">UICollectionViewScrollDirection</span>.<span class="hljs-type">Horizontal</span> <span class="hljs-comment">//1</span>
  itemSize = <span class="hljs-type">CGSizeMake</span>(<span class="hljs-type">PageWidth</span>, <span class="hljs-type">PageHeight</span>) <span class="hljs-comment">//2</span>
  minimumInteritemSpacing = <span class="hljs-number">10</span> <span class="hljs-comment">//3</span>
}
</code></pre><p>下面是关于1，2，3的解释：</p><ul><li>1.设置滑动方向为水平</li><li>2.设置 cell 的页面宽度为362，高度为568</li><li>3.设置 cell 减最小间距为10</li></ul><p>接下来，在<code>init(coder:)</code>后面添加如下代码：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">prepareLayout</span><span class="hljs-params">()</span></span> {
  <span class="hljs-keyword">super</span>.prepareLayout()
 
  <span class="hljs-comment">//The rate at which we scroll the collection view.</span>
  <span class="hljs-comment">//1</span>
  collectionView?.decelerationRate = <span class="hljs-type">UIScrollViewDecelerationRateFast</span>
 
  <span class="hljs-comment">//2</span>
  collectionView?.contentInset = <span class="hljs-type">UIEdgeInsets</span>(
    top: <span class="hljs-number">0</span>,
    <span class="hljs-keyword">left</span>: collectionView!.bounds.width / <span class="hljs-number">2</span> - <span class="hljs-type">PageWidth</span> / <span class="hljs-number">2</span>,
    bottom: <span class="hljs-number">0</span>,
    <span class="hljs-keyword">right</span>: collectionView!.bounds.width / <span class="hljs-number">2</span> - <span class="hljs-type">PageWidth</span> / <span class="hljs-number">2</span>
  )
}
</code></pre><p><code>prepareLayout()</code>让你有机会在获取布局信息前进行一系列运算。下面是对每个数字注释的解释：</p><ul><li>1.设置用户手指移开后collectionView 的减速速率。通过设置其值为UIScrollViewDecelerationRateFast，colletionView 将会更快速的停止滑动。也可以尝试以下Normal来查看以下对比。</li><li>2.设置 contentInset，让第一本书的封面一直居中。</li></ul><p>现在你需要位没一个 cell 处理布局信息。 在<code>prepareLayout()</code>方法下面添加如下代码：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">layoutAttributesForElementsInRect</span><span class="hljs-params">(rect: CGRect)</span></span> -&gt; [<span class="hljs-type">AnyObject</span>]? {
  <span class="hljs-comment">//1</span>
  <span class="hljs-keyword">var</span> array = <span class="hljs-keyword">super</span>.layoutAttributesForElementsInRect(rect) <span class="hljs-keyword">as</span>! [<span class="hljs-type">UICollectionViewLayoutAttributes</span>]
 
  <span class="hljs-comment">//2</span>
  <span class="hljs-keyword">for</span> attributes <span class="hljs-keyword">in</span> array {
    <span class="hljs-comment">//3</span>
    <span class="hljs-keyword">var</span> frame = attributes.frame
    <span class="hljs-comment">//4</span>
    <span class="hljs-keyword">var</span> <span class="hljs-built_in">distance</span> = <span class="hljs-built_in">abs</span>(collectionView!.contentOffset.x + collectionView!.contentInset.<span class="hljs-keyword">left</span> - frame.origin.x)
    <span class="hljs-comment">//5</span>
    <span class="hljs-keyword">var</span> scale = <span class="hljs-number">0.7</span> * <span class="hljs-built_in">min</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span> - <span class="hljs-built_in">distance</span> / (collectionView!.bounds.width), <span class="hljs-number">0.75</span>), <span class="hljs-number">1</span>)
    <span class="hljs-comment">//6</span>
    attributes.transform = <span class="hljs-type">CGAffineTransformMakeScale</span>(scale, scale)
  }
 
  <span class="hljs-keyword">return</span> array
}
</code></pre><p>layoutAttributesForElementsInRect(_:)返回一个包含了多个UICollectionViewLayoutAttributes对象的数组，这些对象为每个 cell 提供布局属性。下面是对代码的拆分：</p><ul><li>1.调用父类的layoutAttributesForElementsInRect方法来获取每个 cell 默认的布局属性</li><li>2.遍历数组中的每个属性</li><li>3.获取当前 cell 布局属性的 frame</li><li>4.计算封面与屏幕中心的距离</li><li>5.根据4中的距离来改变封面的 scale，使其在0.75到1之间，最后在乘以一个系数0.7让它看起来更舒服</li><li>6.最后让封面使用设置后的 scale</li></ul><p>紧接着在<code> layoutAttributesForElementsInRect(_:)</code>之后添加如下代码：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shouldInvalidateLayoutForBoundsChange</span><span class="hljs-params">(newBounds: CGRect)</span></span> -&gt; <span class="hljs-type">Bool</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
}
</code></pre><p>返回 true 表示在每一次 collectionView bounds 发生改变时强制让 layout 去重新计它的布局属性。collectionView 在滑动过程中 bounds 会发生改变，这使得重计算 cell 的布局属性变得很方便。</p><p>运行程序，将会发现中间的封面会比其他的大。</p><img class="lazyload" data-src="/oldimages/VN_NotSnappy.gif"/><p>滑动来查看每个封面是如何放大和缩小的。但是如果书籍吸附在相应位置是不是更好呢？接下来我们就来实现这个。</p><h2>书本吸附</h2><p><code>targetContentOffsetForProposedContentOffset(_:withScrollingVelocity:)</code>决定<code>collectionView</code>停在什么位置，然后返回一个<code>offset</code>来设置 <code>collectionView</code> 的 <code>contentOffset</code>。如果不复写这个方法，则返回默认的 offset。在<code>shouldInvalidateLayoutForBoundsChange(_:)</code>后面添加如下代码：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">targetContentOffsetForProposedContentOffset</span><span class="hljs-params">(proposedContentOffset: CGPoint, withScrollingVelocity velocity: CGPoint)</span></span> -&gt; <span class="hljs-type">CGPoint</span> {
  <span class="hljs-comment">// Snap cells to centre</span>
  <span class="hljs-comment">//1</span>
  <span class="hljs-keyword">var</span> newOffset = <span class="hljs-type">CGPoint</span>()
  <span class="hljs-comment">//2</span>
  <span class="hljs-keyword">var</span> layout = collectionView!.collectionViewLayout <span class="hljs-keyword">as</span>! <span class="hljs-type">UICollectionViewFlowLayout</span>
  <span class="hljs-comment">//3</span>
  <span class="hljs-keyword">var</span> width = layout.itemSize.width + layout.minimumLineSpacing
  <span class="hljs-comment">//4</span>
  <span class="hljs-keyword">var</span> offset = proposedContentOffset.x + collectionView!.contentInset.<span class="hljs-keyword">left</span>
 
  <span class="hljs-comment">//5</span>
  <span class="hljs-keyword">if</span> velocity.x &gt; <span class="hljs-number">0</span> {
    <span class="hljs-comment">//ceil returns next biggest number</span>
    offset = width * ceil(offset / width)
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> velocity.x == <span class="hljs-number">0</span> { <span class="hljs-comment">//6</span>
    <span class="hljs-comment">//rounds the argument</span>
    offset = width * round(offset / width)
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> velocity.x &lt; <span class="hljs-number">0</span> { <span class="hljs-comment">//7</span>
    <span class="hljs-comment">//removes decimal part of argument</span>
    offset = width * floor(offset / width)
  }
  <span class="hljs-comment">//8</span>
  newOffset.x = offset - collectionView!.contentInset.<span class="hljs-keyword">left</span>
  newOffset.y = proposedContentOffset.y <span class="hljs-comment">//y will always be the same...</span>
  <span class="hljs-keyword">return</span> newOffset
}
</code></pre><p>在用户手指离开屏幕时，该方法将会计算书本封面的 offset。</p><ul><li>1.创建一个名为 newOffset 的 CGPoint</li><li>2.获取当前 collectionView 的 layout</li><li>3.获取 cell 的宽度</li><li>4.计算当前offset</li><li>5.如果 velocity.x &gt; 0,用户是在向右滑。把 offset/width 理解成书本的 index，滑至对应的 index</li><li>6.如果 velocity.x = 0,用户滑动距离不够，保持上衣吃选中的书不变</li><li>7.如果 velocity.x &lt; 0,用户向左滑</li><li>8.更新 x 的 offset，然后返回。保证书的封面居中显示</li></ul><p>运行程序，滑动一下，你会发现滑动过程中书本，吸附效果更明显了。 你需要建立一种机制来使得用户只能点击居中的书本，然而现在不管书本在哪，你都可以点击。 打开BooksViewController.swift，将下面代码加到<code>// MARK: Helpers</code>注释下方：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">selectedCell</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">BookCoverCell?</span> {
  <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> indexPath = collectionView?.indexPathForItemAtPoint(<span class="hljs-type">CGPointMake</span>(collectionView!.contentOffset.x + collectionView!.bounds.width / <span class="hljs-number">2</span>, collectionView!.bounds.height / <span class="hljs-number">2</span>)) {
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> cell = collectionView?.cellForItemAtIndexPath(indexPath) <span class="hljs-keyword">as</span>? <span class="hljs-type">BookCoverCell</span> {
      <span class="hljs-keyword">return</span> cell
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}
</code></pre><p>该方法返回居中的 cell。 接下来用下面代码来替换<code>openBook(_:) </code></p><pre data-language="Swift" class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openBook</span><span class="hljs-params">()</span></span> {
  <span class="hljs-keyword">let</span> vc = storyboard?.instantiateViewControllerWithIdentifier(<span class="hljs-string">"BookViewController"</span>) <span class="hljs-keyword">as</span>! <span class="hljs-type">BookViewController</span>
  vc.book = selectedCell()?.book
  <span class="hljs-comment">// UICollectionView loads it's cells on a background thread, so make sure it's loaded before passing it to the animation handler</span>
  dispatch_async(dispatch_get_main_queue(), { () -&gt; <span class="hljs-type">Void</span> <span class="hljs-keyword">in</span>
    <span class="hljs-keyword">self</span>.navigationController?.pushViewController(vc, animated: <span class="hljs-literal">true</span>)
    <span class="hljs-keyword">return</span>
  })
}
</code></pre><p>该方法简单使用了上面写的<code>selectedCell</code>方法来获取当前选中的书本。 然后用下面代码替换<code>collectionView(_:didSelectItemAtIndexPath:)</code>：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">collectionView</span><span class="hljs-params">(collectionView: UICollectionView, didSelectItemAtIndexPath indexPath: NSIndexPath)</span></span> {
  openBook()
}
</code></pre><p>这个方法使得你的点击打开的书本一直是居中的 cell 对应的书本，而不是之前 indexPath 对应的书本。</p><p>至此，我们已经完成了 BooksLayout。是时候展示真正的技术了--让屏幕上的书本看起来更自然真实，同时支持翻页。</p><h2>翻页布局</h2><p>下图是我们要达成的最终效果：</p><img class="lazyload" data-src="/oldimages/VN_PageFlipping.gif"/><p>使其看起来更像一本书！:]</p><p>在 Book 分组下新建 Layout 分组，右键新建一个继承自UICollectionViewFlowLayout名为BookLayout的子类，语言设置为 Swift。</p><p>和之前一样，bookCollectionView 需要设置其 Layout 为刚才新建的 Layout 类，如下图所示：</p><img class="lazyload" data-src="/oldimages/VN_BookLayoutStoryboard.png"/><p>打开 BookLayout.swift，在 BookLayout 类声明上面加入如下代码：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> <span class="hljs-type">PageWidth</span>: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">362</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> <span class="hljs-type">PageHeight</span>: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">568</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> numberOfItems = <span class="hljs-number">0</span>
</code></pre><p>我们将使用这些常量来设置每个 cell 的大小，同样我们需要记录一本书的页数。 接下来在类声明中添加如下代码：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">prepareLayout</span><span class="hljs-params">()</span></span> {
  <span class="hljs-keyword">super</span>.prepareLayout()
  collectionView?.decelerationRate = <span class="hljs-type">UIScrollViewDecelerationRateFast</span>
  numberOfItems = collectionView!.numberOfItemsInSection(<span class="hljs-number">0</span>)
  collectionView?.pagingEnabled = <span class="hljs-literal">true</span>
}
</code></pre><p>和你在BooksLayout中所做的类似，不同的是：</p><ul><li>1.设置减速速率为UIScrollViewDecelerationRateFast来增加减速速率，进而使得 scrollView 快速停止</li><li>2.获取当前书本的页数</li><li>3.启用翻页；让每次滑动都是一个页面的距离</li></ul><p>继续在BookLayout.swift添加如下代码：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shouldInvalidateLayoutForBoundsChange</span><span class="hljs-params">(newBounds: CGRect)</span></span> -&gt; <span class="hljs-type">Bool</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
}
</code></pre><p>和上面一样，在 bounds 发生改变时使布局失效，进而调用 prepareLayout 来计算新的布局。 接下来复写collectionViewContentSize()来设置 collecyionView 的 contentSize：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">collectionViewContentSize</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">CGSize</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-type">CGSizeMake</span>((<span class="hljs-type">CGFloat</span>(numberOfItems / <span class="hljs-number">2</span>)) * collectionView!.bounds.width, collectionView!.bounds.height)
}
</code></pre><p>该方法返回整个内容视图大小，高度不变，宽度随着 item 及书的页数发生改变。之所以要除以2，是因为每一页有两面，每一面上都有内容。 和你在BooksLayout中做的一样，需要复写layoutAttributesForElementsInRect(_:)方法，在这个方法中可以添加为每一页添加翻页效果。 在collectionViewContentSize()方法后面添加下面代码：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">layoutAttributesForElementsInRect</span><span class="hljs-params">(rect: CGRect)</span></span> -&gt; [<span class="hljs-type">AnyObject</span>]? {
  <span class="hljs-comment">//1</span>
  <span class="hljs-keyword">var</span> array: [<span class="hljs-type">UICollectionViewLayoutAttributes</span>] = []
 
  <span class="hljs-comment">//2</span>
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ... <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, numberOfItems - <span class="hljs-number">1</span>) {
    <span class="hljs-comment">//3</span>
    <span class="hljs-keyword">var</span> indexPath = <span class="hljs-type">NSIndexPath</span>(forItem: i, inSection: <span class="hljs-number">0</span>)
    <span class="hljs-comment">//4</span>
    <span class="hljs-keyword">var</span> attributes = layoutAttributesForItemAtIndexPath(indexPath)
    <span class="hljs-keyword">if</span> attributes != <span class="hljs-literal">nil</span> {
      <span class="hljs-comment">//5</span>
      array += [attributes]
    }
  }
  <span class="hljs-comment">//6</span>
  <span class="hljs-keyword">return</span> array
}
</code></pre><p>和 BooksLayout 不同的是，因为所有 cell 都在可见区域中，所以我们在 layoutAttributesForItemAtIndexPath(_:) 方法中来计算布局属性。 下面是每一行的解释：</p><ul><li>1.创建一个新的数组来持有所有 cell 的布局属性</li><li>2.遍历所有 item</li><li>3.为每个 item 创建一个 indexPath</li><li>4.获取 indexPath 对应的布局属性。你马上就要复写 layoutAttributesForItemAtIndexPath(_:) 方法</li><li>5.将布局属性添加到数组当中</li><li>6.返回所有 cell 的布局属性</li></ul><h2>页面的几何运算</h2><p>在你实现 layoutAttributesForItemAtIndexPath(_:) 之前，花点时间来考虑布局，想想它该如何工作，我们是否能写一些工具方法来使得所有事情简单化、模块化。:]</p><img class="lazyload" data-src="/oldimages/VN_PaperRatioDiagram.png"/><p>上图显示书页的翻动是以书脊作为旋转轴。上图中的比例从-1.0到1.0变化。为什么？想象一下将一本书放在桌子上，书脊表示0.0，当你从左至右翻页时，翻转比率从-1.0（最左端）变到1.0（最右端）。 因此，你可以用如下比率来表示你的翻页过程：</p><ul><li>0.5表示页面成90度状态，与桌面垂直</li><li>+/- 0.5表示与桌面成45度</li><li>+/- 1.0表示与桌面平行</li></ul><p>因为旋转是逆时针的，角度符号与比率符号相反。（即正负符号相反） 首先将下面工具方法添加在 layoutAttributesForElementsInRect(_:) 之后：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-comment">//MARK: - Attribute Logic Helpers</span>
 
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFrame</span><span class="hljs-params">(collectionView: UICollectionView)</span></span> -&gt; <span class="hljs-type">CGRect</span> {
  <span class="hljs-keyword">var</span> frame = <span class="hljs-type">CGRect</span>()
 
  frame.origin.x = (collectionView.bounds.width / <span class="hljs-number">2</span>) - (<span class="hljs-type">PageWidth</span> / <span class="hljs-number">2</span>) + collectionView.contentOffset.x
  frame.origin.y = (collectionViewContentSize().height - <span class="hljs-type">PageHeight</span>) / <span class="hljs-number">2</span>
  frame.size.width = <span class="hljs-type">PageWidth</span>
  frame.size.height = <span class="hljs-type">PageHeight</span>
 
  <span class="hljs-keyword">return</span> frame
}
</code></pre><p>根据 collectionView 的中心为每一个页面计算其 frame。getFrame(_:) 方法会将每个页面边缘与书脊对其。改变的唯一变量是collectionView的内容在x方向偏移。 接下来，添加如下方法：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getRatio</span><span class="hljs-params">(collectionView: UICollectionView, indexPath: NSIndexPath)</span></span> -&gt; <span class="hljs-type">CGFloat</span> {
  <span class="hljs-comment">//1</span>
  <span class="hljs-keyword">let</span> page = <span class="hljs-type">CGFloat</span>(indexPath.item - indexPath.item % <span class="hljs-number">2</span>) * <span class="hljs-number">0.5</span>
 
  <span class="hljs-comment">//2</span>
  <span class="hljs-keyword">var</span> ratio: <span class="hljs-type">CGFloat</span> = -<span class="hljs-number">0.5</span> + page - (collectionView.contentOffset.x / collectionView.bounds.width)
 
  <span class="hljs-comment">//3</span>
  <span class="hljs-keyword">if</span> ratio &gt; <span class="hljs-number">0.5</span> {
    ratio = <span class="hljs-number">0.5</span> + <span class="hljs-number">0.1</span> * (ratio - <span class="hljs-number">0.5</span>)
 
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ratio &lt; -<span class="hljs-number">0.5</span> {
    ratio = -<span class="hljs-number">0.5</span> + <span class="hljs-number">0.1</span> * (ratio + <span class="hljs-number">0.5</span>)
  }
 
  <span class="hljs-keyword">return</span> ratio
}
</code></pre><p>上面方法计算页面的比率。下面是对每个注释的解释：</p><ul><li>1.计算页面在书本当中的编号，记住书页是双面的。乘以0.5可以得到你当前所在的页面。</li><li>2.根据你翻动的权重计算比率</li><li>3.需要将比率范围限制在-0.5到0.5之间。乘以0.1是用来给页面之间添加一个间距使得它们看起来是被遮盖一样。</li></ul><p>在你计算好比率之后，就可以用它来计算当前翻动的角度了。在上面代码后添加如下代码：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getAngle</span><span class="hljs-params">(indexPath: NSIndexPath, ratio: CGFloat)</span></span> -&gt; <span class="hljs-type">CGFloat</span> {
  <span class="hljs-comment">// Set rotation</span>
  <span class="hljs-keyword">var</span> angle: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">0</span>
 
  <span class="hljs-comment">//1</span>
  <span class="hljs-keyword">if</span> indexPath.item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> {
    <span class="hljs-comment">// The book's spine is on the left of the page</span>
    angle = (<span class="hljs-number">1</span>-ratio) * <span class="hljs-type">CGFloat</span>(-<span class="hljs-type">M_PI_2</span>)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">//2</span>
    <span class="hljs-comment">// The book's spine is on the right of the page</span>
    angle = (<span class="hljs-number">1</span> + ratio) * <span class="hljs-type">CGFloat</span>(<span class="hljs-type">M_PI_2</span>)
  }
  <span class="hljs-comment">//3</span>
  <span class="hljs-comment">// Make sure the odd and even page don't have the exact same angle</span>
  angle += <span class="hljs-type">CGFloat</span>(indexPath.row % <span class="hljs-number">2</span>) / <span class="hljs-number">1000</span>
  <span class="hljs-comment">//4</span>
  <span class="hljs-keyword">return</span> angle
}
</code></pre><p>这里进行了一些数学计算，但是拆开来看也不是很难：</p><ul><li>1.判断当前页面是否为双书面，即序号是否为2的倍数，也就是说它处在书脊的右边。向左翻动是逆时针，在书脊右侧的页面的角度是负的。回想一下之前定义的在-0.5到0.5变化的比率。</li><li>2.如果当前面是奇数，那么它就在书脊的左侧，向右翻动是顺时针，所以书脊左侧的页面角度为正。</li><li>3.为每个页面添加一个偏移角度</li><li>4.返回旋转角</li></ul><p>现在我们有了旋转角，我们需要转换每一个页面，添加如下代码：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makePerspectiveTransform</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">CATransform3D</span> {
  <span class="hljs-keyword">var</span> transform = <span class="hljs-type">CATransform3DIdentity</span>
  transform.m34 = <span class="hljs-number">1.0</span> / -<span class="hljs-number">2000</span>
  <span class="hljs-keyword">return</span> transform
}
</code></pre><p>修改 transform 中的<code>m34</code>来为每个页面增加透视。 现在是时候加上旋转效果了。加入如下代码：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getRotation</span><span class="hljs-params">(indexPath: NSIndexPath, ratio: CGFloat)</span></span> -&gt; <span class="hljs-type">CATransform3D</span> {
  <span class="hljs-keyword">var</span> transform = makePerspectiveTransform()
  <span class="hljs-keyword">var</span> angle = getAngle(indexPath, ratio: ratio)
  transform = <span class="hljs-type">CATransform3DRotate</span>(transform, angle, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)
  <span class="hljs-keyword">return</span> transform
}
</code></pre><p>该方法使用上面提到的两个工具方法来计算 transform 和 angle，然后创建了一个 CATransform3D并将其使用到页面的 y 轴上。 现在所有工具方法已准备就是，是时候为每个 cell撸一下布局属性了。在 layoutAttributesForElementsInRect(_:) 后面加入下面代码：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">layoutAttributesForItemAtIndexPath</span><span class="hljs-params">(indexPath: NSIndexPath)</span></span> -&gt; <span class="hljs-type">UICollectionViewLayoutAttributes!</span> {
  <span class="hljs-comment">//1</span>
  <span class="hljs-keyword">var</span> layoutAttributes = <span class="hljs-type">UICollectionViewLayoutAttributes</span>(forCellWithIndexPath: indexPath)
 
  <span class="hljs-comment">//2</span>
  <span class="hljs-keyword">var</span> frame = getFrame(collectionView!)
  layoutAttributes.frame = frame
 
  <span class="hljs-comment">//3</span>
  <span class="hljs-keyword">var</span> ratio = getRatio(collectionView!, indexPath: indexPath)
 
  <span class="hljs-comment">//4</span>
  <span class="hljs-keyword">if</span> ratio &gt; <span class="hljs-number">0</span> &amp;&amp; indexPath.item % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>
     || ratio &lt; <span class="hljs-number">0</span> &amp;&amp; indexPath.item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> {
    <span class="hljs-comment">// Make sure the cover is always visible</span>
    <span class="hljs-keyword">if</span> indexPath.row != <span class="hljs-number">0</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
    }
  }	
  <span class="hljs-comment">//5</span>
  <span class="hljs-keyword">var</span> rotation = getRotation(indexPath, ratio: <span class="hljs-built_in">min</span>(<span class="hljs-built_in">max</span>(ratio, -<span class="hljs-number">1</span>), <span class="hljs-number">1</span>))
  layoutAttributes.transform3D = rotation
 
  <span class="hljs-comment">//6</span>
  <span class="hljs-keyword">if</span> indexPath.row == <span class="hljs-number">0</span> {
    layoutAttributes.zIndex = <span class="hljs-type">Int</span>.<span class="hljs-built_in">max</span>
  }
 
  <span class="hljs-keyword">return</span> layoutAttributes
}
</code></pre><p>每个 cell 都会调用这个方法：</p><ul><li>1.为给定的 indexPath 创建一个 UICollectionViewLayoutAttributes</li><li>2.使用 getFrame 方法给布局属性设置 frame，来保证它会与书脊对齐</li><li>3.用之前的 getRatio 方法来设置布局属性的比率</li><li>4.判断当前页的比率是否在限制范围内，如果不在就不展示这个 cell。为了优化，通常不显示背面，只展示正面。当然如果是书的封面则需要一直展示。</li><li>5.根据计算得到比率来获取 rotation 和 transform</li><li>6.判断 indexPath 是否为第一页，如果是第一页则设置其 zIndex 让它显示在所有页面之上，避免闪现情况发生。</li></ul><p>运行程序，打开书本，翻动以下。。。what the f**k!!</p><img class="lazyload" data-src="/oldimages/misc-jackie-chan.png"/><p>页面的锚点貌似是 center 而不是边缘！</p><img class="lazyload" data-src="/oldimages/VN_Anchor1.png"/><p>如图所示，每个页面锚点坐标为（0.5,0.5）。你知道怎么解决这个问题吗？</p><img class="lazyload" data-src="/oldimages/VN_CorrectRatio.png"/><p>很明显，你需要改变锚点位置，使其位于边缘。如果页面在书脊的右侧，锚点应该为(0,0.5),反之锚点为(1,0.5)。</p><p>打开 BookPageCell.swift 添加如下代码：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">applyLayoutAttributes</span><span class="hljs-params">(layoutAttributes: UICollectionViewLayoutAttributes!)</span></span> {
  <span class="hljs-keyword">super</span>.applyLayoutAttributes(layoutAttributes)
  <span class="hljs-comment">//1</span>
  <span class="hljs-keyword">if</span> layoutAttributes.indexPath.item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> {
    <span class="hljs-comment">//2</span>
    layer.anchorPoint = <span class="hljs-type">CGPointMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>)
    isRightPage = <span class="hljs-literal">true</span>
    } <span class="hljs-keyword">else</span> { <span class="hljs-comment">//3</span>
      <span class="hljs-comment">//4</span>
      layer.anchorPoint = <span class="hljs-type">CGPointMake</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0.5</span>)
      isRightPage = <span class="hljs-literal">false</span>
    }
    <span class="hljs-comment">//5</span>
    <span class="hljs-keyword">self</span>.updateShadowLayer()
}
</code></pre><p>上面复写了 applyLayoutAttributes(_:) 方法，它使用了 BookLayout 中的布局属性。这看起来非常言简意赅。</p><ul><li>1.判读当前页面是否为双数，也就是当前页面在书脊右侧。</li><li>2.将锚点设置成左边缘，然后设置<code>isRightPage</code>为 true。这个变量可以帮你确定圆角的位置。</li><li>3。如果当前页面为奇数，那么它就处于书脊左侧</li><li>4.设置奇数页面的锚点为其右测边缘，然后设置<code>isRightPage</code>为 false</li><li>5.最后更新当前页的阴影 layer</li></ul><p>运行一下，翻动页面，看起来比之前好多了。</p><img class="lazyload" data-src="/oldimages/VN_CompletePart1.gif"/><p>到此为止，该教程的第一部分已经结束。花点时间休息一下，想想这个过程是不是很屌？！</p><h2>何去何从</h2><p>你可以<a href="https://koenig-media.raywenderlich.com/uploads/2015/05/Part-1-Paper-Completed.zip" target="_blank">在此</a>下载第一部分的完整代码。 你从默认的 layout 开始，然后学习了如何自定义一个新的 layout 然后创建了一个比较屌的效果！用这个 app 的人会觉得他们像在翻实体书一样。正是这样一个细节使得一个普通的阅读类软件变得深受用户欢迎。 然而，一切还没有结束。在<a href="/posts/How-to-Create-an-iOS-Book-Open-Animation-part-two-translation">第二部分</a>中你可以让这个 app 变得更好更简洁。 你是否也有很炫的布局想法？如果你有任何疑问、评论以及对这篇教程的其他想法，欢迎在下面讨论。</p>]]></content><tag>UICollectionView</tag><tag>翻译</tag></entry><entry><title>如何创建一个翻书动画(Part2)[译]</title><link href="/posts/How-to-Create-an-iOS-Book-Open-Animation-part-two-translation"/><url>/posts/How-to-Create-an-iOS-Book-Open-Animation-part-two-translation</url><content type="html"><![CDATA[<p>欢迎回到 iOS 翻书动画教程系列！在该系列的<a href="http://www.raywenderlich.com/94565/how-to-create-an-ios-book-open-animation-part-1" target="_blank">第一部分</a>(<a href="/posts/How-to-Create-an-iOS-Book-Open-Animation-part-one-translation">译文</a>，你已经知道如何创建自定义的 layout 以及如何在 app 中使用阴影效果来创建景深和模拟现实。在这篇教程中，你将学到如何创建一个自定义的转场以及如何使用 pinch 手势来打开书本。</p><blockquote><p>2019.11.21 update 本文中图片和资源相关链接可能已失效，如需查阅，请查看原文 感谢<a href="https://twitter.com/hegedus90" target="_blank">Attila Hegedüs</a>创建了这个棒棒哒示例工程。</p></blockquote><img class="lazyload" data-src="/oldimages/BookOpening.gif"/><p>原文：<a href="http://www.raywenderlich.com/?p=97690" target="_blank">How to Create an iOS Book Open Animation: Part 2</a></p><h2>开始</h2><p>这篇教程基于<a href="/posts/How-to-Create-an-iOS-Book-Open-Animation-part-one-translation">第一部分</a>。如果你不了解第一部分或者想重新开始，可以下载上一教程的<a href="https://koenig-media.raywenderlich.com/uploads/2015/05/Part-1-Paper-Completed.zip" target="_blank">完整代码</a>。</p><img class="lazyload" data-src="/oldimages/VN2_Start.gif"/><p>在 Xcode 中打开工程。现在你可以选择一本书，然后书本从右滑出(即 push)，这是 UINavigationController 的默认转场行为。但是在这片教程结束的时候，自定义转场看起来像这样：</p><img class="lazyload" data-src="/oldimages/VN_BookOpening.gif"/><p>自定义转场将在书本打开和合上的状态转换中进行丝滑的动画过渡，这种方式非常自然，深得我心。 来吧，骚年，开撸！</p><h2>创建自定义导航控制器</h2><p>想要实现自定义转场必须创建一个自定义的导航控制器然后实现 UINavigationControllerDelegate 协议。 右键 App 分组创建一个继承自 UINavigationController 名为 CustomNavigationController 的类。语言设置为 Swift。</p><p>打开CustomNavigationController.swift，用下面代码替换其内容：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-keyword">import</span> UIKit
 
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomNavigationController</span>: <span class="hljs-title">UINavigationController</span>, <span class="hljs-title">UINavigationControllerDelegate</span> </span>{
 
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">super</span>.viewDidLoad()
    <span class="hljs-comment">//1</span>
    delegate = <span class="hljs-keyword">self</span>
  }
 
  <span class="hljs-comment">//2</span>
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">navigationController</span><span class="hljs-params">(navigationController: UINavigationController, animationControllerForOperation operation: UINavigationControllerOperation, fromViewController fromVC: UIViewController, toViewController toVC: UIViewController)</span></span> -&gt; <span class="hljs-type">UIViewControllerAnimatedTransitioning?</span> {
    <span class="hljs-keyword">if</span> operation == .<span class="hljs-type">Push</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
    }
 
    <span class="hljs-keyword">if</span> operation == .<span class="hljs-type">Pop</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
    }
 
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
  }
}
</code></pre><p>上面代码主要做了两件事：</p><ul><li>1.在 viewDidLoad 方法中将代理设置为自身</li><li>2.navigationController(_:animationControllerForOperation:fromViewController:toViewController:) 方法是协议方法中的一个。这个方法在每次 push 或者 pop 的时候被调用，你可以在此返回对应的转场类型动画。现在这个方法返回 nil 使得其使用默认的标准转场。马上你就会用你自定义的转场类来替换它。</li></ul><p>既然导航控制器已经准备就绪，那么让我们开始来替换 storyboard 中默认的导航控制器</p><p>设置如下图所示：</p><img class="lazyload" data-src="/oldimages/VN_storyboard2.png"/><p>运行一下，确保能正常运行，一切正常，因为你在代理方法中返回 nil，导致控制器使用默认转场行为。</p><h2>创建自定义转场</h2><p>终于来到重头戏环节————撸一个自定义转场！ 在自定义转场类中，必须遵循 UIViewControllerAnimatedTransitioning 协议，特别是需要实现下面几个方法：</p><ul><li>transitionDuration：必须实现。返回转场动画时间，以及同步交互转场动画</li><li>animateTransition：必须实现。提供转场过程中的源控制器和目的控制器。自定义转场的工作重心主要是在这个方法中完成</li><li>animationEnded：可选实现。在转场结束时调用。可以在该方法中还原之前的设置</li></ul><h2>设置你的转场</h2><p>右键 App 分组新建一个继承自 NSObject 名为 BookOpeningTransition 的类，设置语言为 Swift。</p><p>打开它，然后用下面代码来替换其所有内容：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-keyword">import</span> UIKit
 
<span class="hljs-comment">//1</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookOpeningTransition</span>: <span class="hljs-title">NSObject</span>, <span class="hljs-title">UIViewControllerAnimatedTransitioning</span> </span>{
 
  <span class="hljs-comment">// MARK: Stored properties</span>
  <span class="hljs-keyword">var</span> transforms = [<span class="hljs-type">UICollectionViewCell</span>: <span class="hljs-type">CATransform3D</span>]() <span class="hljs-comment">//2</span>
  <span class="hljs-keyword">var</span> toViewBackgroundColor: <span class="hljs-type">UIColor?</span> <span class="hljs-comment">//3</span>
  <span class="hljs-keyword">var</span> isPush = <span class="hljs-literal">true</span> <span class="hljs-comment">//4</span>
 
  <span class="hljs-comment">//5</span>
  <span class="hljs-comment">// MARK: UIViewControllerAnimatedTransitioning</span>
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">transitionDuration</span><span class="hljs-params">(transitionContext: UIViewControllerContextTransitioning)</span></span> -&gt; <span class="hljs-type">NSTimeInterval</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
  }
 
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">animateTransition</span><span class="hljs-params">(transitionContext: UIViewControllerContextTransitioning)</span></span> {
 
  }
}
</code></pre><p>每个数字标号注释的解释：</p><ul><li>1.BookOpeningTransition 实现了 UIViewControllerAnimatedTransitioning 协议</li><li>2.字典 transforms 存储了键为 UICollectionViewCell 值为 CATransform3D类型的键值对。当书本打开时，它存储了每个 cell 的 transform</li><li>3.定义了目的控制器的背景色，使得渐变看起来更加清爽</li><li>4.isPush 决定了转场为 push 还是 pop</li><li>5.添加了协议中必须实现的方法避免编译器报错。紧接着就是要实现这些方法</li></ul><p>一切变量设置就绪，是时候来实现协议方法了。</p><p>用下面代码来替换 transitionDuration(_:) 中的内容：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-keyword">if</span> isPush {
  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
} <span class="hljs-keyword">else</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>
}
</code></pre><p>该方法返回了转场动画持续的时间，这里 pop 和 push都返回1秒。这个方法可以轻松改变转场动画的持续时间。 接下来需要实现第二个必须是闲的方法——animateTransition，这个方法让一切变得皆有可能。你将分两部分来实现：</p><p>写两个工具方法来分别实现 push 和 pop 的animateTransition。</p><h2>创建 push 转场</h2><p>回想一下实际生活中，你翻书的场景：</p><img class="lazyload" data-src="/oldimages/VN_PushStage.png"/><p>看起来很复杂，但是你只需要关心动画的两种状态，然后让 UIView 的 animateWithDuration 方法来实现两种状态之间的过渡：</p><ul><li>1.第一阶段：书被合上</li><li>2.第二阶段：书被打开</li></ul><p>在实现 animateTransition(_:) 前，首先写一个工具方法来处理两种状态。还是在 BookOpeningTransition.swift 中，在最后添加：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-comment">// MARK: Helper Methods</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makePerspectiveTransform</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">CATransform3D</span> {
  <span class="hljs-keyword">var</span> transform = <span class="hljs-type">CATransform3DIdentity</span>
  transform.m34 = <span class="hljs-number">1.0</span> / -<span class="hljs-number">2000</span>
  <span class="hljs-keyword">return</span> transform
}
</code></pre><p>该方法返回一个 transform，以及添加一个 z 轴上的透视。后面动画过程中你将会用到它来改变 view。</p><h3>第一阶段——书本合起</h3><p>接着在上述方法后面添加：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">closePageCell</span><span class="hljs-params">(cell : BookPageCell)</span></span> {
  <span class="hljs-comment">// 1</span>
  <span class="hljs-keyword">var</span> transform = <span class="hljs-keyword">self</span>.makePerspectiveTransform()
  <span class="hljs-comment">// 2</span>
  <span class="hljs-keyword">if</span> cell.layer.anchorPoint.x == <span class="hljs-number">0</span> {
    <span class="hljs-comment">// 3</span>
    transform = <span class="hljs-type">CATransform3DRotate</span>(transform, <span class="hljs-type">CGFloat</span>(<span class="hljs-number">0</span>), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)
    <span class="hljs-comment">// 4</span>
    transform = <span class="hljs-type">CATransform3DTranslate</span>(transform, -<span class="hljs-number">0.7</span> * cell.layer.bounds.width / <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)
    <span class="hljs-comment">// 5</span>
    transform = <span class="hljs-type">CATransform3DScale</span>(transform, <span class="hljs-number">0.7</span>, <span class="hljs-number">0.7</span>, <span class="hljs-number">1</span>)
   }
   <span class="hljs-comment">// 6</span>
   <span class="hljs-keyword">else</span> {
     <span class="hljs-comment">// 7</span>
     transform = <span class="hljs-type">CATransform3DRotate</span>(transform, <span class="hljs-type">CGFloat</span>(-<span class="hljs-type">M_PI</span>), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)
     <span class="hljs-comment">// 8</span>
     transform = <span class="hljs-type">CATransform3DTranslate</span>(transform, <span class="hljs-number">0.7</span> * cell.layer.bounds.width / <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)
     <span class="hljs-comment">// 9</span>
     transform = <span class="hljs-type">CATransform3DScale</span>(transform, <span class="hljs-number">0.7</span>, <span class="hljs-number">0.7</span>, <span class="hljs-number">1</span>)
    }
 
    <span class="hljs-comment">//10</span>
    cell.layer.transform = transform
}
</code></pre><p>我们对每一个页面做了转换使其与书脊对齐，然后翻页时围绕着个轴做旋转来达到真实的翻阅效果。首先你想要书本是合上状态。这个方法使得每个页面平铺在封面的底部。如下图所示：</p><img class="lazyload" data-src="/oldimages/VN2_ClosedState.png"/><p>我们来解释一下上面的代码：</p><ul><li>1.使用之前创建的工具方法初始化一个新的 transform</li><li>2.判断页面是否在书脊右侧</li><li>3.如果是右侧页面，设其角度为0，使其呈平铺状态</li><li>4.将页面居中并位于封面之下</li><li>5.使页面的x，y 均乘以0.7.如果你不知道为什么要乘以0.7，回想上一篇教程中你曾将封面缩小到0.7。</li><li>6.如果不是右侧页面，那就是左侧页面</li><li>7.设置左侧页面角度为180度。</li><li>8.使其位于封面之下，并居中</li><li>9.同5</li><li>10.设置 cell 的 transform</li></ul><p>现在添加如下代码到上面方法之前：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setStartPositionForPush</span><span class="hljs-params">(fromVC: BooksViewController, toVC: BookViewController)</span></span> {
  <span class="hljs-comment">// 1</span>
  toViewBackgroundColor = fromVC.collectionView?.backgroundColor
  toVC.collectionView?.backgroundColor = <span class="hljs-literal">nil</span>
 
  <span class="hljs-comment">//2</span>
  fromVC.selectedCell()?.alpha = <span class="hljs-number">0</span>
 
  <span class="hljs-comment">//3</span>
  <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> toVC.collectionView!.visibleCells() <span class="hljs-keyword">as</span>! [<span class="hljs-type">BookPageCell</span>] {
    <span class="hljs-comment">//4</span>
    transforms[cell] = cell.layer.transform
    <span class="hljs-comment">//5</span>
    closePageCell(cell)
    cell.updateShadowLayer()
    <span class="hljs-comment">//6</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> indexPath = toVC.collectionView?.indexPathForCell(cell) {
      <span class="hljs-keyword">if</span> indexPath.row == <span class="hljs-number">0</span> {
        cell.shadowLayer.opacity = <span class="hljs-number">0</span>
      }
    }
  }
}
</code></pre><p>该方法设置了第一阶段的转场。它同时使用两个 VC 来做动画：</p><ul><li>fromVC：即书单 VC</li><li>toVC：书页 VC</li></ul><p>相关解释：</p><ul><li>1.存储 BooksViewController 的 collectionView 的背景色，设置 BookViewController 中 collectionView 的背景色为 nil</li><li>2.隐藏选中书籍的封面，toVC 将会处理封面图片的呈现</li><li>3.遍历书本页面</li><li>4.保存每个 cell 打开状态下的transform</li><li>5.因为书本一开始是合上的，所以需要合上所有页面然后更新阴影层</li><li>6.最后忽略封面的阴影</li></ul><h3>第二阶端——打开书籍</h3><p>我们已经完成第一阶段的过渡转场，是时候撸一撸第二阶段的了。第二阶段是有闭合到打开的状态。</p><p>在 setStartPositionForPush(_:toVC:)) 方法下添加如下代码：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setEndPositionForPush</span><span class="hljs-params">(fromVC: BooksViewController, toVC: BookViewController)</span></span> {
  <span class="hljs-comment">//1</span>
  <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> fromVC.collectionView!.visibleCells() <span class="hljs-keyword">as</span>! [<span class="hljs-type">BookCoverCell</span>] {
    cell.alpha = <span class="hljs-number">0</span>
  }
 
  <span class="hljs-comment">//2</span>
  <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> toVC.collectionView!.visibleCells() <span class="hljs-keyword">as</span>! [<span class="hljs-type">BookPageCell</span>] {
    cell.layer.transform = transforms[cell]!
    cell.updateShadowLayer(animated: <span class="hljs-literal">true</span>)
  }
}
</code></pre><p>分析一下上面的代码：</p><ul><li>1.隐藏所有书的封面，因为我们将展示选中书籍的页面。</li><li>2.遍历所有页面然后加载之前保存的打开状态下的 transform</li></ul><p>当你从 BooksViewController push 到 BookViewController 之后，还原之前的一些设置。</p><p>加入以下代码：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cleanupPush</span><span class="hljs-params">(fromVC: BooksViewController, toVC: BookViewController)</span></span> {
  <span class="hljs-comment">// Add background back to pushed view controller</span>
  toVC.collectionView?.backgroundColor = toViewBackgroundColor
}
</code></pre><p>push 完成后将 BookViewController 的背景色设置为你之前保存的背景色，将下面所有东西都隐藏起来。</p><h2>实现开书转场</h2><p>上面所有工具方法已经整装待发，接着我们来实现 push 动画。将下面代码加到 animateTransition(_:) 中：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-comment">//1</span>
<span class="hljs-keyword">let</span> container = transitionContext.containerView()
<span class="hljs-comment">//2</span>
<span class="hljs-keyword">if</span> isPush {
  <span class="hljs-comment">//3</span>
  <span class="hljs-keyword">let</span> fromVC = transitionContext.viewControllerForKey(<span class="hljs-type">UITransitionContextFromViewControllerKey</span>) <span class="hljs-keyword">as</span>! <span class="hljs-type">BooksViewController</span>
  <span class="hljs-keyword">let</span> toVC = transitionContext.viewControllerForKey(<span class="hljs-type">UITransitionContextToViewControllerKey</span>) <span class="hljs-keyword">as</span>! <span class="hljs-type">BookViewController</span>
  <span class="hljs-comment">//4</span>
  container.addSubview(toVC.view)
 
  <span class="hljs-comment">// Perform transition</span>
  <span class="hljs-comment">//5</span>
  <span class="hljs-keyword">self</span>.setStartPositionForPush(fromVC, toVC: toVC)
 
  <span class="hljs-type">UIView</span>.animateWithDuration(<span class="hljs-keyword">self</span>.transitionDuration(transitionContext), delay: <span class="hljs-number">0.0</span>, usingSpringWithDamping: <span class="hljs-number">0.7</span>, initialSpringVelocity: <span class="hljs-number">0.7</span>, options: <span class="hljs-literal">nil</span>, animations: {
    <span class="hljs-comment">//6</span>
    <span class="hljs-keyword">self</span>.setEndPositionForPush(fromVC, toVC: toVC)
    }, completion: { finished <span class="hljs-keyword">in</span>
      <span class="hljs-comment">//7</span>
      <span class="hljs-keyword">self</span>.cleanupPush(fromVC, toVC: toVC)
      <span class="hljs-comment">//8</span>
      transitionContext.completeTransition(finished)
  })
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">//POP</span>
}
</code></pre><p>下面解释一下上面代码做了哪些事：</p><ul><li>1.获取容器视图，它在转场过程中充当父视图角色。</li><li>2.判断当前是执行 push 操作</li><li>3.获取 fromVC 和 toVC</li><li>4.将 toVC 加入到当前容器视图</li><li>5.设置闭合状态下 toVC 和 fromVC 的起始位置</li><li>6.从起始位置做动画，直到终点位置</li><li>7.还原设置</li><li>8.告知系统转场已完成</li></ul><h2>在导航控制器中使用 push 转场</h2><p>上面我们已经实现了 push 转场动画，是时候来使用它了。打开 BooksViewController.swift 将下面属性添加到类声明之后：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-keyword">var</span> transition: <span class="hljs-type">BookOpeningTransition?</span>
</code></pre><p>这个属性是转场类实例，它帮助你判断当前转场是 push 还是 pop。添加如下扩展：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">BooksViewController</span> </span>{
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">animationControllerForPresentController</span><span class="hljs-params">(vc: UIViewController)</span></span> -&gt; <span class="hljs-type">UIViewControllerAnimatedTransitioning?</span> {
  <span class="hljs-comment">// 1</span>
  <span class="hljs-keyword">var</span> transition = <span class="hljs-type">BookOpeningTransition</span>()
  <span class="hljs-comment">// 2</span>
  transition.isPush = <span class="hljs-literal">true</span>
  <span class="hljs-comment">// 3</span>
  <span class="hljs-keyword">self</span>.transition = transition
  <span class="hljs-comment">// 4</span>
  <span class="hljs-keyword">return</span> transition
  }
}
</code></pre><ul><li>1.创建一个 transition</li><li>2.设置 isPush 为 true</li><li>3&amp;4.保存当前 transition，返回 transition</li></ul><p>接着打开 CustomNavigationController.swift 用下面代码替换 push 的 if 判断</p><pre data-language="Swift" class="hljs"><code><span class="hljs-keyword">if</span> operation == .<span class="hljs-type">Push</span> {
  <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> vc = fromVC <span class="hljs-keyword">as</span>? <span class="hljs-type">BooksViewController</span> {
    <span class="hljs-keyword">return</span> vc.animationControllerForPresentController(toVC)
  }
}
</code></pre><p>这一步判断判断是否从 BooksViewController 中 push 过来的，然后用你创建的 BookOpeningTransition 来做转场展示你的 BookViewController。</p><p>运行，选中某本书你会看到，书本在开、合之间的动画非常顺畅。</p><img class="lazyload" data-src="/oldimages/VN_PushGlitch.gif"/><p>WTF...这货看起来没有动画？！</p><img class="lazyload" data-src="/oldimages/angry-desk-flip.png"/><p>它直接从闭合状态跳转到打开状态，不要慌，这是因为你还没有加载页面 cell。 导航控制器从 BooksViewController 过渡到 BookViewController，他们两个都是继承自 UICollectionViewController。UICollectionViewCell 没有在主线程中加载，所以没有动画过程。 你需要给 collectionView 足够的时间让它来加载所有的 cell。 打开 BooksViewController.swift 然后使用下面代码替换 openBook(_:)：</p><pre data-language="ObjectiveC" class="hljs"><code>func openBook(book: Book?) {
  let vc = storyboard?.instantiateViewControllerWithIdentifier(<span class="hljs-string">"BookViewController"</span>) as! BookViewController
  vc.book = selectedCell()?.book
  <span class="hljs-comment">//1</span>
  vc.view.snapshotViewAfterScreenUpdates(<span class="hljs-literal">true</span>)
  <span class="hljs-comment">//2</span>
  <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), { () -&gt; Void <span class="hljs-keyword">in</span>
    <span class="hljs-keyword">self</span>.navigationController?.pushViewController(vc, animated: <span class="hljs-literal">true</span>)
    <span class="hljs-keyword">return</span>
  })
}
</code></pre><p>下面说下是如何解决这个问题的：</p><ul><li>1.当转场要发生时告诉 BookViewController 去截取当前视图</li><li>2.确定是在主线程中 push，来给 cell 足够的时间进行加载</li></ul><p>运行程序，应该和下图类似：</p><img class="lazyload" data-src="/oldimages/VN_PushGlitchAnimate.gif"/><p>看起来更完美了。至此 push 的转场已经完成，继续撸 pop 的转场。</p><h2>实现 Pop 转场的工具方法</h2><p>pop 的过程和 push 过程刚好相反。第一阶段是书打开状态，第二阶段是书本闭合状态。</p><img class="lazyload" data-src="/oldimages/VN_PopState.png"/><p>打开 BookOpeningTransition.swift 添加如下代码：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-comment">// MARK: Pop methods</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setStartPositionForPop</span><span class="hljs-params">(fromVC: BookViewController, toVC: BooksViewController)</span></span> {
  <span class="hljs-comment">// Remove background from the pushed view controller</span>
  toViewBackgroundColor = fromVC.collectionView?.backgroundColor
  fromVC.collectionView?.backgroundColor = <span class="hljs-literal">nil</span>
}
</code></pre><p>该方法存储了 BookViewController 的背景色然后移除了 BooksViewController 中 collectionView 的背景色。我们不需要设置任何的 transform，因为书本当前状态就是打开状态。 接下来添加如下代码到上述代码之后：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setEndPositionForPop</span><span class="hljs-params">(fromVC: BookViewController, toVC: BooksViewController)</span></span> {
  <span class="hljs-comment">//1</span>
  <span class="hljs-keyword">let</span> coverCell = toVC.selectedCell()
  <span class="hljs-comment">//2</span>
  <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> toVC.collectionView!.visibleCells() <span class="hljs-keyword">as</span>! [<span class="hljs-type">BookCoverCell</span>] {
    <span class="hljs-keyword">if</span> cell != coverCell {
      cell.alpha = <span class="hljs-number">1</span>
    }
  }      
  <span class="hljs-comment">//3</span>
  <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> fromVC.collectionView!.visibleCells() <span class="hljs-keyword">as</span>! [<span class="hljs-type">BookPageCell</span>] {
    closePageCell(cell)
  }
}
</code></pre><p>该方法设置 pop 转场的最终状态：</p><ul><li>1.获取当前选中书本的封面</li><li>2.在书本闭合状态，遍历 BooksViewController 所有书本封面，然后渐显</li><li>3.遍历 BookViewController 中所有的 cell，然后将它们转换成闭合态</li></ul><p>然后加入以下代码：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cleanupPop</span><span class="hljs-params">(fromVC: BookViewController, toVC: BooksViewController)</span></span> {
  <span class="hljs-comment">// Add background back to pushed view controller</span>
  fromVC.collectionView?.backgroundColor = <span class="hljs-keyword">self</span>.toViewBackgroundColor
  <span class="hljs-comment">// Unhide the original book cover</span>
  toVC.selectedCell()?.alpha = <span class="hljs-number">1</span>
}
</code></pre><p>该方法在 pop 转场结束后做了一些还原工作。主要是将 BooksViewController 的 collectionView 的背景色还原成之前的状态，以及展示之前的书本封面。 把下面代码加到代理方法 animateTransition(_:) 中的 带有 <code>//POP</code> 注释的 else 大括号内。</p><pre data-language="Swift" class="hljs"><code><span class="hljs-comment">//1</span>
<span class="hljs-keyword">let</span> fromVC = transitionContext.viewControllerForKey(<span class="hljs-type">UITransitionContextFromViewControllerKey</span>) <span class="hljs-keyword">as</span>! <span class="hljs-type">BookViewController</span>
<span class="hljs-keyword">let</span> toVC = transitionContext.viewControllerForKey(<span class="hljs-type">UITransitionContextToViewControllerKey</span>) <span class="hljs-keyword">as</span>! <span class="hljs-type">BooksViewController</span>
 
<span class="hljs-comment">//2</span>
container.insertSubview(toVC.view, belowSubview: fromVC.view)
 
<span class="hljs-comment">//3</span>
setStartPositionForPop(fromVC, toVC: toVC)
<span class="hljs-type">UIView</span>.animateWithDuration(<span class="hljs-keyword">self</span>.transitionDuration(transitionContext), animations: {
  <span class="hljs-comment">//4</span>
  <span class="hljs-keyword">self</span>.setEndPositionForPop(fromVC, toVC: toVC)
}, completion: { finished <span class="hljs-keyword">in</span>
  <span class="hljs-comment">//5</span>
  <span class="hljs-keyword">self</span>.cleanupPop(fromVC, toVC: toVC)
  <span class="hljs-comment">//6</span>
  transitionContext.completeTransition(finished)
})
</code></pre><p>下面解释下 pop 转场动画的工作原理：</p><ul><li>1.获取转场过程中的控制器。fromVC 现在变成了 BookViewController，toVC 变成了 BooksViewController。</li><li>2.在 containerView 中把 BooksViewController 的视图放置到 BookViewController 视图下面。</li><li>3.setStartPositionForPop(_:toVC) 方法存储了背景色</li><li>4.用动画形式将书本有打开状态转换到闭合状态</li><li>5.动画完成则做还原设置，将背景色设置为之前保存的，然后显示书本封面</li><li>6.通知转场完成</li></ul><h2>在导航控制器中使用 pop 转场</h2><p>现在让我们像之前添加自定义 push 动画那样将 pop 动画也加入到代理方法中去。 打开 BooksViewController.swift 然后在 animationControllerForPresentController(_:) 方法后添加如下代码：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">animationControllerForDismissController</span><span class="hljs-params">(vc: UIViewController)</span></span> -&gt; <span class="hljs-type">UIViewControllerAnimatedTransitioning?</span> {
  <span class="hljs-keyword">var</span> transition = <span class="hljs-type">BookOpeningTransition</span>()
  transition.isPush = <span class="hljs-literal">false</span>
  <span class="hljs-keyword">self</span>.transition = transition
  <span class="hljs-keyword">return</span> transition
}
</code></pre><p>这个方法同样创建一个 BookOpeningTransition 实例，唯一不同的是其 transition 设置为 pop。 打开 CustomNavigationController.swift 用下面代码替换之前的 if 逻辑：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-keyword">if</span> operation == .<span class="hljs-type">Pop</span> {
  <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> vc = toVC <span class="hljs-keyword">as</span>? <span class="hljs-type">BooksViewController</span> {
    <span class="hljs-keyword">return</span> vc.animationControllerForDismissController(vc)
  }
}
</code></pre><p>它返回一个 transition，然后执行 pop 动画来把书合上。 运行程序，选中一本书，看下它的打开和闭合状态，应该和下图类似：</p><img class="lazyload" data-src="/oldimages/VN_OpenAndClose.gif"/><h2>创建一个可交互的导航控制器</h2><p>打开和关闭转场动画看起来非常屌，但是你可以做得更好。你可以使用 pinch 手势来控制书的开、合。 首先打开 BookOpeningTransition.swift 添加如下属性：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-comment">// MARK: Interaction Controller</span>
<span class="hljs-keyword">var</span> interactionController: <span class="hljs-type">UIPercentDrivenInteractiveTransition?</span>
</code></pre><p>接着打开 CustomNavigationController.swift 然后添加如下代码：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">navigationController</span><span class="hljs-params">(navigationController: UINavigationController, interactionControllerForAnimationController animationController: UIViewControllerAnimatedTransitioning)</span></span> -&gt; <span class="hljs-type">UIViewControllerInteractiveTransitioning?</span> {
  <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> animationController = animationController <span class="hljs-keyword">as</span>? <span class="hljs-type">BookOpeningTransition</span> {
    <span class="hljs-keyword">return</span> animationController.interactionController
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}
</code></pre><p>上述方法返回一个可交互的动画对象。它使得导航控制器控制着整个动画过程，这样用户就可以使用 pinch 手势来控制书本的开、合。 打开 BooksViewController.swift 在transition 变量下添加如下属性：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-comment">//1</span>
<span class="hljs-keyword">var</span> interactionController: <span class="hljs-type">UIPercentDrivenInteractiveTransition?</span>
<span class="hljs-comment">//2</span>
<span class="hljs-keyword">var</span> recognizer: <span class="hljs-type">UIGestureRecognizer?</span> {
  <span class="hljs-keyword">didSet</span> {
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> recognizer = recognizer {
      collectionView?.addGestureRecognizer(recognizer)
    }
  }
}
</code></pre><p>下面解释为什么要添加这几个变量：</p><ul><li>1.interactionController 是一个 UIPercentDrivenInteractiveTransition 实例，它管理 VC 转场过程中自定义动画的出现和消失。这个可交互控制器同样依赖一个 transition animator。这个 animator 实现了 UIViewControllerAnimatorTransitioning 协议，你刚才创建的 BookOpeningTransition 就是干这件事的。iteractionController 可以控制 push 和 pop 的过程，如果想要了解更多细节可以参考<a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIPercentDrivenInteractiveTransition_class/index.html#//apple_ref/occ/instm/UIPercentDrivenInteractiveTransition/cancelInteractiveTransition" target="_blank">苹果官方文档</a>。</li><li>2.recognizer 是一个 UIGestureRecognizer 实例。你可以使用它来控制书本的开、合。</li></ul><p>在 BooksViewController 扩展中的 animationControllerForPresentController(_:) 方法中添加如下代码，将其放在 transition.isPush = true 这一行之后：</p><pre data-language="Swift" class="hljs"><code>transition.interactionController = interactionController
</code></pre><p>这行代码让自定义导航控制器知道使用那一个交互控制器。 同样把上面在添加到 animationControllerForDismissController(_:) 方法中 transition.isPush = false 之后。 紧接着在 viewDidLoad() 中加入下面一行代码：</p><pre data-language="Swift" class="hljs"><code>recognizer = <span class="hljs-type">UIPinchGestureRecognizer</span>(target: <span class="hljs-keyword">self</span>, action: <span class="hljs-string">"handlePinch:"</span>)
</code></pre><p>它初始化了一个 UIPinchGestureRecognizer 实例，这个 pinch 手势的 action 是 handlePinch(_:)。</p><p>现在我们来实现 handlePinch(_:) 这个方法：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-comment">// MARK: Gesture recognizer action</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handlePinch</span><span class="hljs-params">(recognizer: UIPinchGestureRecognizer)</span></span> {
  <span class="hljs-keyword">switch</span> recognizer.state {
    <span class="hljs-keyword">case</span> .<span class="hljs-type">Began</span>:
      <span class="hljs-comment">//1</span>
      interactionController = <span class="hljs-type">UIPercentDrivenInteractiveTransition</span>()
      <span class="hljs-comment">//2</span>
      <span class="hljs-keyword">if</span> recognizer.scale &gt;= <span class="hljs-number">1</span> {
        <span class="hljs-comment">//3</span>
        <span class="hljs-keyword">if</span> recognizer.view == collectionView {
          <span class="hljs-comment">//4</span>
          <span class="hljs-keyword">var</span> book = <span class="hljs-keyword">self</span>.selectedCell()?.book
          <span class="hljs-comment">//5</span>
          <span class="hljs-keyword">self</span>.openBook(book)
        }
      <span class="hljs-comment">//6</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//7</span>
        navigationController?.popViewControllerAnimated(<span class="hljs-literal">true</span>)
      }        
    <span class="hljs-keyword">case</span> .<span class="hljs-type">Changed</span>:
      <span class="hljs-comment">//8</span>
      <span class="hljs-keyword">if</span> transition!.isPush {
        <span class="hljs-comment">//9</span>
        <span class="hljs-keyword">var</span> progress = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">max</span>(<span class="hljs-built_in">abs</span>((recognizer.scale - <span class="hljs-number">1</span>)) / <span class="hljs-number">5</span>, <span class="hljs-number">0</span>), <span class="hljs-number">1</span>)
        <span class="hljs-comment">//10</span>
	interactionController?.updateInteractiveTransition(progress)
	<span class="hljs-comment">//11</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//12</span>
	<span class="hljs-keyword">var</span> progress = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">max</span>(<span class="hljs-built_in">abs</span>((<span class="hljs-number">1</span> - recognizer.scale)), <span class="hljs-number">0</span>), <span class="hljs-number">1</span>)
        <span class="hljs-comment">//13</span>
	interactionController?.updateInteractiveTransition(progress)
      } 
    <span class="hljs-keyword">case</span> .<span class="hljs-type">Ended</span>:
      <span class="hljs-comment">//14</span>
      interactionController?.finishInteractiveTransition()
      <span class="hljs-comment">//15</span>
      interactionController = <span class="hljs-literal">nil</span>
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>
  }
}
</code></pre><p>对于 UIPinchGestureRecognizer，我们关心三种不同的状态：began，changed，end。</p><p><strong>begin状态</strong></p><ul><li>1.初始化一个 UIPercentDrivenInteractiveTransition 对象</li><li>2.判断 scale， 也就是 pinch 手势移动的距离，看起是否大于等于1</li><li>3.如果是，确保手势发生在 colletionView 当中</li><li>4.获取当前手势所作用的书脊</li><li>5.执行 push 转场动画，显示书籍页面</li><li>6.如果小于1</li><li>7.执行 pop 动画来展示书本封面</li></ul><p><strong>changed 状态</strong></p><ul><li>8.判断当前转场是否为 push</li><li>9.如果正 push 到 BookViewController，获取用户 pinch 手势的百分比。将 pinch 手势缩小为其原始值的 1/5，这样用户更加容易控制转场过程</li><li>10.根据之前计算的白封闭更新 transition 完成状态的百分比。</li><li>11.如果当前转场不是 push，那肯定是 pop</li><li>12.当使用 pinch 手势控制书本关闭时，缩放比一定是从1变到0</li><li>13.最后更新 transition 的进度</li></ul><p><strong>end 状态</strong></p><ul><li>14.通知系统用户转场交互已完成</li><li>15.将交互 controller 置为 nil</li></ul><p>最后，你需要实现 pinch-to-closed 状态。因此你需要将手势传递给 BookViewController，这样他就能自发进行 pop。</p><pre data-language="Swift" class="hljs"><code><span class="hljs-keyword">var</span> recognizer: <span class="hljs-type">UIGestureRecognizer?</span> {
  <span class="hljs-keyword">didSet</span> {
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> recognizer = recognizer {
      collectionView?.addGestureRecognizer(recognizer)
    }
  }
}
</code></pre><p>当你在 BookViewController 中设置好手势时，它会马上被加到 collectionView 中区，这样我们就可以在用户合上书本的时候追踪 pinch 手势。 下面需要在 BooksViewController 和 BookViewController 之间进行手势的传递。 打开 BookOpeningTransition.swift 添加下面一行代码到 cleanUpPush(_:toVC) 方法中，并且将它放在设置背景色之后：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-comment">// Pass the gesture recognizer</span>
toVC.recognizer = fromVC.recognizer
</code></pre><p>当从 BooksViewController push 到 BookViewController后，你需要将手势回传。 加入下面代码到 cleanUpPop(_:toVC) 方法中，同样是放在设置背景色之后：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-comment">// Pass the gesture recognizer</span>
toVC.recognizer = fromVC.recognizer
</code></pre><p>运行程序，选中任意一本书然后使用 pinch 手势来控制书本的开、合。</p><img class="lazyload" data-src="/oldimages/VN_Pinching.gif"/><p>用 pinch 收拾来控制书本的开合显得非常自然，同样可以让界面更加简洁，我们不再需要导航栏上的返回按钮，是时候来清理它了。</p><p>如下图设置即可：</p><img class="lazyload" data-src="/oldimages/Screen-Shot-2015-03-14-at-1.16.36-PM.png"/><p>继续运行，可以看到导航栏不复存在画面变得更加简洁！:]</p><img class="lazyload" data-src="/oldimages/VN_BookOpening.gif"/><h2>何去何从</h2><p>你可以在此下载<a href="https://koenig-media.raywenderlich.com/uploads/2015/05/Part-2-Paper-Completed_Final.zip" target="_blank">完整代码</a>。在这系列教程中，你学会了如何使用自定义布局、自定义转场、使用手势来控制转场交互。 我希望你喜欢这篇教程并从中受益，我想在此感谢<a href="https://twitter.com/hegedus90" target="_blank">Attila Hegedüs</a>创建了这个碉堡的项目。 如有任何疑问，请在下面留言指出。</p>]]></content><tag>UICollectionView</tag><tag>翻译</tag></entry><entry><title>WebView 与 JS 的交互</title><link href="/posts/Communication-Between-WebView-and-JS"/><url>/posts/Communication-Between-WebView-and-JS</url><content type="html"><![CDATA[<p>本文主要分析一些 iOS 中 WebView 与 JavaScript 交互的一些框架。</p><h3>UIWebView 调 JS 方法</h3><p>通过调用如下方法：</p><pre data-language="ObjectiveC" class="hljs"><code>- (<span class="hljs-built_in">NSString</span> *)stringByEvaluatingJavaScriptFromString:(<span class="hljs-built_in">NSString</span> *)script;
</code></pre><p>比如获取网页 title，也可以动态注入 JS，先写一个 JS 函数</p><pre data-language="JavaScript" class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showAlert</span>(<span class="hljs-params"></span>) </span>{  
    alert(<span class="hljs-string">'show alert'</span>);  
} 
</code></pre><p>然后保存为js 文件，最后读取这个文件并注入</p><pre data-language="ObjectiveC" class="hljs"><code><span class="hljs-built_in">NSString</span> *filePath = [[<span class="hljs-built_in">NSBundle</span> mainBundle] pathForResource:<span class="hljs-string">@"test"</span> ofType:<span class="hljs-string">@"js"</span>];  
<span class="hljs-built_in">NSString</span> *jsString = [[<span class="hljs-built_in">NSString</span> alloc] initWithContentsOfFile:filePath];  
[webView stringByEvaluatingJavaScriptFromString:jsString];
</code></pre><h3>JS 调原生方法</h3><p>直接调用无法做到，可以间接实现。</p><h4>方法1</h4><p>JS 中要从现在的网页跳到另外一个网页的时候，就会去修改 <code>window.location.href</code> ，而在 <code>@protocol UIWebViewDelegate</code> 中有一个回调方法</p><pre data-language="ObjectiveC" class="hljs"><code>- (<span class="hljs-built_in">BOOL</span>)webView:(<span class="hljs-built_in">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="hljs-built_in">NSURLRequest</span> *)request navigationType:(<span class="hljs-built_in">UIWebViewNavigationType</span>)navigationType;
</code></pre><p>可以监听到网页的跳转，所以可以在此做文章。 通过指定<code>window.location.href = schemename://nativemethodname:args</code>就可以去间接调用到原生函数。JS 一旦修改了<code>window.location.href</code>，<code>UIWebView</code>就会收到相应回调，也就是上面说的方法，这样我们可以通过判断<code> request</code>的<code>url</code>是否为自定义的 <code>scheme</code>来决定是否调用原生函数。</p><h4>方法2</h4><p>创建iframe，设置src，并插入到body节点</p><pre data-language="JavaScript" class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execute</span>(<span class="hljs-params">url</span>) 
</span>{
  <span class="hljs-keyword">var</span> iframe = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"IFRAME"</span>);
  iframe.setAttribute(<span class="hljs-string">"src"</span>, url);
  <span class="hljs-built_in">document</span>.documentElement.appendChild(iframe);
  iframe.parentNode.removeChild(iframe);
  iframe = <span class="hljs-literal">null</span>;
}
execute(<span class="hljs-string">"schemename://nativemethodname:args"</span>);
</code></pre><p>上述的这一串<code>schemename://nativemethodname:args</code>由客户端和前端约定好即可。剩余的事就是截获这个<code>request</code>，然后解析得到相应的参数，传入要调用的原生函数即可。同时在回调方法中要<code>return NO</code>。 大致代码如下：</p><pre data-language="ObjectiveC" class="hljs"><code>- (<span class="hljs-built_in">BOOL</span>)webView:(<span class="hljs-built_in">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="hljs-built_in">NSURLRequest</span> *)request navigationType:(<span class="hljs-built_in">UIWebViewNavigationType</span>)navigationType
{
    <span class="hljs-built_in">NSURL</span> *requestUrl = request.URL;
    <span class="hljs-keyword">if</span> ([requestUrl.scheme isEqualToString:<span class="hljs-string">@"schemename"</span>]) {
            <span class="hljs-built_in">NSArray</span> *components = [requestUrl.absoluteString componentsSeparatedByString:<span class="hljs-string">@":"</span>];
            <span class="hljs-built_in">NSString</span> *resultJSONString = [components[<span class="hljs-number">2</span>] stringByReplacingPercentEscapesUsingEncoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>];
            [<span class="hljs-keyword">self</span> customMethod:resultJsonString];
            <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;
        }
   <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;
}
</code></pre><h3>WebViewJavaScriptBridge</h3><img class="lazyload" data-src="/oldimages/2019-11-21-15743466661142.jpg"/><h4>实现原理</h4><p>大致原理与上面说的一致。只不过<code>WebViewJavaScriptBridge</code>进行了更完善的封装，使得 <code>JS</code>与<code>Native</code>之间的通信变得更为简便。</p><p>一开始注入<code>WebViewJavaScriptBridge.js</code>,该文件中的<code> JS</code>方法主要做了以下几件事</p><ul><li>创建了一个用于发送消息的iFrame(通过创建一个隐藏的<code>ifrmae</code>，并设置它的URL 来发出一个请求，从而触发UIWebView的<code>shouldStartLoadWithRequest</code>回调协议)</li><li>创建了一个核心对象<code>WebViewJavaScriptBridge</code>，并给它定义了几个方法，这些方法大部分是公开的API方法</li><li>创建了一个事件：<code>WebViewJavaScriptBridgeReady</code>，并<code>dispatch</code>。##</li></ul><p><code>native</code>将方法名、参数、回调的id放到一个对象中传给<code>js</code>。<code>js</code>根据方法名字调用相应方法，之后将返回数据和<code>responseId</code>拼装，最后通过<code>src</code> 重定向到<code>UIWebview</code> 的<code>delegate</code>。<code>native</code>得到数据后根据<code>responseId</code>调用事先装入<code>_responseCallbacks</code>的<code>block</code>，动态读取调用，从而完成交互。</p><h4>流程（Native端）</h4><h5>Public Interface</h5><pre data-language="ObjectiveC" class="hljs"><code>+ (<span class="hljs-keyword">instancetype</span>)bridgeForWebView:(WVJB_WEBVIEW_TYPE*)webView handler:(WVJBHandler)handler;
+ (<span class="hljs-keyword">instancetype</span>)bridgeForWebView:(WVJB_WEBVIEW_TYPE*)webView webViewDelegate:(WVJB_WEBVIEW_DELEGATE_TYPE*)webViewDelegate handler:(WVJBHandler)handler;
+ (<span class="hljs-keyword">instancetype</span>)bridgeForWebView:(WVJB_WEBVIEW_TYPE*)webView webViewDelegate:(WVJB_WEBVIEW_DELEGATE_TYPE*)webViewDelegate handler:(WVJBHandler)handler resourceBundle:(<span class="hljs-built_in">NSBundle</span>*)bundle;
+ (<span class="hljs-keyword">void</span>)enableLogging;
- (<span class="hljs-keyword">void</span>)send:(<span class="hljs-keyword">id</span>)message;
- (<span class="hljs-keyword">void</span>)send:(<span class="hljs-keyword">id</span>)message responseCallback:(WVJBResponseCallback)responseCallback;
- (<span class="hljs-keyword">void</span>)registerHandler:(<span class="hljs-built_in">NSString</span>*)handlerName handler:(WVJBHandler)handler;
- (<span class="hljs-keyword">void</span>)callHandler:(<span class="hljs-built_in">NSString</span>*)handlerName;
- (<span class="hljs-keyword">void</span>)callHandler:(<span class="hljs-built_in">NSString</span>*)handlerName data:(<span class="hljs-keyword">id</span>)data;
- (<span class="hljs-keyword">void</span>)callHandler:(<span class="hljs-built_in">NSString</span>*)handlerName data:(<span class="hljs-keyword">id</span>)data responseCallback:(WVJBResponseCallback)responseCallback;
</code></pre><h5>初始化一个 bridge</h5><p>初始化的工作主要如下：</p><ul><li>设置默认的消息处理 block ———— messageHandler</li><li>初始化用来保存消息处理 block 的字典 ———— messageHandlers</li><li>初始化消息队列数组 ———— startupMessageQueue</li><li>初始化响应回调 ———— responseCallbacks</li><li>以及初始化全局唯一标识 ———— uniqueId</li></ul><p>当在外部调用</p><pre data-language="ObjectiveC" class="hljs"><code>- (<span class="hljs-keyword">void</span>)registerHandler:(<span class="hljs-built_in">NSString</span> *)handlerName handler:(WVJBHandler)handler;
</code></pre><p>方法时，会将 handler 保存到上面初始化好的 messageHandlers 当中，key为上述方法中的 handlerName，value 为上述方法的 handler。</p><pre data-language="ObjectiveC" class="hljs"><code>- (<span class="hljs-keyword">void</span>)sendData:(<span class="hljs-keyword">id</span>)data responseCallback:(WVJBResponseCallback)responseCallback handlerName:(<span class="hljs-built_in">NSString</span>*)handlerName; 
</code></pre><p>发送消息时，会将消息加入到消息队列数组，加到数组当中的object 为字典型，字典有三个 key，分别为 data，callbackId， handlerName，分别对应上述方法的三个参数。入队时，如果当前消息队列存在，则将该消息入队，否则立即分发该消息。</p><h5>网页加载过程</h5><pre data-language="ObjectiveC" class="hljs"><code>- (<span class="hljs-built_in">BOOL</span>)webView:(<span class="hljs-built_in">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="hljs-built_in">NSURLRequest</span> *)request navigationType:(<span class="hljs-built_in">UIWebViewNavigationType</span>)navigationType;
</code></pre><p>加载请求或 html 时，在 shouldStartLoadWithRequest 回调中会先判断请求是否带自定义协议。如果带有自定义协议，会调用注入的 js 中 WebViewJavaScriptBridge 的_fetchQueue 方法来获取当前消息，然后分发该消息。主要是在分发消息这一块，拿到消息 json 然后序列化，如果这个消息是队列(数组)才进行处理，消息队列中也是一系列字典型对象，这些对象可能有这么几个key：responseId，responseData，callbackId，handlerName，data。 然后对消息队列做一个遍历大致逻辑如下：</p><ul><li>如果 responseId 对应的 value 存在，那么就到 responseCallbacks 字典中去寻找对应的 WVJBResponseCallback 型回调 block，然后执行，block 参数为 responseData 对应的 value。然后把这个 block 从 responseCallbacks 字典中移除。</li><li>如果 responseId 对应的 value 不存在，再看 callbackId 对应的 value 是否存在，存在则设置回调 responseCallback，这个 responseCallback 主要是创建一个消息，然后是消息入队，这个消息字典为 <code>@{ @"responseId":callbackId, @"responseData":responseData }</code>；反之 responseCallback 中什么也不执行；最后判断 handlerName 对应的 value 是否存在，存在则取 messageHandlers 中对应的回调 handler，不存在就是用默认的 handler，最后执行这个 WVJBHandler 型的 handler，参数为 data 对应的 value 以及 responseCallback。</li></ul><p>文字有点多，参考下下面这个流程图：</p><img class="lazyload" data-src="/oldimages/2019-11-21-15743466818699.jpg"/><pre data-language="ObjectiveC" class="hljs"><code>- (<span class="hljs-keyword">void</span>)webViewDidFinishLoad:(<span class="hljs-built_in">UIWebView</span> *)webView;
</code></pre><p>加载结束的回调中判断 js 是否初始化了 WebViewJavaScriptBridge实例，如果不存在，就注入本地的 js。然后检测到 bridge 调用自定义 scheme 后会分发整个消息队列即 startupMessageQueue，遍历消息队列然后取出每一个消息对象(NSDictionary) 然后将其序列化成 JSON，在主线程中调用 JS 的 WebViewJavaScriptBridge._handleMessageFromObjC 方法，参数就是序列化后的 JSON 数据。分发完成后，将 startupMessageQueue 队列置为 nil。</p><p>至此 OC 端的整个流程完毕。</p><h4>JS 端流程</h4><p>JS 端流程和 OC 端流程大致是一样的</p><h5>Public Interface</h5><pre data-language="JavaScript" class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span>(<span class="hljs-params">messageHandler</span>)
<span class="hljs-title">function</span> <span class="hljs-title">send</span>(<span class="hljs-params">data, responseCallback</span>)
<span class="hljs-title">function</span> <span class="hljs-title">registerHandler</span>(<span class="hljs-params">handlerName, handler</span>)
<span class="hljs-title">function</span> <span class="hljs-title">callHandler</span>(<span class="hljs-params">handlerName, data, responseCallback</span>)
<span class="hljs-title">function</span> <span class="hljs-title">_fetchQueue</span>(<span class="hljs-params"></span>)
<span class="hljs-title">function</span> <span class="hljs-title">_handleMessageFromObjC</span>(<span class="hljs-params">messageJSON</span>)</span>
</code></pre><h5>初始化</h5><p>类似 OC 中的初始化</p><ul><li>注入一个默认的 messageHandler</li><li>初始化一个消息接收队列，然后调用内部方法 _dispatchMessageFromObjC 来分发消息,同时将消息接收队列置空</li></ul><h5>发送消息</h5><p>调用内部 <code>function _doSend(message, responseCallback)</code> 函数，该函数通过判断 responseCallback 回调是否存在，存在则将这个回调存入到 responseCallbacks 字典中，其 key 是全局唯一的，同时将这个 key 存入到 message 这个字典参数中，其 key 和 value 一致，及 message['key'] = key。接着把这个 message 参数入队即加到 sendMessageQueue 数组中。然后重定向 frame 的 src，这样 OC 端就可以在代理回调方法中去拦截这个 src 对应的 request。</p><h5>消息处理机制</h5><p>如果消息接受队列存在则将消息 JSON 入队即添加到 receiveMessageQueue 数组中。反之，调用内部消息分发方法</p><pre data-language="JavaScript" class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_dispatchMessageFromObjC</span>(<span class="hljs-params">messageJSON</span>)</span>
</code></pre><p>分发机制类似 OC 端的那张流程图，在此不做详述。</p><h5>注册及调用 handler</h5><ul><li>注册：在 messageHandlers 这个字典添加对应的 key 和 value。key 为 name，value 为 handler</li><li>调用：类似发送消息，message 参数为 { handlerName:handlerName, data:data }</li></ul><h5>获取消息队列(供 OC 端调用)</h5><p>这里会将消息发送数组进行 JSON 转化，转换后清空消息队列，然后返回给 OC 端。</p><h5>内部注入的 JS</h5><p>上面说的所有都在内部注入的 JS(WebViewJavaScriptBridge.js.txt) 中完成,该 JS 做的事情在上述的实现原理中也有提到，这里不再展开。</p><h5>外部 html 或 js 需要处理的事</h5><p>可参考下例的写法：</p><pre data-language="JavaScript" class="hljs"><code><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'WebViewJavascriptBridgeReady'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
    <span class="hljs-keyword">var</span> bridge = event.bridge
    <span class="hljs-comment">// Start using the bridge</span>
}, <span class="hljs-literal">false</span>)
</code></pre><p>可将上述代码封装到一个 JS 函数中，然后在函数中进行其它一系列操作，如init，send 等具体参见 <a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank">Demo</a>。</p><h3>JavaScriptCore(iOS7 &amp; OS X 10.9 later)</h3><h4>主要的类:</h4><ul><li>JSVirtualMachine：非常轻量，可初始化多个 VM 来支持 JS 中的多线程</li><li>JSContext：给 JS 提供运行上下文环境以及一系列值操作(通过下标来获取，类似 NSdictionary，即context[@"objectKey"])，一个 VM 中可有多个 context</li><li>JSValue：数据桥梁</li><li>JSManagedValue：用于解决 retain cycle</li></ul><h4>OC 调用 JS</h4><p>JSContext 可调用 <code>evaluateScript:</code> 方法来执行某个脚本如下：</p><pre data-language="ObjectiveC" class="hljs"><code>[context evaluateScript:@”var square = function(x) {<span class="hljs-keyword">return</span> x*x;}”]; 
JSValue *squareFunction = context[@”square”]; <span class="hljs-built_in">NSLog</span>(@”%@”, squareFunction);  <span class="hljs-comment">// function (x) {return x*x;}</span>
JSValue *aSquared = [squareFunction callWithArguments:@[context[@”a”]]]; <span class="hljs-built_in">NSLog</span>(@”a^<span class="hljs-number">2</span>: %@”, aSquared); <span class="hljs-comment">//a^2: 25</span>
JSValue *nineSquared = [squareFunction callWithArguments:@[@<span class="hljs-number">9</span>]]; 
<span class="hljs-built_in">NSLog</span>(@”<span class="hljs-number">9</span>^<span class="hljs-number">2</span>: %@”, nineSquared); <span class="hljs-comment">//81</span>
</code></pre><h4>JS 调用 OC</h4><p>两种方式：</p><ul><li>Block</li><li>JSExport 协议</li></ul><h5>Block</h5><pre data-language="ObjectiveC" class="hljs"><code>context[<span class="hljs-string">@"factorial"</span>] = ^(<span class="hljs-keyword">int</span> x) {
        <span class="hljs-keyword">int</span> factorial = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (; x &gt; <span class="hljs-number">1</span>; x--) {
            factorial *= x;
        }
        <span class="hljs-keyword">return</span> factorial;
    };
[context evaluateScript:<span class="hljs-string">@"var fiveFactorial = factorial(5);"</span>];
JSValue *fiveFactorial = context[<span class="hljs-string">@"fiveFactorial"</span>];
<span class="hljs-comment">// 5! = 120</span>
<span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"5! = %@"</span>, fiveFactorial);
</code></pre><p>值得注意的是：</p><ul><li>不要在 block 中持有 JSValue，而是应该将JSValue 作为参数来传递</li><li>不要在 block 中持有 JSContext，可通过 <code>[JSContext currentContext]</code>来获取当前 context</li></ul><pre data-language="ObjectiveC" class="hljs"><code>JSContext *context = [[JSContext alloc] init];
context[<span class="hljs-string">@"callback"</span>] = ^{
	<span class="hljs-comment">//错误示例 </span>
     JSValue *object = [JSValue valueWithNewObjectInContext:context];
     <span class="hljs-comment">//正确的姿势</span>
     JSValue *object = [JSValue valueWithNewObjectInContext:
        [JSContext currentContext]];
     object[<span class="hljs-string">@"x"</span>] = <span class="hljs-number">2</span>;
     object[<span class="hljs-string">@"y"</span>] = <span class="hljs-number">3</span>;
     <span class="hljs-keyword">return</span> object;
};
</code></pre><h5>JSExport 协议</h5><p>如果没有这个协议，OC 端的修改会同步到 JS 端，但是 JS 端的修改对 JS 和 OC 均无影响。见下例</p><pre data-language="ObjectiveC" class="hljs"><code><span class="hljs-comment">//TestModel.m</span>
- (<span class="hljs-built_in">NSString</span> *)description
{
    <span class="hljs-built_in">NSString</span> *str = [<span class="hljs-string">@"TestModel With testString:"</span> stringByAppendingString:<span class="hljs-keyword">self</span>.testString];
    <span class="hljs-keyword">return</span> [str stringByAppendingString:[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@" and numberStr:%@"</span>,<span class="hljs-keyword">self</span>.numberStr]];
}

<span class="hljs-comment">// viewDidLoad</span>
TestModel *model = [[TestModel alloc] init];
model.testString = <span class="hljs-string">@"test string"</span>;
model.numberStr = <span class="hljs-string">@"123"</span>;
JSContext *context = [[JSContext alloc] initWithVirtualMachine:[[JSVirtualMachine alloc] init]];
context[<span class="hljs-string">@"model"</span>] = model;
JSValue *modelValue = context[<span class="hljs-string">@"model"</span>];
<span class="hljs-comment">// model: TestModel With testString:test string and numberStr:123</span>
<span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"model: %@"</span>,model);
<span class="hljs-comment">// model JSValue: TestModel With testString:test string and numberStr:123</span>
<span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"model JSValue: %@"</span>,modelValue);
model.numberStr = <span class="hljs-string">@"456"</span>;
<span class="hljs-comment">// model: TestModel With testString:test string and numberStr:456</span>
<span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"model: %@"</span>,model);
<span class="hljs-comment">// model JSValue: TestModel With testString:test string and numberStr:456</span>
<span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"model JSValue: %@"</span>,modelValue);
[context evaluateScript:<span class="hljs-string">@"model.testString = \"anotoher test\";model.numberStr = \"789\""</span>];
<span class="hljs-comment">// model: TestModel With testString:test string and numberStr:456</span>
<span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"model: %@"</span>,model);
<span class="hljs-comment">// model JSValue: TestModel With testString:test string and numberStr:456</span>
<span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"model JSValue: %@"</span>,modelValue);
</code></pre><p>如果想要上述 JS 修改起作用,则需要实现 JSExport 协议。 通过实现该协议来暴露自定义类给 JS，这样 JS 会为这个类创建一个 wrapper object，这样看起来就像 OC 和 JS 在互相传值一样。这样，一个对象可以在 JS 和 OC 间共享，任何一端的更改都将同步到另外一端。需要注意的是，JS 只能修改暴露在协议中的属性或调用协议中的方法。</p><pre data-language="ObjectiveC" class="hljs"><code><span class="hljs-comment">// .h</span>
<span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">TestModelDelegate</span> &lt;<span class="hljs-title">JSExport</span>&gt;</span>

<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *testString;
- (<span class="hljs-keyword">void</span>)modelTest;

<span class="hljs-keyword">@end</span>

<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">TestModel</span> : <span class="hljs-title">NSObject</span> &lt;<span class="hljs-title">TestModelDelegate</span>&gt;</span>

<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *testString;
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *numberStr;

<span class="hljs-keyword">@end</span>

<span class="hljs-comment">// .m</span>

- (<span class="hljs-built_in">NSString</span> *)description
{
    <span class="hljs-built_in">NSString</span> *str = [<span class="hljs-string">@"TestModel With testString:"</span> stringByAppendingString:<span class="hljs-keyword">self</span>.testString];
    <span class="hljs-keyword">return</span> [str stringByAppendingString:[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@" and numberStr:%@"</span>,<span class="hljs-keyword">self</span>.numberStr]];
}

- (<span class="hljs-keyword">void</span>)modelTest
{
    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"modelTest!!!"</span>);
}

- (<span class="hljs-keyword">void</span>)test
{
    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"Test!!!"</span>);
}

<span class="hljs-comment">// viewDidLoad</span>
[context evaluateScript:<span class="hljs-string">@"model.testString = \"anotoher test\";model.numberStr = \"567\""</span>];
<span class="hljs-comment">// model: TestModel With testString:anotoher test and numberStr:123</span>
<span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"model: %@"</span>,model);
<span class="hljs-comment">// model JSValue: TestModel With testString:anotoher test and numberStr:123</span>
<span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"model JSValue: %@"</span>,modelValue);
<span class="hljs-comment">// modelTest!!!</span>
[context evaluateScript:<span class="hljs-string">@"model.modelTest()"</span>];
JSValue *unknowValue = [context evaluateScript:<span class="hljs-string">@"model.test()"</span>];
<span class="hljs-comment">// unknowValue :undefined</span>
<span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"unknowValue :%@"</span>,unknowValue);
</code></pre><p>上例中的 numberStr 之所以还是保持为 123 是因为，这个属性不在协议中，JS 对其修改不起作用，同样如果 JS 中调用 model 不在协议中的方法，也不起作用，如果用 JSValue 去接收这个值，其值为 undefined。 没有任何响应，如果用一个 JSValue 去接收上面代码的值，得到的是 undifine</p><h5>对象对应关系</h5><p>Objective-C type | JavaScript type --------------------|--------------------- nil | undefined NSNull | null NSString | string NSNumber | number, boolean NSDictionary | Object object NSArray | Array object NSDate | Date object NSBlock | Function object id | Wrapper object Class | Constructor object</p><h4>UIWebView 与 JavaScriptCore 的交互</h4><p>UIWebview 也有一个 JSContext 实例，但是没有暴露在 API 中，但是我们可以通过 KVC 或者在 NSObject 分类去拿到这个实例，然后来进行自定义的一些操作。关于 NSObject 分类实现可以参考<a href="http://stackoverflow.com/questions/18920536/why-use-javascriptcore-in-ios7-if-it-cant-access-a-uiwebviews-runtime" target="_blank">这里</a>。但是这两种方法都有可能被拒。</p><p>其实WebView 与 JS 的交互和上述的 TestModel 与 JS 交互区别不大。只不过上例都是自己创建的 context，而在webView 中则是我们通过 KVC 来拿到这个 context 而不是自己创建。来看一个例子：</p><pre data-language="html" class="hljs"><code><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span><span class="hljs-params">()</span>
            </span>{
                objcObject.testDemo();
                alert(objcObject);
            }
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>JavaScriptCore Demo<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"test()"</span>&gt;</span>测试<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre><p>上述 html 简单创建了一个 button，然后绑定一个事件。 接下来看看 ViewController 里面做了什么。</p><pre data-language="ObjectiveC" class="hljs"><code><span class="hljs-comment">// .h</span>
<span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">TestJSDelegate</span> &lt;<span class="hljs-title">JSExport</span>&gt;</span>

- (<span class="hljs-keyword">void</span>)testDemo;

<span class="hljs-keyword">@end</span>

<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">WebViewController</span> : <span class="hljs-title">UIViewController</span> &lt;<span class="hljs-title">TestJSDelegate</span>,<span class="hljs-title">UIWebViewDelegate</span>&gt;</span>

<span class="hljs-keyword">@end</span>

<span class="hljs-comment">// .m</span>
- (<span class="hljs-keyword">void</span>)viewDidLoad
{
    [<span class="hljs-keyword">super</span> viewDidLoad];
    <span class="hljs-built_in">NSURL</span> *path = [[<span class="hljs-built_in">NSBundle</span> mainBundle] URLForResource:<span class="hljs-string">@"test"</span> withExtension:<span class="hljs-string">@"html"</span>];
    <span class="hljs-built_in">NSString</span> *html = [<span class="hljs-built_in">NSString</span> stringWithContentsOfURL:path encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span> error:<span class="hljs-literal">nil</span>];
    [<span class="hljs-keyword">self</span>.webView loadHTMLString:html baseURL:<span class="hljs-literal">nil</span>];
}
- (<span class="hljs-keyword">void</span>)webViewDidFinishLoad:(<span class="hljs-built_in">UIWebView</span> *)webView
{
	JSContext *context = [webView valueForKeyPath:<span class="hljs-string">@"documentView.webView.mainFrame.javaScriptContext"</span>];
    context[<span class="hljs-string">@"objcObject"</span>] = <span class="hljs-keyword">self</span>;
}

- (<span class="hljs-keyword">void</span>)testDemo
{
    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"test!!!"</span>);
}
</code></pre><p>运行效果:</p><img class="lazyload" data-src="/oldimages/2019-11-21-15743467085275.jpg"/><img class="lazyload" data-src="/oldimages/2019-11-21-15743467192938.jpg"/><p>如果协议方法中有多个参数该怎么调用呢？举个例子</p><pre data-language="ObjectiveC" class="hljs"><code><span class="hljs-comment">// ObjC 中的某个协议方法</span>
- (<span class="hljs-keyword">void</span>)testWithName:(<span class="hljs-built_in">NSString</span> *)name age:(<span class="hljs-built_in">NSNumber</span> *)age
{
    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"name:%@,age:%@"</span>,name,age);
}
</code></pre><pre data-language="Html" class="hljs"><code>// 在上述 html 的 js 中添加一行代码
objcObject.testWithNameAge("Tracy",20);
</code></pre><p>那么在按钮点击后，协议方法将会被执行，然后打印出 <code>name:Tracy,age:20</code>。</p><h4>内存管理</h4><p>OC 中是用的是 ARC，JavaScriptCore 中用的是垃圾回收机制（garbage collection）,JavaScriptCore 中所有引用都为强引用。在大部分情况下，JavaScriptCore 能做到在这两种内存管理机制之间无缝切换，但是在以下两种情况下需要特别注意：</p><ul><li>在 OC 对象中存储 JavaScript 值</li><li>在 OC 对象中添加 JavaScript 域</li></ul><p>如下例就会造成循环引用：</p><pre data-language="JavaScript" class="hljs"><code><span class="hljs-comment">// ClickHandler 构造器，button 为 OC 对象，callback 是按钮点击事件回调</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ClickHandler</span>(<span class="hljs-params">button, callback</span>) </span>{
     <span class="hljs-keyword">this</span>.button = button;
     <span class="hljs-keyword">this</span>.button.onClickHandler = <span class="hljs-keyword">this</span>;
     <span class="hljs-keyword">this</span>.handleEvent = callback;
};
</code></pre><pre data-language="ObjectiveC" class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MyButton</span></span>
- (<span class="hljs-keyword">void</span>)setOnClickHandler:(JSValue *)handler
{
     _onClickHandler = handler; <span class="hljs-comment">// Retain cycle</span>
}
<span class="hljs-keyword">@end</span>
</code></pre><p>上例中 ClickHandler 对 button 进行了强引用，而 MyButton 中又对 _onClickHandler 这个 JSValue 进行了强引用，最终导致循环引用，如下图所示：</p><img class="lazyload" data-src="/oldimages/2019-11-21-15743467542111.jpg"/><p>如果将 _onClickHandler 设置为 weak，那么我们将收不到点击事件回调。</p><p>举个栗子，在某个方法中有一个临时的 OC 对象，然后通过 JSContext 被 JS 中的变量引用，但是该 OC 方法调用结束后，这个临时对象将被释放，因此 JS 会造成错误访问。 同样的，如果用 JSContext 创建了对象，然后在 OC 中用 JSValue 去接收，即使把 JSValue 变量在 OC 中被 retain，但可能因为 JS 中因为变量没有了引用而被释放内存，那么对应的JSValue也没有用了。</p><p>所以苹果引入了另一个类来解决这种循环引用的问题。</p><pre data-language="ObjectiveC" class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MyButton</span></span>
- (<span class="hljs-keyword">void</span>)setOnClickHandler:(JSValue *)handler
{
	<span class="hljs-comment">//正确的姿势</span>
     _onClickHandler = [JSManagedValue managedValueWithValue:handler];
     [_context.virtualMachine addManagedReference:_onClickHandler
                                        withOwner:<span class="hljs-keyword">self</span>]
} 
<span class="hljs-keyword">@end</span>
</code></pre><p><code>addManagedReference</code>做的事情主要如下：它创建了一个 garbage collected reference，这种引用既不是强引用也不是弱引用。</p><img class="lazyload" data-src="/oldimages/2019-11-21-15743467654320.jpg"/><p>JSManagedValue 本身是一个对 JavaScript Value 的弱引用，而 JSValue 是强引用。addManagedReference 将 JSManagedValue 转换为 garbage collected reference。如果 JS 在垃圾回收过程中能够找到 managed reference 的所有者，那么这个引用将不会被释放，否则将被释放。JSManagedValue 需要调用其addManagedReference:withOwner: 方法把它添加到JSVirtualMachine 中，确保使用过程中 JSValue 不会被释放。</p><h4>多线程</h4><p>如前面所说，每一个 JSVirtualMachine 都可以有多个 JScontext，在每个进程中又可以有多个 JSVirtualMachine。JSValue 可以在同一个 JSVirtualMachine 中的不同 JSContext 之间传递，但是不能跨 JSVirtualMachine 来传递。因为每个 JSVirtualMachine 都有自己的内存堆以及垃圾回收器，如果 JSValue 跨 JSVirtualMachine 传递，那么垃圾回收器将不知如何处理来自不同内存堆的 JSvalue。</p><ul><li>JavaScriptCore 的 API 是线程安全的</li><li>同步锁粒度：JSVirtualMachine，即我们可以在 JSVirtualMachine 不同线程中调用 JS，但是如果有线程正在执行 JS，那么其它线程将不能执行 JS 操作。所以要想进行并发操作，那么需要为每个操作创建一个单独的 JSVirtualMachine 来实现并发。</li></ul><h3>WKWebView (iOS8 and later)</h3><h4>新特性</h4><ul><li>在性能、稳定性、功能方面有很大提升（最直观的体现就是加载网页是占用的内存）；</li><li>允许JavaScript的Nitro库加载并使用（UIWebView中限制）；</li><li>支持了更多的HTML5特性以及 native 和 web 的高效交互；</li><li>高达60fps的滚动刷新率以及内置手势；</li><li>将UIWebViewDelegate与UIWebView重构成了14类与3个协议</li></ul><p>WebKit 为非线程安全的，所以要确保该 framework 的所有方法在主线程上调用。</p><p>更多内容请参考<a href="http://nshipster.cn/wkwebkit/" target="_blank">Nshipster</a>。</p><h3>总结</h3><p>总得来说两种方式都可以实现二者的交互，JavaScriptBridge 相对而言复杂一些，但是安全且不需要做版本适配，APP 上架不会被拒，但是 JavaScriptCore 更加简洁，不需要写繁琐的代码，但是有被拒的风险，同时这个框架是在 iOS7 之后才有，所以如果要适配 iOS6的话还是选择 JavaScriptBridge。</p><p>本文 <a href="https://github.com/wang9262/WebViewJSDemo" target="_blank">Demo</a></p>]]></content><tag>WebView</tag><tag>原创</tag></entry><entry><title>iOS Animations by Tutorials 2.0 笔记</title><link href="/posts/Note-for-iOS-Animations-by-Tutorials"/><url>/posts/Note-for-iOS-Animations-by-Tutorials</url><content type="html"><![CDATA[<p>这本书主要分成七个部分，二十七个章节，涵盖了从底层的 Core Animation 到上层的 UIView 的动画封装，AutoLayout 动画以及 ViewController 之间的转场动画。最后选择了两个开源动画库（<a href="https://github.com/icanzilb/EasyAnimation" target="_blank">Easy Animation</a>、<a href="https://github.com/facebook/pop" target="_blank">pop</a>）进行实践。本篇文章主要是在阅读、学习过程中的一些笔记，留下记录，日后忘记可以再来翻看。</p><h2>Section Ⅰ View Animation</h2><p>这部分主要是关于 UIView 的动画，UIView 层次的动画是一些经过封装的上层 API，简单但是实用。基本都是日常用到的，比如位置、大小、透明度、旋转、关键帧动画等等，所以没啥好记录的。</p><h4>View 之间的过渡转场</h4><p>主要是使用如下两个方法:</p><pre data-language="ObjectiveC" class="hljs"><code>+ (<span class="hljs-keyword">void</span>)transitionWithView:(<span class="hljs-built_in">UIView</span> *)view duration:(<span class="hljs-built_in">NSTimeInterval</span>)duration options:(<span class="hljs-built_in">UIViewAnimationOptions</span>)options animations:(<span class="hljs-keyword">void</span> (^ __<span class="hljs-keyword">nullable</span>)(<span class="hljs-keyword">void</span>))animations completion:(<span class="hljs-keyword">void</span> (^ __<span class="hljs-keyword">nullable</span>)(<span class="hljs-built_in">BOOL</span> finished))completion <span class="hljs-built_in">NS_AVAILABLE_IOS</span>(<span class="hljs-number">4</span>_0);

<span class="hljs-comment">// toView added to fromView.superview, fromView removed from its superview</span>
+ (<span class="hljs-keyword">void</span>)transitionFromView:(<span class="hljs-built_in">UIView</span> *)fromView toView:(<span class="hljs-built_in">UIView</span> *)toView duration:(<span class="hljs-built_in">NSTimeInterval</span>)duration options:(<span class="hljs-built_in">UIViewAnimationOptions</span>)options completion:(<span class="hljs-keyword">void</span> (^ __<span class="hljs-keyword">nullable</span>)(<span class="hljs-built_in">BOOL</span> finished))completion <span class="hljs-built_in">NS_AVAILABLE_IOS</span>(<span class="hljs-number">4</span>_0); 
</code></pre><h2>Section Ⅱ Auto Layout</h2><p>这部分主要是 Auto Layout 的相关动画，首先基本介绍了它的使用，然后通过同一个 Demo 层层递进。总得来说，不管是手写还是 IB,布局虽然看似静态的，但是它也是能做动画的。</p><p>这一部分的动画，无非就是改了约束，然后把 <code>[view layoutIfNeeded]</code> 放到动画 block 里面。不过在这里学会了一招，就是在 IB 里面可以为约束设置标识（identifier）有点类似于 view 的 tag。</p><h2>Section Ⅲ Layer Animation</h2><p>这一部分通过几个 Demo 来着重介绍 CALayer 及其几个常用的子类、CAAnimation 及其子类。其中使用 CAShapeLayer、CAGradientLayer、CAReplicatorLayer 的实例都比较有趣。 当 UIView 的那一套动画 API 已经无法满足需要时，这个时候应该转向更为底层的 Core Animation。UIView 的那一套动画 API 归根结底也是对 Core Animation 的封装。说白了，UIView 是 CALyaer 的 delegate.两者的具体区别如下:</p><table><thead><tr><th align="center">UIView</th><th align="center">CALayer</th></tr></thead><tbody><tr><td align="center">拥有复杂的视图布局及层级等</td><td align="center">较简单的层级结构，所以能快速布局及绘制</td></tr><tr><td align="center">可交互</td><td align="center">不可交互</td></tr><tr><td align="center">利用 CPU 在主线程做一些自定义绘制及其它逻辑</td><td align="center">默认没有自定义逻辑，直接使用 GPU 绘制及缓存</td></tr><tr><td align="center">灵活、实用</td><td align="center">-</td></tr></tbody></table><p>这里作者给出了选择 UIView 还是 Core Animation 来做动画的一些建议：</p><blockquote><p>choose view animations any time you can to do the job; you will know when you need more performance or flexibility and have to switch to layer animations instead.Don’t stress yourself about it though, because you can mix and match view and layer animations freely.</p></blockquote><p>简单来说就是在 UIView 满足需求的时候尽量使用 UIView，当追求更好的性能及灵活性时可以考虑使用 Core Animation.当然，两者也可以混合使用。</p><h4>fillMode</h4><p>这里借用书中的几张图来阐明一下各种模式</p><ul><li><strong>kCAFillModeRemoved</strong></li></ul><p>默认模式：动画执行完毕后恢复原样</p><img class="lazyload" data-src="/oldimages/QQ20160826-0@2x.png" alt="QQ20160826-0@2x"/><ul><li><strong>kCAFillModeBackwards</strong></li></ul><p>动画开始前展示第一帧 <img class="lazyload" data-src="/oldimages/QQ20160826-1@2x.png" alt="QQ20160826-1@2x"/></p><ul><li><strong>kCAFillModeForwards</strong></li></ul><p>动画结束后 layer 维持最后一帧的状态</p><img class="lazyload" data-src="/oldimages/QQ20160826-2@2x.png" alt="QQ20160826-2@2x"/><ul><li><strong>kCAFillModeBoth</strong></li></ul><p>是上面两种模式的结合，动画开始前维持第一帧，动画结束后维持最后一帧</p><img class="lazyload" data-src="/oldimages/QQ20160826-3@2x.png" alt="QQ20160826-3@2x"/><h4>Layer 弹性动画</h4><p>这一节以钟摆举例，来解释弹性阻尼动画的相关属性。</p><ul><li><strong>damping</strong></li></ul><p>阻尼？不知道是不是这么翻译，主要是由空气摩擦、机械摩擦以及其它外界阻力造成的。<br>- <strong>mass</strong></p><p>惯性？物体的质量越大，振荡时间越长。 - <strong>stiffness</strong></p><p>重力加速度（G） - <strong>initial velocity</strong></p><p>初始速度，开始运动前，外界的推（拉力）产生的速度</p><p>某些情况下，UIView 的弹性阻尼动画看起来胡比较生硬，因为在指定的 <code>duration</code> 内无法停下来，而被系统强制停下来，所以看起来很生硬。就如下图：</p><img class="lazyload" data-src="/oldimages/QQ20160826-4@2x.png" alt="QQ20160826-4@2x"/><p>如果 <code>duration</code> 为0.25，此时本应该还有振荡，但是动画时间已到，只能强制停止振荡，进而使动画看起来略微生硬。所以 <code>CASpringAnimation</code> 里面有一个属性叫做 <code>settlingDuration</code>,该属性表示所有动画参数设定好之后，振荡完成是所需时间，如果将 <code>duration</code> 设置成这样，那么动画看起来就会很自然。</p><blockquote><p>友情提示：请在设置好所有弹性振荡参数之后再设置 <code>duration</code>.</p></blockquote><h2>Section Ⅳ 3D Animations</h2><p>这部分主要通过一个侧拉菜单的 Demo 讲解了 3D 动画该如何实现。关键还是在于 CATransform3D 中的 m34 以及配合改变 anchor point,要想让视图看起来具有 3D 透视效果，可以将 m34 设置为 -1.0 / [camera distance], 分母代表相机离视图的距离.</p><p>关于距离选值与透视效果的明显程度可参见下表：</p><table><thead><tr><th align="center">distance</th><th align="center"></th></tr></thead><tbody><tr><td align="center">0.1~500</td><td align="center">失真较严重</td></tr><tr><td align="center">700~2000</td><td align="center">效果最好，逼真</td></tr><tr><td align="center">&gt;2000</td><td align="center">几乎没有透视效果</td></tr></tbody></table><h2>Section Ⅴ Further Types of Animations</h2><p>这部分主要是讲一些其它动画的延伸，比如粒子动画、ImageView 的帧动画。 粒子动画主要使用 CAEmitterLayer 来做，具体细节可以参考 CAEmitterLayer 的 API。 帧动画主要是讲解 UIImageView 关于使用图片数组产生帧动画的效果，基本就是改变其 animationDuration 来达到控制帧率的效果。</p><h2>Section Ⅵ View Controller Transitions</h2><p>这一部分主要是将视图控制器之间过渡的转场效果动画。关于这里，不再过多记录，毕竟关于 VC 之间的转场效果 GitHub 上一抓一大把了，随便拿一个读一读源码即可，万变不离其宗。</p><h2>Section Ⅶ Third-Party Animation Libraries</h2><p>这部分主要是两个开源动画库的使用，找个时间读一读源码，另外再写一篇文章。</p>]]></content><tag>笔记</tag></entry><entry><title>让你的 Xcode8 继续使用插件</title><link href="/posts/Make-Your-Xcode8-Great-Again"/><url>/posts/Make-Your-Xcode8-Great-Again</url><content type="html"><![CDATA[<p>随着 iOS10 的正式版即将发布，Xcode8 GM 也在发布会后放出，本文不会涉及到 Xcode8 有哪些更新，而是记录了如何让 Xcode8 继续支持 Plugin。</p><h3>Update:</h3><p><strong>2017.4.9</strong></p><p>Xcode 8.3 生成 XcodeGr8 后，XVim 即使用脚本更新也会失效，需要重新编译一次。下载 XVim 到本地后，需要删除删除如下几个文件：</p><blockquote><p>IDEPlaygroundEditor+XVim.h IDEPlaygroundEditor+Xvim.m 同时屏蔽掉 XVim/XVimHookManager.m 里面对上面两个文件的引用和调用</p></blockquote><p>详情参考这个 <a href="issue">issue: Build failure with Xcode 8.3</a></p><p><strong>2016.10.8</strong> 如果你的 XcodeGr8 时不时就转菊花卡死，可以试下这种方式：打开<code>系统偏好设置-&gt;安全性与隐私-&gt;通讯录-&gt;将 Xcode 前面的勾去掉</code>，如下图所示，解决方案来自 <code>Xvim</code> 的这个 <a href="11">issue</a>。</p><img class="lazyload" data-src="/oldimages/14759295440293.jpg"/><p><strong>2016.9.16</strong> 看到 GitHub 上有一个 repo 可以一句命令即可解决本文提到的所有问题 <a href="9">update<em>xcode</em>plugins</a>，没有亲测，如果觉得本文方法比较麻烦，可以一试。</p><p>我个人常用的 Xcode 插件可以参见这篇文章<a href="10">Xcode 常用插件</a>。</p><hr><p>相信各位已经有尝试过 Xcode-beta 了，但是会发现之前所有的插件都失效了。一开始我以为是和之前一样 Xcode 升级了，需要更新 Xcode info.plsit 中的 DVTPlugInCompatibilityUUID,于是运行了如下命令，具体修复原理和方案可以参考这篇文章 <a href="1">Xcode升级后插件失效的原理与修复办法</a>。</p><pre data-language="undefined" class="hljs"><code>
find ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I{} defaults write {} DVTPlugInCompatibilityUUIDs -array-add `defaults read /Applications/Xcode-beta.app/Contents/Info.plist DVTPlugInCompatibilityUUID`
</code></pre><p>结果还是无效，去 Github 上看，果然一堆人遇到了这个问题，可以看下这个 <a href="2">issue</a>。由于 Xcode8 没了插件支持，我用的时候勉强还能习惯，一个用习惯了 Xvim 的同事表示不能忍，于是就去到 <a href="3">XVim</a> 看有没有提这个 issue，果然也是有一堆人提到了这个问题，作者也给出了对应的解决方案，摘录最主要的一段如下：</p><p>&gt;With Xcode 8 and above, you'll be asked if you want to remove code singature from Xcode. It is required to make the XCode load XVim. So if you are OK just type 'y' to proceed and remove code signature from your Xcode.</p><p>但是我并没有按照这种方式来操作，而是结合这个 <a href="4">issue</a> 中的解决方案，总结起来步骤如下：</p><blockquote><p>1. 编译 <a href="5">MakeXcodeGr8Again</a> 并且导出其 product (关于 MakeXcodeGr8Again，下文会详细说到)。 2. 退出 Xcode8，同时运行刚刚导出的 MakeXcodeGr8Again，将 Xcode8 拖入其中，等待一段时间(3~10分钟)。 3. 等菊花转完后，应用程序文件夹下会生成一个 XcodeGr8 的应用，运行命令 <code>sudo xcode-select -s /Applications/XcodeGr8.app/Contents/Developer</code> 将 Xcode 开发路径指向刚生成的 XcodeGr8。 4. 既然 Xcode8 的签名已被移除，那么就可以继续使用上面的修复插件失效代码。但是上面的脚本要稍微改一下就是把 Xcode.app 换成 XcodeGr8.app 即可。代码如下：</p></blockquote><pre data-language="undefined" class="hljs"><code>
find ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I{} defaults write {} DVTPlugInCompatibilityUUIDs -array-add `defaults read /Applications/XcodeGr8.app/Contents/Info.plist DVTPlugInCompatibilityUUID`
</code></pre><p>下面我们来看下步骤1提到的 MakeXcodeGr8Again，其 <a href="6">ReadMe</a> 也有对应的介绍。这里大概摘录一下: &gt;苹果为了避免类似 <a href="7">Xcode Ghost 👻</a> 事件的再次发生，Xcode8 禁用了插件机制，而开放了另一种形式：<a href="8">Source Editor extensions</a>，但是这种形式局限性太大。MakeXcodeGr8Again 只是去除了它的签名，这样使得 Xcode8 也可以继续使用插件了。由于签名被移除，所以它的安全性又重回 Xcode7 时代，也就是还有可能受到类似 Xcode Ghost 的攻击。所以不推荐用 XcodeGr8 来提交应用到 Appstore。Use at your own risk.</p><p>PS：可能遇到的问题</p><ul><li>1.生成了 XcodeGr8 之后，打不开。 解决方法：重启。</li><li>2.如果之前对其它版本的 Xcode-beat 也有使用这种方式，再对 Xcode8 GM 也是用该方式可能 MakeXcodeGr8Again 这个 APP 会一直闪退。 解决方法：卸载之前生成的 XcodeGr8，再重试。卸载后记得将开发路径重新指回原来的路径，即 <code>sudo xcode-select -s /Applications/Xcode.app/Contents/Developer</code>。如果这种方式还不行，卸载所有版本的 Xcode，然后再安装 GM 版，重复上述步骤。</li></ul><p>PPS：如果要卸载 XcodeGr8，记得将重新开发路径置回初始状态。</p><p>最后，重要的事情说三遍： <strong>不要使用 XcodeGr8 打包上传 Appstore，最好使用服务器打包，保证服务器 Xcode 是 Appstore 下载的！！！ 不要使用 XcodeGr8 打包上传 Appstore，最好使用服务器打包，保证服务器 Xcode 是 Appstore 下载的！！！ 不要使用 XcodeGr8 打包上传 Appstore，最好使用服务器打包，保证服务器 Xcode 是 Appstore 下载的！！！</strong></p><p>[1]:http://joeshang.github.io/2015/04/10/fix-xcode-upgrade-plugin-invalid/ [2]:https://github.com/alcatraz/Alcatraz/issues/475 [3]:https://github.com/XVimProject/XVim [4]:https://github.com/XVimProject/XVim/issues/979#issuecomment-242976786 [5]:https://github.com/fpg1503/MakeXcodeGr8Again [6]:https://github.com/fpg1503/MakeXcodeGr8Again/blob/master/README.md [7]:https://en.wikipedia.org/wiki/XcodeGhost [8]:https://developer.apple.com/videos/play/wwdc2016/414/ [9]:https://github.com/inket/update<em>xcode</em>plugins [10]:http://vongloo.me/2016/09/17/Useful-Xcode-Plugins/ [11]:https://github.com/XVimProject/XVim/issues/966#issuecomment-247276024 [issue]:https://github.com/XVimProject/XVim/issues/1058#issuecomment-289703908</p>]]></content><tag>Xcode</tag><tag>插件</tag><tag>Xcode8</tag></entry><entry><title>Xcode 常用插件</title><link href="/posts/Useful-Xcode-Plugins"/><url>/posts/Useful-Xcode-Plugins</url><content type="html"><![CDATA[<p>工欲善其事，必先利其器。随着 Xcode 的一步步变得强(yong)大(zhong)，许多功能已经被集成到 Xcode 中，但是日常开发还是会遇到很多小问题，影响效率，于是 Xcode plugins 便派上用场了。下面介绍一下自己在开发中常用的插件，排名不分先后，仅按字母排序。</p><blockquote><p>关于 Xcode8 不能使用插件的问题，可以在我上一篇文章<a href="1">让你的 Xcode8 继续使用插件</a>找到解决方案。</p></blockquote><h3><a href="2">Alcatraz</a></h3><img class="lazyload" data-src="/oldimages/14740910538405.jpg"/><p>这个就不用多说了吧，所有插件包管理器，快捷键 <code>cmd + shift + 9</code>。</p><h3><a href="3">ATProperty</a></h3><img class="lazyload" data-src="/oldimages/14740919509236.gif"/><p>平时在属性声明时，总要写一堆的诸如 <code>@property (strong, nonatomic) UIWindow *window;</code>之类的，前面那一长串在属性一多时，写起来挺累的。这个插件正是为了解决这个痛点而存在，快捷键如下：</p><table><thead><tr><th align="left">快捷键</th><th align="left">结果</th></tr></thead><tbody><tr><td align="left">@t</td><td align="left">@property (nonatomic, strong)</td></tr><tr><td align="left">@w</td><td align="left">@property (nonatomic, weak)</td></tr><tr><td align="left">@y</td><td align="left">@property (nonatomic, copy)</td></tr><tr><td align="left">@a</td><td align="left">@property (nonatomic, assign)</td></tr></tbody></table><p><code>readonly</code> 只需在 <code>@</code> 后插入 <code>r</code> 即可，比如 <code>@rt</code>，就是 <code>@property (nonatomic, strong, readonly)</code></p><h3><a href="4">Auto-Importer</a></h3><img class="lazyload" data-src="/oldimages/14740927781208.gif"/><p>在写代码过程中，比如处在 line500 的时候要引入一个新的类，这个时候不得不滑到顶部，去写一次 <code>#import"xxxx.h"</code>，然后又滑回来继续写代码，严重影响效率。此时你需要这个插件来解决这个苦恼，随便一个地方，使用快捷键 <code>cmd + ctrl + h</code> 来呼出弹窗，在搜索框中输入想要导入的头文件即可，无需在滑到文件顶部，参考上图。</p><h3><a href="5">CATweakerSense</a></h3><img class="lazyload" data-src="/oldimages/14740930409569.png"/><p>用的不是很多，主要是在做动画比较有用，时间缓冲函数，将时间曲线可视化。</p><h3><a href="6">ColorSenseRainbow</a></h3><img class="lazyload" data-src="/oldimages/14740932923044.png"/><p>一目了然，颜色可视化。</p><h3><a href="7">DBSmartPanels</a></h3><img class="lazyload" data-src="/oldimages/14740934576865.jpg"/><p>智能化的区域隐藏插件，在输入时自动隐藏底部 <code>debug</code>、右侧 <code>inspector</code> 区域，具体可以自定义。</p><h3><a href="8">DXXcodeConsoleUnicodePlugin</a></h3><p>有时候在调试时，服务端返回的中文字符在 <code>debug console</code> 中总是显示成 <code>unicode</code>，这个插件可以将其自动转成中文字符。具体可到其 GitHub 主页查看用法。</p><h3><a href="9">FastStub</a></h3><img class="lazyload" data-src="/oldimages/14740940467700.gif"/><p>检测头文件、父类、协议等中的方法，然后自动在 <code>.m</code> 文件插入。快捷键 <code>cmd + ctrl + k</code></p><h3><a href="10">FuzzyAutocomplete</a></h3><img class="lazyload" data-src="/oldimages/14740942597943.gif"/><p>快速补全。</p><h3><a href="11">GitDiff</a></h3><img class="lazyload" data-src="/oldimages/14740943628859.jpg"/><p>检测文件中的 git 状态。</p><h3><a href="12">RRConstraintsPlugin</a></h3><p>对系统 Auto Layout 的一些补充。</p><h3><a href="13">SCXcodeSwitchExpander</a></h3><img class="lazyload" data-src="/oldimages/14741022908523.gif"/><p><code>switch</code> 时根据枚举类型，自动补全所有枚举</p><h3><a href="14">SCXcodeTabSwitcher</a></h3><img class="lazyload" data-src="/oldimages/14741091449161.gif"/><p>此插件用于存在多个 <code>tab</code> 时在 <code>tab</code> 间快速切换，类似 Chrome。快捷键 <code>Cmd + 1...9</code> 切换。</p><h3><a href="15">VVDocumenter-Xcode</a></h3><p>这个不用多说了吧。快速注释，现已集成到 Xcode8。</p><h3><a href="16">XAlign</a></h3><img class="lazyload" data-src="/oldimages/14741140642718.gif"/><p>对齐插件，可自定义对齐方式。</p><h3><a href="17">XQuit</a></h3><img class="lazyload" data-src="/oldimages/14741141444896.png"/><p>完全退出(cmd + q) Xcode 之前，弹出一个确认框，防止误操作。</p><h3><a href="18">XToDo</a></h3><img class="lazyload" data-src="/oldimages/14741143739724.png"/><img class="lazyload" data-src="/oldimages/14741143787410.png"/><p>用于工程中的一些标注，及快速查找这些标注的插件。</p><h3><a href="19">XVim</a></h3><p>Vim 控必备。</p><p>以上便是个人常用的 Xcode 插件，欢迎推荐。</p><p>[1]:http://vongloo.me/2016/09/10/Make-Your-Xcode8-Great-Again/ [2]:https://github.com/alcatraz/Alcatraz/ [3]:https://github.com/Draveness/ATProperty [4]:https://github.com/citrusbyte/Auto-Importer-for-Xcode [5]:https://github.com/keefo/CATweaker [6]:https://github.com/NorthernRealities/ColorSenseRainbow [7]:https://github.com/chaingarden/DBSmartPanels/ [8]:https://github.com/dhcdht/DXXcodeConsoleUnicodePlugin [9]:https://github.com/music4kid/FastStub-Xcode [10]:https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin [11]:https://github.com/johnno1962/GitDiff [12]:https://github.com/RolandasRazma/RRConstraintsPlugin [13]:https://github.com/stefanceriu/SCXcodeSwitchExpander [14]:https://github.com/stefanceriu/SCXcodeTabSwitcher [15]:https://github.com/onevcat/VVDocumenter-Xcode [16]:https://github.com/qfish/XAlign [17]:https://github.com/StefanLage/XQuit [18]:https://github.com/trawor/XToDo [19]:https://github.com/XVimProject/XVim</p>]]></content><tag>Xcode</tag><tag>插件</tag><tag>Xcode8</tag></entry><entry><title>Modern Objective-C</title><link href="/posts/Modern-Objective-C"/><url>/posts/Modern-Objective-C</url><content type="html"><![CDATA[<p>本文主要介绍一些 Objective-C 的一些新特性。</p><h3>从一个 Bug 来说说 Objective-C 中的指定构造器</h3><p>某天测试反馈，iOS8 点击按钮时弹出一个列表视图出现必现崩溃，看了下崩溃日志，是野指针导致导出乱崩，具体是 <code>[xxx collectionView:numberOfItemsInSection:] unrecognized selector send to instance xxxxx</code>。 连上设备调试，发现 <code>setupDataSource</code> 走了两次，由于调用栈非常类似，一开始没注意它调了两次，一直没找到问题所在。后面各种断点上去，发现 <code>setupDataSource</code> 方法被调用了两次，进一步 <code>commonInit</code> 被调用了两次。最后查看初始化代码，才发现调用 <code>convenience init method</code> 时，没有调 <code>designed init method</code>，并且调完之后又再调了一次 <code>commonInit</code>。具体看下代码：</p><pre data-language="objc" class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">PanelView</span>()</span>
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">UICollectionView</span> *collectionView;
<span class="hljs-keyword">@end</span>

- (<span class="hljs-keyword">instancetype</span>)initWithCoder:(<span class="hljs-built_in">NSCoder</span> *)aDecoder {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> initWithCoder:aDecoder]) {
        [<span class="hljs-keyword">self</span> commonInit];
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;
}

- (<span class="hljs-keyword">instancetype</span>)initWithFrame:(<span class="hljs-built_in">CGRect</span>)frame {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> initWithFrame:frame]) {
        [<span class="hljs-keyword">self</span> commonInit];
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;
}

- (<span class="hljs-keyword">instancetype</span>)initWithType:(PanelType)type {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init]) {
        [<span class="hljs-keyword">self</span> commonInit];
        <span class="hljs-keyword">self</span>.type = type;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;
}

- (<span class="hljs-keyword">void</span>)commonInit {
    <span class="hljs-keyword">self</span>.colletionView = ...
    [<span class="hljs-keyword">self</span> addSubview:<span class="hljs-keyword">self</span>.colletionView];
    [<span class="hljs-keyword">self</span> setupDataSource];
}
- (<span class="hljs-keyword">void</span>)setupDataSource {
    DataSource *dataSource = [[DataSource alloc] initWithCollectionView:<span class="hljs-keyword">self</span>.collectionView];
    dataSource.delegate = <span class="hljs-keyword">self</span>;
    <span class="hljs-keyword">self</span>.collectionView.dataSource = dataSource;
    <span class="hljs-keyword">self</span>.dataSource = dataSource;
}

<span class="hljs-comment">// 外面使用 initWithType: 做了初始化</span>
</code></pre><p>由于调了两次 <code>commonInit</code>，导致创建了两个 <code>collectionView</code> 和 <code>dataSource</code>，由于第一次创建的 <code>dataSource</code> 没有持有者，被释放为 <code>nil</code>，而第一次创建的 <code>collectionView</code> 被加到视图层级当中被 <code>self</code> 持有，所以在第一个 <code>collectionView</code> 在执行调用数据源方法时，<code>dataSource</code> 为 <code>nil</code>，但是在 iOS9 之前 <code>UICollectionView</code> 和 <code>UITableView</code> 的 <code>delegate</code> 和 <code>dataSource</code> 属性用 <code>assign</code> 而非 <code>weak</code> 修饰，导致这一块内存被污染，继续调用时会出现野指针崩溃。</p><p>归根结底，就是初始化的姿势不对。</p><p>正确的姿势应该是：</p><ol><li>子类指定构造器必须调用父类指定构造器</li><li>便捷构造器只能通过调用自身指定构造器来完成初始化</li><li>指定构造器必须要用 <code>NS_DESIGNATED_INITIALIZER</code> 标示</li></ol><p>可参考下图</p><img class="lazyload" data-src="/oldimages/14912017895530.jpg"/><blockquote><p>图片出自 《The Swift Programming Language (Swift 3.0.1)》 Initialization - Syntax for Designated and Convenience Initializers 小节</p></blockquote><p>关于指定构造器，iOS 自身内部实现也有一个 bug <a href="">UITableViewController subclass designated initializer Crash</a>、<a href="">How to subclass UITableViewController in Swift</a>。iOS8 下自定义一个 <code>UIViewController</code> 继承自 <code>UITableViewController</code>，然后自定义指定构造器，代码如下：</p><pre data-language="objc" class="hljs"><code><span class="hljs-comment">// 指定构造器</span>
- (<span class="hljs-keyword">instancetype</span>)initWithTitle:(<span class="hljs-built_in">NSString</span> *)title {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> initWithStyle:<span class="hljs-built_in">UITableViewStyleGrouped</span>]) {
        <span class="hljs-comment">//....</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;
}

- (<span class="hljs-keyword">instancetype</span>)initWithNibName:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSString</span> *)nibNameOrNil bundle:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSBundle</span> *)nibBundleOrNil {
    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> initWithTitle:<span class="hljs-literal">nil</span>];
}

- (<span class="hljs-keyword">instancetype</span>)initWithStyle:(<span class="hljs-built_in">UITableViewStyle</span>)style {
    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> initWithTitle:<span class="hljs-literal">nil</span>];
}

<span class="hljs-comment">// 外面调用，iOS8 下调用此段代码，必崩</span>
<span class="hljs-comment">// 所以 iOS8 最好不要继承自 UITableViewController</span>
TestViewController *vc = [[TestViewController alloc] initWithTitle:<span class="hljs-string">@"Hello"</span>];
</code></pre><h4>几个小问题</h4><ul><li><strong>Question 1</strong>: <code>instancetype</code> 和 <code>id</code> 两者有什么区别？</li></ul><blockquote><p><code>instancetype</code> 能够做到类型检测而 <code>id</code> 不行。前者仅可做方法返回值，不能作为参数，见示例代码比如如下代码：</p></blockquote><pre data-language="objc" class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">TestObjectA</span> : <span class="hljs-title">NSObject</span></span>

+ (<span class="hljs-keyword">id</span>)createObjectA;
- (<span class="hljs-keyword">void</span>)methodA;

<span class="hljs-keyword">@end</span>

<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">TestObjectB</span> : <span class="hljs-title">NSObject</span></span>

+ (<span class="hljs-keyword">instancetype</span>)createObjectB;
- (<span class="hljs-keyword">void</span>)methodB;

<span class="hljs-keyword">@end</span>

[[TestObjectA createObjectA] methodB];      <span class="hljs-comment">// no compile error or warning but crash</span>
[[TestObjectB createObjectB] methodA];      <span class="hljs-comment">// compile error --&gt; No visible @interface for 'TestObjectB' declares the selector 'methodA'</span>
</code></pre><p>延伸问题：为什么<code>(id)initWithXXX:</code> 也可以做到类型检测？ &gt; 类方法只要以 <code>alloc</code>、<code>new</code> 开头就会有关联返回类型（即类型检测） &gt; 实例方法只要以 <code>init</code>、<code>autorelease</code>、<code>retain</code>、<code>self</code> 开头就会有关联返回类型 &gt; <a href="">Clang Language Extensions--Objective-C Features</a> &gt; <strong>Note</strong>: ARC 下实测，实例方法只有 <code>init</code> 开头的才有关联返回类型。</p><ul><li><strong>Question 2</strong>: 新建一个VC 文件同时勾选 <code>Also create XIB file</code> 后，初始化 <code>VC *vc = [[VC alloc] init]</code> 得到的是否和 <code>initWithNibName:bundle:</code> 初始化得到的 UI 一致？为什么？</li></ul><blockquote><p>是一致的，因为最终都会调到指定构造器 <code>initWithNibName:bundle:</code>，但此时 <code>nibName</code> 为 <code>nil</code>，关于 <code>nibName</code> 的相关设置文档是这么说的 However, if you do not specify a nib name, and do not override the loadView method in your custom subclass, the view controller searches for a nib file using other means. Specifically, it looks for a nib file with an appropriate name (without the .nib extension) and loads that nib file whenever its view is requested. Specifically, it looks (in order) for a nib file with one of the following names:If the view controller class name ends with the word ‘Controller’, as in MyViewController, it looks for a nib file whose name matches the class name without the word ‘Controller’, as in MyView.nib.It looks for a nib file whose name matches the name of the view controller class. For example, if the class name is MyViewController, it looks for a MyViewController.nib file.</p></blockquote><blockquote><p>简单来说，如果没设置该属性也没有复写 <code>loadView</code> 方法，则系统有一套自己的寻找机制来看是否有对应的 xib 文件，如果有，则加载 xib 文件。</p></blockquote><ul><li><strong>Question 3</strong>: 如下代码输出的是什么？为什么？ 选自 <a href="">神经病院objc runtime入院考试</a></li></ul><pre data-language="objc" class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">TestSubclass</span> : <span class="hljs-title">TestSuperclass</span></span>
<span class="hljs-keyword">@end</span>
<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">TestSubclass</span></span>
- (<span class="hljs-keyword">instancetype</span>)init {
    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) {
        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>, <span class="hljs-built_in">NSStringFromClass</span>([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>]));
        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>, <span class="hljs-built_in">NSStringFromClass</span>([<span class="hljs-keyword">super</span> <span class="hljs-keyword">class</span>]));
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;
}
<span class="hljs-keyword">@end</span>
</code></pre><blockquote><p>输出的都是 <code>TestSubclass</code>，因为两者的 receiver 都是 self。当我们给 super 发消息的时候，实际上是给 self 发消息，只不过在查找方法列表时会自动跳过当前类的方法列表，而从父类方法列表中开始查找。归根结底，最后产生的消息是 <code>objc_msgSendSuper(self, @selector(init));</code>。</p></blockquote><ul><li><strong>Question 4</strong>: 为什么我们初始化方法的写法都长这样？</li></ul><pre data-language="objc" class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">SomeClass</span> : <span class="hljs-title">TestSuperClass</span></span>
<span class="hljs-keyword">@end</span>
<span class="hljs-class"><span class="hljs-keyword">@implementation</span></span>
- (<span class="hljs-keyword">instancetype</span>)init 
{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init]) {
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;
}
<span class="hljs-keyword">@end</span>
SomeClass *aInstance = [[SomeClass alloc] init];
</code></pre><blockquote><p>我们可以将上面代码拆成以下几个步骤：</p></blockquote><blockquote><p>1. <code>[SomeClass alloc]</code> 返回一个 <code>SomeClass</code> 的实例 2. 紧接着给 <strong>步骤1</strong> 生成的实例发 <code>init</code> 消息，所以 <strong>init</strong> 方法中的 self 为 <strong>步骤1</strong> 生成的实例 3. <code>[super init]</code> 实际上调用的是父类的初始化方法，在父类的方法中，<strong>self</strong> 依然是 <strong>步骤1</strong> 生成的实例，<strong>对于这一点的理解很重要</strong> 4. 父类的 <code>init</code> 方法要么做一些基本的初始化工作，要么修改 self，然后返回一个新的实例 5. 回到 SomeClass 的<code>init</code>方法中来，此时得到的要么是 <strong>步骤1</strong> 生成的实例，要么是新生成的实例。这就是为什么我们要加 if 判断的原因。</p></blockquote><h3>新增关键字及特性</h3><h4>Nullability</h4><p><code>nonnull/_Nonnull</code> 表达的意思是一样的，<code>nullable/_Nullable</code> 同理，只是修饰符的位置不同</p><p><code>_Nonnull</code> 和 <code>_Nullable</code> 的位置和 C语言的 <code>const</code> 关键字位置一致。</p><pre data-language="objc" class="hljs"><code><span class="hljs-comment">// 写法1和2 表达的意思完全一致</span>
<span class="hljs-comment">// 写法1</span>
- (AAPLListItem * _Nullable)itemWithName:(<span class="hljs-built_in">NSString</span> * _Nonnull)name;
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">copy</span>, <span class="hljs-keyword">readonly</span>) <span class="hljs-built_in">NSArray</span> * _Nonnull allItems;
<span class="hljs-comment">// 写法2</span>
- (<span class="hljs-keyword">nullable</span> AAPLListItem *)itemWithName:(<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">NSString</span> *)name;
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">copy</span>, <span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">nonnull</span>) <span class="hljs-built_in">NSArray</span> *allItems;
</code></pre><p>几个特例： - <code>typedef</code> 类型由于可以从上下文中推断出它是空（nullable）或非空（nonnull），所以内部不需要写 <code>nullable</code> 或 <code>nonnull</code>。 - 复杂指针必须显式声明其是否可为空，比如指定一个指向非空对象的可空指针可声明为 <code>_Nullable id * _Nonnull</code> - <code>NSError **</code> 类型通常为一个指向可空对象的可空指针。</p><p>为了避免重复写 <code>nonnull</code>，有一对宏 <code>NS_ASSUME_NONNULL_BEGIN</code> 和 <code>NS_ASSUME_NONNULL_END</code>，被这两个宏包裹的代码，默认都是 <code>nonnull</code>，如果可为空，则需显式声明为 <code>nullable</code> 或者 <code>_Nullable</code>。</p><p><code>null_resettable</code>: 可被置 nil，但是调用 getter 时又会重新创建，可参考 <code>UIViewController</code> 的 <code>view</code> 属性 或者 <code>UIView</code> 的 <code>tintColor</code> 属性。</p><p>更多关于 Nullability 可参考： &gt; <a href="">Nullability and Objective-C</a> &gt; <a href="">Difference between nullable, _<em>nullable and </em>Nullable in Objective-C</a></p><h4>__kindof</h4><p>该关键字的出现可以很好的避免做强转，比如 <code>UIView</code>、<code>UITableView</code> 的如下方法/属性</p><pre data-language="objc" class="hljs"><code><span class="hljs-comment">// UIView.h</span>
<span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">readonly</span>,<span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSArray</span>&lt;__kindof <span class="hljs-built_in">UIView</span> *&gt; *subviews;
- (<span class="hljs-keyword">nullable</span> __kindof <span class="hljs-built_in">UIView</span> *)viewWithTag:(<span class="hljs-built_in">NSInteger</span>)tag;
...

<span class="hljs-comment">// UITableView.h</span>
- (<span class="hljs-keyword">nullable</span> __kindof <span class="hljs-built_in">UITableViewCell</span> *)cellForRowAtIndexPath:(<span class="hljs-built_in">NSIndexPath</span> *)indexPath;
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>) <span class="hljs-built_in">NSArray</span>&lt;__kindof <span class="hljs-built_in">UITableViewCell</span> *&gt; *visibleCells;

<span class="hljs-comment">// 无警告，不需要做强转</span>
<span class="hljs-built_in">UIlabel</span> *textLabel = view.subviews.firstObject; 
CustomCell *cell = <span class="hljs-keyword">self</span>.tableView.visibleCells.lastObject;
</code></pre><h4>Generics</h4><p>为了更好的桥接 Swift，Objective-C 新增了轻量级的泛型支持，之所以是轻量级泛型，是因为它只是编译时的泛型。目前 Swift 仅支持 NSArray,、NSDictionary、NSSet 这 3 个类的泛型桥接，其它类(含自定义)，不支持。 <a href="">Using Objective-C Lightweight Generics</a></p><h5>__covariant</h5><p>子类可赋给父类</p><h5>__contravariant</h5><p>父类可赋给子类，目前没有想到适用的场景，<code>__kindof</code> 和这个有点类似，但是又不一样，<code>__kindof</code> 可直接修饰属性。 比如 <code>@property (nullable, nonatomic, strong) __kindof NSObject *object;</code></p><p>协变和逆变的具体区别可参考，sunnyxx 的博客<a href="">2015 Objective-C 新特性</a></p><h3>__attributes__ 命令</h3><h4>基本概念</h4><p><code>__attribute__</code> 命令是用来修饰 C/C++/Objective-C 中的代码片段，让它们拥有额外的属性，进而使编译器做出对应的优化或者为代码调用者提供有用的上下文（警告或提示）。进一步来讲，就是 <code>__attributes__</code> 命令为我们提供了阅读代码的上下文，便于编译器提前做出优化，达到事半功倍的效果。</p><h4>什么时候用</h4><p>Twitter 官方博客是推荐，能用且可以提供额外上下文的地方就尽量用。这样不仅可以让编译器做优化，同时可以让其他阅读代码的人（包括你自己）受益匪浅。当你想用却又在犹豫该不该用时，就不要用了。</p><h4>怎么用</h4><p>虽然上面说到在能够使用的地方尽量使用，但是也不能乱用、滥用。具体例子可以参考下面提到的 Twitter 官方博客。</p><p>最开始接触 <code>__attribute__</code> 命令是在 <code>PSPDFUIKitMainThreadGuard.m</code>，第一次看到这个的时候一脸懵逼，仅仅一个 <code>.m</code> 文件，就可以起到检测是否在主线程执行的作用，而且对项目毫无侵入。后面看了下源代码，然后每个方法都设置了一个断点，然后在非主线程操作 UI，看断点位置。结果运行后，就走到了一个方法：</p><pre data-language="objc" class="hljs"><code><span class="hljs-comment">// This installs a small guard that checks for the most common threading-errors in UIKit.</span>
<span class="hljs-comment">// This won't really slow down performance but still only is compiled in DEBUG versions of PSPDFKit.</span>
<span class="hljs-comment">// @note No private API is used here.</span>
__attribute__((constructor)) <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> PSPDFUIKitMainThreadGuard(<span class="hljs-keyword">void</span>) {
    <span class="hljs-keyword">@autoreleasepool</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSString</span> *selStr <span class="hljs-keyword">in</span> @[PROPERTY(setNeedsLayout), PROPERTY(setNeedsDisplay), PROPERTY(setNeedsDisplayInRect:)]) {
            SEL selector = <span class="hljs-built_in">NSSelectorFromString</span>(selStr);
            SEL newSelector = <span class="hljs-built_in">NSSelectorFromString</span>([<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@"pspdf_%@"</span>, selStr]);
            <span class="hljs-keyword">if</span> ([selStr hasSuffix:<span class="hljs-string">@":"</span>]) {
                PSPDFReplaceMethodWithBlock(<span class="hljs-built_in">UIView</span>.class, selector, newSelector, ^(__<span class="hljs-keyword">unsafe_unretained</span> <span class="hljs-built_in">UIView</span> *_<span class="hljs-keyword">self</span>, <span class="hljs-built_in">CGRect</span> r) {
                    PSPDFAssertIfNotMainThread();
                    ((<span class="hljs-keyword">void</span> ( *)(<span class="hljs-keyword">id</span>, SEL, <span class="hljs-built_in">CGRect</span>))objc_msgSend)(_<span class="hljs-keyword">self</span>, newSelector, r);
                });
            }<span class="hljs-keyword">else</span> {
                PSPDFReplaceMethodWithBlock(<span class="hljs-built_in">UIView</span>.class, selector, newSelector, ^(__<span class="hljs-keyword">unsafe_unretained</span> <span class="hljs-built_in">UIView</span> *_<span class="hljs-keyword">self</span>) {
                    PSPDFAssertIfNotMainThread();
                    ((<span class="hljs-keyword">void</span> ( *)(<span class="hljs-keyword">id</span>, SEL))objc_msgSend)(_<span class="hljs-keyword">self</span>, newSelector);
                });
            }
        }
    }
}
</code></pre><p>具体代码就不分析了，就是 hook 了一些布局才会调用的函数，然后判断其是否在主线程。最有意思的是前面的修饰符<code>__attribute__((constructor))</code>，后面查阅资料才知道，该修饰符修饰的方法，在 <code>main()</code> 函数执行前， <code>+load</code> 方法执行后。</p><blockquote><p>constructor 和 +load 都是在 main 函数执行前调用，但 +load 比 constructor 更加早一丢丢，因为 dyld（动态链接器，程序的最初起点）在加载 image（可以理解成 Mach-O 文件）时会先通知 objc runtime 去加载其中所有的类，每加载一个类时，它的 +load 随之调用，全部加载完成后，dyld 才会调用这个 image 中所有的 constructor 方法。<a href="">Clang Attributes 黑魔法小记</a></p></blockquote><p><code>__attribute__</code> 是编译器命令，后面会跟随两个括号对，主要是为了防止宏的歧义，方便宏的展开。</p><pre data-language="objc" class="hljs"><code><span class="hljs-comment">// +(void)load 执行之后，main() 执行之前，只对 C 方法生效</span>
<span class="hljs-comment">// 若有多个 constructor 且想控制优先级的话，可以写成 __attribute__((constructor(101)))</span>
<span class="hljs-comment">// 里面的数字越小优先级越高，1 ~ 100 为系统保留</span>
__attribute__((constructor))
__attribute__((objc_requires_super)) <span class="hljs-comment">// 子类复写时，必须先调用父类方法</span>

<span class="hljs-comment">// ---------- </span>
<span class="hljs-comment">// 用于 @interface 或 @protocol，将类或协议的名字在编译时指定成另一个</span>
__attribute__((objc_runtime_name(<span class="hljs-string">"SomeClass"</span>)))
<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Some</span> : <span class="hljs-title">NSObject</span></span>
<span class="hljs-keyword">@end</span>

<span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>, <span class="hljs-built_in">NSStringFromClass</span>([Some <span class="hljs-keyword">class</span>]));  <span class="hljs-comment">// "SomeClass"</span>
</code></pre><p>更多的 <code>__attribute__</code> 命令可参考：</p><blockquote><p>Twitter 官方博客：<a href=""><strong>attribute</strong> directives in Objective-C</a> NSHipster 关于 <code>__attribute__</code> 的讨论： <a href=""><strong>attribute</strong></a></p></blockquote><p>[UITableViewController subclass designated initializer Crash]:http://www.openradar.me/23709930 [How to subclass UITableViewController in Swift]:http://stackoverflow.com/questions/25139494/how-to-subclass-uitableviewcontroller-in-swift [<strong>attribute</strong> directives in Objective-C]:https://blog.twitter.com/2014/attribute-directives-in-objective-c [Nullability and Objective-C]:https://developer.apple.com/swift/blog/?id=25 [Difference between nullable, <strong>nullable and _Nullable in Objective-C]:http://stackoverflow.com/questions/32452889/difference-between-nullable-nullable-and-nullable-in-objective-c [Using Objective-C Lightweight Generics]:https://useyourloaf.com/blog/using-objective-c-lightweight-generics/ [Clang Attributes 黑魔法小记]:http://blog.sunnyxx.com/2016/05/14/clang-attributes/ [</strong>attribute<strong>]:http://nshipster.com/</strong>attribute__/ [Clang Language Extensions--Objective-C Features]:https://clang.llvm.org/docs/LanguageExtensions.html#objective-c-features [神经病院objc runtime入院考试]:http://blog.sunnyxx.com/2014/11/06/runtime-nuts/ [2015 Objective-C 新特性]:http://blog.sunnyxx.com/2015/06/12/objc-new-features-in-2015/</p>]]></content><tag>Objective-C</tag></entry><entry><title>亦无岁月可回头</title><link href="/posts/2017-Summary"/><url>/posts/2017-Summary</url><content type="html"><![CDATA[<p>2018 即将来到(哈哈哈哈哈哈，我说的是农历年)，这篇文章纯当一篇水文，做个2017的年终总结。</p><h3>工作</h3><img class="lazyload" data-src="/oldimages/15187013079738.jpg"/><p>来美图工作已经快4年了（算上实习的话），从一个 CollectionView 都不会用的人，到现在慢慢得能够比较轻松应对现在的工作。</p><p>去年工作上最有成就感的两件事情：</p><ul><li>在业界的几种模块化方式上结合美拍实际情况进行了简单的实践。年后写篇文章分享一下这个过程和思路。</li><li>配合架构同学让美拍直播实现了真正的秒开。</li></ul><blockquote><p>讲真陌陌直播秒开真的很牛逼，现在美拍也能达到这个水平了！</p></blockquote><p>年中的时候，买了几本书，目前只看了其中三本，年后再继续吧。 12月的时候美拍开始996，说真的有点累，每天晚上10点多到家，洗完澡差不多到睡觉时间，希望年后不要再继续了😂还是比较怀念之前有双休的日子。 对于学习的方式也发生了一点变化，以前总是想着要学很多，列了很多待学习项，但是最后都是不了了之，现在慢慢开始往某一个方向去深入了解，其他的做个基本了解就 ok。</p><h3>生活</h3><p>随着毕业季到来，和公司的两个小鲜肉合租，周末偶尔自己做做饭，刚开始兴趣比较大，后面由于996，基本上也就没怎么用过厨房了。 今年夏天在小鲜肉们的带领下，学会了一项求生技能----游泳。现在还不会换气，一口气只能游10m，姿势是狗刨试。 基本上每个月至少会和他们一起看一部电影，烂片除外。 国庆和小伙伴们去了一趟台湾，本来去年就计划好的，但是又去通行证时间来不及坑了熊哥，所以原计划就推到了今年。台湾旅程感觉最有意思的地方非绿岛莫属了，环岛骑了半天机车，傍晚时分一起去潜水。第一次比较紧张，到十几米水下的时候感觉不舒服，然后手脚错乱，还好教练在身边，马上浮了上来，差点 GG。后面再下去就比较顺利了，如果后面有机会，值得再去一次。</p><h3>游戏</h3><p>周末一般会和同学玩一玩英雄联盟，S7世界赛和同事们在家里一起投屏看比赛，只是很可惜零封 SSG 的 RNG 没有赢下对 SKT 的比赛。当然 EDG 是被喷的最惨的，不过 iBoy 这个小朋友很皮，S8可以期待一下。</p><p>996之后英雄联盟就玩的比较少了，一般就中午的时候吃一吃鸡。</p><p>不过不管玩什么游戏，都很菜，而且有时候反应很慢，可能不是玩游戏的料，纯属娱乐😂。哈哈哈哈哈，只能用这个来安慰自己了，感谢队友的不杀之恩！！！</p><h3>技能</h3><h4>技术方面</h4><ul><li><strong>初识逆向</strong> 发现逆向还是蛮好玩的，但是基础知识不够，还没有深入玩下去，只是做了个简单的了解。改善了一下平时写正向代码的思路。</li><li><strong>RAC 实践</strong> 之前组内同事一直在推广，但是自己没有真正实践过，都是停留在他的分享上。今年接手美拍直播这一块之后，慢慢开始使用，很多值得注意的地方，也踩了一些坑，目前只是算对 RAC 有一个基本的了解，以及初步实践，后面还需要继续实践，以及完整读一遍源码。</li></ul><h4>生活方面</h4><ul><li><strong>做菜</strong> 上面说到合租后有自己做过一段时间饭，有照着食谱做，也有回忆着老爸做菜时候的一些操作和步骤。从难吃到慢慢变成勉强能吃，到后面每次大家都能把菜吃光，也算是一种进步了吧。</li><li><strong>游泳</strong> 之前对游泳是抗拒的，主要是不会游，觉得去了很尴尬，后面看了几集视频教程以及实践，开始学会了一丁点，能有一点点距离了，但还是不会换气。</li></ul><h3>展望</h3><p>躺在床上，敲着这些流水账，听着外面鞭炮声，这真的是一篇写了“一年”的文章。</p><p>2017已经过去，希望2018自己能够继续成长。</p>]]></content><tag>杂谈</tag><tag>原创</tag></entry><entry><title>Pod 中资源引入方式对比</title><link href="/posts/Pod-Resource"/><url>/posts/Pod-Resource</url><content type="html"><![CDATA[<p>写这篇博客起因是由于周四在知识小集发了一个 <a href="https://weibo.com/3129068073/G7rJx4Pag" target="_blank">Tip</a>，讲 <code>Pod</code> 里面使用了 <code>.xcassets</code> 会导致 <code>Xcode 9</code> 打出来的包没有 <code>icon</code> 的解决方案。然后和 <a href="https://weibo.com/damonone" target="_blank">@Damonwong</a> 展开了一下讨论。当然这条 Tip 讲得不全对，而且表达得不是很清晰，所以这里专门开一篇文章来讲一下那个 Tip 想要表达的意思，最后也会附上对应的 Demo。也当做之后要写的模块化系列的文章开篇吧。</p><p>首先我们先来给出结论：</p><ul><li><strong><code>podspec</code> 里面写资源时，最好用 <code>s.resource_bundle</code> 而不是 <code>s.resource</code></strong></li><li><strong>只有 <code>podspec</code> 使用 <code>resource</code> 且明确写了 <code>.xcassets</code> 的情况下才会导致 <code>Xcode 9</code> 打出来的包没有 <code>icon</code></strong></li></ul><blockquote><p>环境配置：Xcode 9.2 、Cocoapods 1.4.0 本文所涉及到的资源主要是指 <code>png</code> 格式的图片</p></blockquote><p>下面我们先来了解一下这两种方式的具体情况，以及各自的优劣势，最后通过一个 <code>Demo</code> 来验证我们上面给的结论。</p><h2>resource 和 resource_bundle</h2><h3>resource</h3><p>通过<a href="https://guides.cocoapods.org/syntax/podspec.html#resources" target="_blank">官方文档</a>描述</p><p>&gt;A list of resources that should be copied into the target bundle.</p><p>这种方式会引用的文件夹下的所有资源拷贝到 <code>target</code> 的 <code>bundle</code> 中去，可以简单的理解为 <code>.app</code> 目录下或者 <code>.app</code> 的 <code>Assets.car</code> 文件中（<strong>如果是 <code>.xcassets</code> 的资源</strong>）。</p><blockquote><p>Tips: 注意一下上面加粗的部分。</p></blockquote><p>这里抄一下官网上给的几个示例写法</p><p>&gt;#单个路径 &gt;spec.resource = 'Resources/HockeySDK.bundle' &gt;#多个路径 &gt;spec.resources = ['Images/*.png', 'Sounds/*']</p><h3>resource_bundle</h3><p>还是一样，我们来看一下 <code>Cocoapods</code> <a href="https://guides.cocoapods.org/syntax/podspec.html#resource_bundles" target="_blank">官方文档</a>上的描述</p><blockquote><p>This attribute allows to define the name and the file of the resource bundles which should be built for the Pod. They are specified as a hash where the keys represent the name of the bundles and the values the file patterns that they should include.</p></blockquote><p>这种方式可以将指定路径下的资源打包打 <code>=&gt;</code> 之前的 <code>key</code> 命名的 bundle 中，这个 <code>bundle</code> 最终会被拷贝到 <code>target</code> 也就是 <code>.app</code> 根目录下。<strong>如果有指定 <code>.xcassets</code> 资源，会被打包到以 <code>key</code> 命名的 <code>bundle</code> 里的 <code>Assets.car</code> 文件中。</strong></p><blockquote><p>Tips: 注意一下上面加粗的部分。</p></blockquote><p>官方示例写法</p><p>&gt;#单个路径 &gt;spec.ios.resource<em>bundle = { 'MapBox' =&gt; 'MapView/Map/Resources/*.png' } &gt;#多个路径，生成多个 bundle &gt;spec.resource</em>bundles = { 'MapBox' =&gt; ['MapView/Map/Resources/*.png'], 'OtherResources' =&gt; ['MapView/Map/OtherResources/*.png'] }</p><h3>对比</h3><p>其实上面官网上的描述我故意漏附了后面的几段话，文档上在两种方式下都<strong>强烈(strongly)</strong>推荐使用 <code>resource_bundle</code> 的方式。</p><p>&gt;<strong>resource</strong> 下的描述 &gt;We <strong>strongly</strong> recommend library developers to adopt resource bundles as there can be name collisions using the resources attribute. Moreover, resources specified with this attribute are copied directly to the client target and therefore they are not optimised by Xcode.</p><p>&gt;<strong>resource_bundle</strong> 下的描述 &gt;We <strong>strongly</strong> recommend library developers to adopt resource bundles as there can be name collisions using the resources attribute. &gt;The names of the bundles should at least include the name of the Pod to minimise the chance of name collisions.</p><p>综合上述所说，就是使用 resource_bundle 主要有以下两点好处：</p><ul><li>避免命名冲突（<code>bundle</code> 命名时最好包含 Pod 的名字来尽可能避免掉命名冲突）</li><li>Xcode 会对资源做优化，比如 <code>.xcassets</code> 里的图片压缩、Slicing、以及 @2x/@3x 图片资源分离</li></ul><p>我们来对比下两种方式下最终打包出来的应用目录结构：</p><img class="lazyload" data-src="/oldimages/pod-resources-1.jpg"/><p>可以看出 <code>resource_bundle</code> 的形式会生成对应的 <code>bundle</code>(上图中的 <code>Pod1.bundle</code>)，并且 <code>.xcassets</code> 最终会被打包到对应 <code>bundle</code> 下的 <code>Assets.car</code> 文件下（该文件可用这个工具打开：<a href="https://github.com/devcxm/iOS-Images-Extractor" target="_blank">iOS-Images-Extractor</a>）。 而 <code>resource</code> 的形式，会把 <code>.xcassets</code> 打包到应用根目录下的 <code>Assets.car</code> 中。</p><p>而要读取对应的图片时，<code>resource</code> 对应的代码长下面这样：</p><pre data-language="objc" class="hljs"><code><span class="hljs-built_in">UIImage</span> *image = [<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@"your-image-name"</span>
                            inBundle:[<span class="hljs-built_in">NSBundle</span> bundleForClass:[<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>]]
       compatibleWithTraitCollection:<span class="hljs-literal">nil</span>];
</code></pre><p>而 <code>resource_bundle</code> 对应的读取代码如下面所示：</p><pre data-language="objc" class="hljs"><code><span class="hljs-built_in">NSBundle</span> *bundle = [<span class="hljs-built_in">NSBundle</span> bundleForClass:[<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>]];
<span class="hljs-built_in">NSURL</span> *url = [bundle URLForResource:<span class="hljs-string">@"your-bundle-name"</span> withExtension:<span class="hljs-string">@"bundle"</span>];
<span class="hljs-built_in">NSBundle</span> *targetBundle = [<span class="hljs-built_in">NSBundle</span> bundleWithURL:url];
<span class="hljs-built_in">UIImage</span> *image = [<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@"your-image-name"</span>
                            inBundle:targetBundle
       compatibleWithTraitCollection:<span class="hljs-literal">nil</span>];
</code></pre><p>通过以上两个代码片段，相信各位已经知道代码片段1、2都可能存在图片命名冲突的问题，但是一般情况下片段2的冲突概率远小于片段1的。因为一般情况下，模块内的图片命名肯定是不会冲突的，而模块间的图片的命名就不好说了。当然如果团队里有明确的命名规范，片段1和片段2都不会有问题。 虽然片段2代码较片段1稍复杂一些，但是如果我们将其封装成一个 <code>NSBundle</code> 的分类，就免去了冗长的写法，对于 <code>Storyboard/Xib</code> 同样适用。</p><pre data-language="objc" class="hljs"><code><span class="hljs-comment">// 具体代码可以在 Demo 中找到</span>
<span class="hljs-comment">//.h</span>
<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NSBundle</span> (<span class="hljs-title">Pod1Bundle</span>)</span>

+ (<span class="hljs-built_in">NSBundle</span> *)pod1_bundle;

<span class="hljs-keyword">@end</span>

<span class="hljs-comment">//.m</span>
<span class="hljs-comment">// FakeClass 仅作占位符用，即只为分类中的 `bundleForClass:` 方法服务</span>
<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Pod1FakeClass</span> : <span class="hljs-title">NSObject</span></span>
<span class="hljs-keyword">@end</span>
<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Pod1FakeClass</span></span>
<span class="hljs-keyword">@end</span>

<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">NSBundle</span> (<span class="hljs-title">Pod1Bundle</span>)</span>

+ (<span class="hljs-built_in">NSBundle</span> *)pod1_bundle {
    <span class="hljs-built_in">NSBundle</span> *bundle = [<span class="hljs-keyword">self</span> bundleForClass:[Pod1FakeClass <span class="hljs-keyword">class</span>]];
    <span class="hljs-built_in">NSURL</span> *url = [bundle URLForResource:<span class="hljs-string">@"Pod1"</span> withExtension:<span class="hljs-string">@"bundle"</span>];
    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> bundleWithURL:url];
}

<span class="hljs-keyword">@end</span>

<span class="hljs-comment">// 片段2可以简写为：</span>
<span class="hljs-built_in">UIImage</span> *image = [<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@"your-image-name"</span>
                            inBundle:[<span class="hljs-built_in">NSBundle</span> pod1_bundle]
       compatibleWithTraitCollection:<span class="hljs-literal">nil</span>];
</code></pre><h2><a href="https://github.com/wang9262/PodResourceDemo" target="_blank">Demo</a></h2><p>第一个 <a href="https://github.com/wang9262/PodResourceDemo/commit/c397c6d15ee1f54e99d333ad9e85a6600fdf34bf" target="_blank"><code>commit</code></a> 写好了两个 <code>podspec</code>，一个用 <code>resource_bundle</code>(Pod1)，一个用 <code>resource</code>(Pod2)，然后都引用 <code>.xassets</code> 资源，里面都有一个名为<code>Pod</code>的图片，主工程也有。区别在于 <code>Pod</code> 中的图片顶部会有该 <code>Pod</code> 名称的水印。然后页面上有3个 <code>ImageView</code>，目前只设置了中间那个 <code>ImageView</code> 的图片为主工程的图片。运行起来，一切表现正常，展示出来的图片也确实是主工程的图片。</p><p>第二个 <a href="https://github.com/wang9262/PodResourceDemo/commit/f2f7cfc979e13fc42e4dc2dd51631c4ce94e9861" target="_blank"><code>commit</code></a> 在主工程内分别读取 <code>Pod1</code> 和 <code>Pod2</code> 的名为 <code>Pod</code> 的图片，然后分别塞到上下两个 <code>ImageView</code> 中，运行起来，最下面那个 <code>ImageView</code> 的图片变成主工程的图片了，而最上面的 <code>ImageView</code> 的图片是正常的！！！这就是我们上面说到的那个问题，由于 <code>Pod2</code> 使用 <code>resource</code> 的方式，<code>.xcassets</code> 中图片是直接和主工程的 <code>.xcassets</code> 中图片一样是打包到 <code>.app</code> 根目录下的 <code>Assets.car</code> 中，命名一致，导致被主工程的图片给覆盖掉了（可以使用上面说到的解压工具解压，查看根目录 <code>.car</code> 下的文件内容，只有主工程的图片）。</p><p>第三个 <a href="https://github.com/wang9262/PodResourceDemo/commit/c6a1c9bd15dd24e1ef165edce948989306df6ad9" target="_blank"><code>commit</code></a> 及 <a href="https://github.com/wang9262/PodResourceDemo/tree/ruby-shell" target="_blank"><code>ruby-shell</code></a> 分支主要解决应用 icon 为空的问题。当我们 Home 键回到桌面时，回发现 Demo 的 icon 是空的，但是我们是有设置 icon 的。所以我们有两种解决方案来解决这个问题。</p><h3>方案一：不使用 <code>.xcassets</code></h3><p>把图片放到 <code>Pod2</code> 目录下，不再放到 <code>.xcassets</code> 里面，然后 <code>podspec</code> 里的写法改成：</p><pre data-language="ruby" class="hljs"><code>s.resources = [<span class="hljs-string">'Pod2/**/*.png'</span>]
</code></pre><p><code>pod install</code> 之后再跑一下，发现 <code>icon</code> 回来了，但是图片还是被主工程覆盖了，查看 <code>.app</code> 文件，我们发现根目录下多了两张图片，他们来自于 <code>Pod2</code> 目录下。</p><img class="lazyload" data-src="/oldimages/pod-resources-2.jpg"/><p>相应的我们的读取代码就需要改成下面这种形式，还需要区分 <code>@2x</code> 和 <code>@3x</code>，非常麻烦，但是这个时候确实能读到对应的图片</p><pre data-language="undefined" class="hljs"><code>
// @2x 读取
_podImage = [UIImage imageNamed:@"Pod@2x"
                       inBundle:[NSBundle bundleForClass:[self class]]
  compatibleWithTraitCollection:nil];
// @3x
_podImage = [UIImage imageNamed:@"Pod@3x"
                       inBundle:[NSBundle bundleForClass:[self class]]
  compatibleWithTraitCollection:nil];
</code></pre><h3>方案二：脚本</h3><p>在 podfile 中加入下面这一段脚本</p><pre data-language="ruby" class="hljs"><code>post_install <span class="hljs-keyword">do</span> <span class="hljs-params">|installer|</span>
copy_pods_resources_path = <span class="hljs-string">"Pods/Target Support Files/Pods-ResourceDemo_Example/Pods-ResourceDemo_Example-resources.sh"</span>
string_to_replace = <span class="hljs-string">'--compile "${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}"'</span>
assets_compile_with_app_icon_arguments = <span class="hljs-string">'--compile "${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}" --app-icon "${ASSETCATALOG_COMPILER_APPICON_NAME}" --output-partial-info-plist "${BUILD_DIR}/assetcatalog_generated_info.plist"'</span>
text = File.read(copy_pods_resources_path)
new_contents = text.gsub(string_to_replace, assets_compile_with_app_icon_arguments)
File.open(copy_pods_resources_path, <span class="hljs-string">"w"</span>) {<span class="hljs-params">|file|</span> file.puts new_contents }
<span class="hljs-keyword">end</span>
</code></pre><p>然后 <code>pod install</code> 之后，运行即可。</p><blockquote><p>以上两种方式执行之前最好 <code>clean</code> 一下，防止 <code>Xcode</code> 缓存，导致以上方法执行后也会出现 <code>icon</code> 消失的情况。</p></blockquote><h2>总结</h2><p>综合以上，我们再总结一下 <code>resource_bundle</code> 的优势：</p><ul><li>绝大多数(99.999%)情况下不会有资源命名冲突问题</li><li>如果图片资源放到 <code>.xcasset</code> 里面 <code>Xcode</code> 会帮我们自动优化、可以使用 Slicing 等（这里不仅仅指的是 <code>resource_bundle</code> 下的 <code>xcassets</code>，只不过 <code>s.resource</code> 中如果引用会导致 <code>icon</code> 消失的问题）。</li></ul><p>至于劣势，我觉得根本就没有，上面那个硬编码问题，完全可以通过我说的分类或者你自定义宏的方式把这个硬编码问题 Cover 掉。</p><p>如果认为文章中的观点或结论有问题，欢迎指出，一起沟通探讨。</p><p>参考链接 --- &gt; <a href="https://github.com/CocoaPods/CocoaPods/issues/7003" target="_blank">App Icons not included in build from Xcode 9</a> &gt; <a href="http://zhoulingyu.com/2018/02/02/pod-resource-reference/" target="_blank">关于 Pod 库的资源引用 resource_bundles or resources</a></p>]]></content><tag>Xcode</tag><tag>原创</tag><tag>Pod</tag></entry><entry><title>替换系统音量提示的实现和遇到的坑</title><link href="/posts/Replace-System-Volume-View"/><url>/posts/Replace-System-Volume-View</url><content type="html"><![CDATA[<p>相信平时大家在用 iPhone 看视频调节音量时，总会被系统的音量提示所打扰，因为它会遮住一部分内容。所以很多视频应用都使用自定义音量视图的方式来替代系统的音量提示。</p><p>比如下面三张截图，分别来自 Instagram、哔哩哔哩、即刻</p><img class="lazyload" data-src="/oldimages/15247541167324.jpg"/><h3>原理</h3><p>这里主要记录一下在项目中如何替换系统音量提示视图的过程。通过 <code>Google</code> 和 <code>stackoverflow</code>，可以查到，如果要自定义音量提示，需要做到以下几步：</p><ol><li>激活 <code>AudioSession</code></li><li>创建一个 <code>MPVolumeView</code>，并将其添加到当前可见的视图层级当中，同时将其 frame 设置到不可见区域</li><li>监听音量按钮触发事件，改变音量提示</li></ol><h3>实现</h3><p>然后为了调用统一且音量视图层级永远在最上方（即不被 <code>Alert</code> 等挡住），首先想到使用一个 <code>UIWindow</code>，然后自定义视图和系统的视图加到这个视图层级上，初始化时 <code>frame</code> 为 <code>CGRectZero</code>，<code>hidden</code> 属性为 <code>NO</code>（注意这里必须为 <code>NO</code>，不然系统音量提示仍会出现，上面说到的第2点）；要显示时设置其 <code>frame</code> 设置成 <code>mainScreen</code> 的 <code>bounds</code>，然后展示即可。</p><blockquote><p>由于自己创建的 <code>UIWindow</code> 的 <code>hidden</code> 属性默认是 <code>YES</code>，所以需要手动将其设成 <code>NO</code>。 音量按钮每触发一次，变化量都是 6.25%，连续按16次，即可调节至最大或最小</p></blockquote><p>上述的第3步有两种方式可以做到，各有优劣，下面来做一个简单介绍。</p><h4>KVO</h4><p>通过 <code>KVO</code> 监听 <code>[AVAudioSession sharedInstance]</code> 的 <code>outputVolume</code> 属性，然后来显示自定义的 UI 控件。这种方式有一个不好的地方就是，在音量调节至最大/最小时，这个时候再调大/调小音量，由于 <code>outputVolume</code> 的值不变，所以不会触发 <code>KVO</code>，也就无法展示自定义音量视图。代码大概长下面这样</p><pre data-language="objc" class="hljs"><code>- (<span class="hljs-keyword">void</span>)dealloc {
    [[<span class="hljs-built_in">AVAudioSession</span> sharedInstance] removeObserver:<span class="hljs-keyword">self</span>
                                         forKeyPath:<span class="hljs-built_in">NSStringFromSelector</span>(<span class="hljs-keyword">@selector</span>(outputVolume))];
}

- (<span class="hljs-keyword">void</span>)addObserver {
    [[<span class="hljs-built_in">AVAudioSession</span> sharedInstance] addObserver:<span class="hljs-keyword">self</span>
                                      forKeyPath:<span class="hljs-built_in">NSStringFromSelector</span>(<span class="hljs-keyword">@selector</span>(outputVolume))
                                         options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span>
                                         context:<span class="hljs-literal">nil</span>];
}

- (<span class="hljs-keyword">void</span>)observeValueForKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath
                      ofObject:(<span class="hljs-keyword">id</span>)object
                        change:(<span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSKeyValueChangeKey</span>,<span class="hljs-keyword">id</span>&gt; *)change
                       context:(<span class="hljs-keyword">void</span> *)context {
    <span class="hljs-keyword">if</span> ([change isKindOfClass:[<span class="hljs-built_in">NSDictionary</span> <span class="hljs-keyword">class</span>]]) {
        <span class="hljs-built_in">NSNumber</span> *volumeNum = change[<span class="hljs-string">@"new"</span>];
        <span class="hljs-keyword">if</span> (volumeNum) {
            [<span class="hljs-keyword">self</span> volumeDidChange:[volumeNum floatValue]];
        }
    }
}

- (<span class="hljs-keyword">void</span>)volumeDidChange:(<span class="hljs-built_in">CGFloat</span>)volume {
    <span class="hljs-comment">// 显示自定义音量提示</span>
}
</code></pre><h4>通知</h4><p>这种方式通过监听系统私有（未公开的）通知，名字是 <code>AVSystemController_SystemVolumeDidChangeNotification</code>，这个监听不会受到最大/最小音量时，调大/调小音量的影响，只要音量键按下，始终都会触发。但是这个通知由于是私有的，可能存在被拒风险，而且将来系统版本该通知名字发生改变，由于是硬编码而不像其它系统通知使用的是常量，会导致监听不到的问题。</p><p>代码大概长这样</p><pre data-language="objc" class="hljs"><code><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSNotificationName</span> <span class="hljs-keyword">const</span> kSystemVolumeDidChangeNotification = <span class="hljs-string">@"AVSystemController_SystemVolumeDidChangeNotification"</span>;

- (<span class="hljs-keyword">void</span>)dealloc {
    [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="hljs-keyword">self</span>];
}

- (<span class="hljs-keyword">void</span>)addObserver {
    [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="hljs-keyword">self</span>
                                             selector:<span class="hljs-keyword">@selector</span>(volumeDidChange:)
                                                 name:kSystemVolumeDidChangeNotification
                                               object:<span class="hljs-literal">nil</span>];
}

- (<span class="hljs-keyword">void</span>)volumeDidChange:(<span class="hljs-built_in">NSNotification</span> *)notification {
    <span class="hljs-built_in">NSString</span> *category = notification.userInfo[<span class="hljs-string">@"AVSystemController_AudioCategoryNotificationParameter"</span>];
    <span class="hljs-built_in">NSString</span> *changeReason = notification.userInfo[<span class="hljs-string">@"AVSystemController_AudioVolumeChangeReasonNotificationParameter"</span>];
    <span class="hljs-keyword">if</span> (![category isEqualToString:<span class="hljs-string">@"Audio/Video"</span>] || ![changeReason isEqualToString:<span class="hljs-string">@"ExplicitVolumeChange"</span>]) {
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-built_in">CGFloat</span> volume = [[notification userInfo][<span class="hljs-string">@"AVSystemController_AudioVolumeNotificationParameter"</span>] floatValue];
    <span class="hljs-comment">// 显示自定义音量提示</span>
}
</code></pre><p>以上两种方式各自优劣势都已经列出来了，上面说到的三个应用，<code>Instagram</code> 使用的是通知的方式，即刻和哔哩哔哩都是用 <code>KVO</code> 的方式。具体要选那种方式，就看具体需求了，如果在最大或最小时，调节音量可以接受不展示音量视图的话，个人推荐使用 <code>KVO</code> 的形式。</p><h3>遇到的问题</h3><p>上面阐明了原理和实现方式，接下来就是接入到项目中真正使用了，接入项目后发现问题还不少。</p><h4>坑0x0001</h4><p>由于我们使用了 <code>window</code> 来显示自定义音量提示，所以 <code>window</code> 需要提前创建好，有一个需要注意的是 <code>UIWindow</code> 的 <code>hidden</code> 默认是 <code>YES</code>，由于上面说到系统的音量视图必须在可见视图层级内，所以创建的这个 <code>window</code> 必须要可见，然后尽量不影响交互，将其 <code>userInteractionEnabled</code> 置为 <code>NO</code>，且要让其不可见时层级最低，<code>windowLevel</code> 设置为 <code>UIWindowLevelNormal</code>。</p><pre data-language="objc" class="hljs"><code><span class="hljs-keyword">self</span>.window = [[<span class="hljs-built_in">UIWindow</span> alloc] initWithFrame:[<span class="hljs-built_in">UIScreen</span> mainScreen].bounds];
<span class="hljs-keyword">self</span>.window.hidden = <span class="hljs-literal">NO</span>;
<span class="hljs-keyword">self</span>.window.windowLevel = <span class="hljs-built_in">UIWindowLevelNormal</span> - <span class="hljs-number">1</span>;
<span class="hljs-keyword">self</span>.window.rootViewController = [[<span class="hljs-built_in">UIViewController</span> alloc] init];
<span class="hljs-keyword">self</span>.window.backgroundColor = [<span class="hljs-built_in">UIColor</span> clearColor];
<span class="hljs-keyword">self</span>.window.userInteractionEnabled = <span class="hljs-literal">NO</span>;
</code></pre><h4>坑0x0010</h4><p>这样一切看起来很正常，但是有一个问题就是有一些地方通过 <code>[[UIApplication sharedApplication].windows firstObject]</code> 来进行一些操作，比如展示 <code>toast</code> 或者收起键盘的 <code>UIControl</code>，所以会导致其不可见或者无法响应交互。 所以上面代码改成</p><pre data-language="objc" class="hljs"><code><span class="hljs-keyword">self</span>.window = [[<span class="hljs-built_in">UIWindow</span> alloc] initWithFrame:<span class="hljs-built_in">CGRectZero</span>];
<span class="hljs-keyword">self</span>.window.clipsToBounds = <span class="hljs-literal">YES</span>;
<span class="hljs-keyword">self</span>.window.windowLevel = <span class="hljs-built_in">UIWindowLevelNormal</span>;
</code></pre><p>嗯，运行起来，那些寻找 <code>firstObject</code> 的地方都正常了，但是...由于存在开屏广告，而且开屏广告用的也是 <code>window</code>，而且他会在自己要显示时，调用 <code>makeKeyAndVisible</code> 方法，消失的时候直接将其置为 <code>nil</code>，导致系统会自己寻找其它的 <code>window</code> 当做 <code>keyWindow</code>，这个时候不知道为什么会找到我们音量提示的 <code>window</code>？难道是因为 <code>[UIApplication sharedApplication].delegate.window</code> 层级是 <code>Normal</code>，音量提示 <code>window</code> 层级也是 <code>Normal</code>，然后会将后加入的 层级为 <code>Normal</code> 的 <code>window</code> 设置为 <code>key window</code>？暂时还不懂，有知道的大神麻烦指点一下。 这样看来，这种修改方式也不太行，会导致其它地方取 <code>keyWindow</code> 的时候，取错掉。</p><h4>坑0x0011</h4><p>嗯，那索性直接用 <code>[UIApplication sharedApplication].delegate.window</code> 这个来显示音量提示，最多也就出现 <code>Alert</code> 或键盘的时候，音量提示会被遮罩挡住，概率也比较小还好。于是改成下面代码</p><pre data-language="objc" class="hljs"><code><span class="hljs-keyword">self</span>.window = [<span class="hljs-built_in">UIApplication</span> sharedApplication].delegate.window;
</code></pre><p>但是这个时候会发现，iPhoneX 下音量提示会被状态栏挡住，wtf！！！那么好吧，在音量显示的时候隐藏一下状态栏，音量消失的时候回复一下之前记住的状态栏状态，但是如果存在两个页面状态栏显隐不一致的情况，就会出现问题。同时在某些 <code>present</code> 起来的页面，音量提示死活不显示，但是用 <code>Xcode</code> 自带视图层级调试工具看，音量提示视图的 <code>frame</code>、<code>alpha</code>、<code>hidden</code> 属性都是正常的，但就是没有显示出来。后面将提示视图 <code>layer</code> 的 <code>zPosition</code> 提高之后，就可以显示出来了，真的很神奇。</p><p>一步步下来，填完一个坑，又来一个，感觉是个无底洞，永远填不满。搞了一晚上，一筹莫展。</p><h5>完美填坑</h5><p>最后灵光一闪，如果自定义一个 <code>Window</code>，继承自 <code>UIWindow</code>，然后复写 <code>becomeKeyWindow</code> 方法，在这个方法里让自身不成为 <code>keyWindow</code> 同时将 <code>[UIApplication sharedApplication].delegate.window</code> 设置为 <code>keyWindow</code>，大致代码长这样：</p><pre data-language="objc" class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">VolumeWindow</span> : <span class="hljs-title">UIWindow</span></span>

<span class="hljs-keyword">@end</span>

<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">VolumeWindow</span></span>

- (<span class="hljs-keyword">void</span>)becomeKeyWindow {
    [<span class="hljs-keyword">self</span> resignKeyWindow];
    [[<span class="hljs-built_in">UIApplication</span> sharedApplication].delegate.window makeKeyWindow];
}

<span class="hljs-keyword">@end</span>
</code></pre><h4>坑0x0100</h4><p>拍摄页拍摄之前系统音量提示是可以被替换的，但是拍摄一段之后，莫名其妙音量按钮按下后自定义提示不见了，出现了系统的铃声提示。一脸懵逼，后面发现是由于设置了 <code>AVCaptureSession</code> 的 <code>usesApplicationAudioSession</code> 为 <code>NO</code>，会导致在拍摄之后会变成铃声，这个和是否替换系统音量提示无关。这个属性是由于项目中很久之前需要兼容 <code>iOS6</code>，然后一直遗留着这个属性设置没有删除。由于 <code>iOS7</code> 之后，<code>AVCaptureSession</code> 和应用使用的是同一个 <code>AudioSession</code>，支持同时播放和录制且不会受到影响和打断，所以不需要再去设置这个属性。</p><h4>坑0x0101</h4><p>做了以上操作，在 iPhoneX 下，当拉起控制中心，并上下滑调整音量后，再回到应用，会发现自定义音量视图会出现在状态栏下面，猜测虽然在应用内自定义音量视图 <code>window</code> 层级高于状态栏 <code>window</code> 层级，但是由于状态栏是全局的，在重新进入到应用时会出现状态栏层级高于音量视图。所以就索性仅在应用为 <code>active</code> 的情况下才处理 <code>KVO</code>。</p><p>最后一个需要注意的点是在语音电话（或者其它使用系统音量的场景下）时，去自己应用内调节音量是无效，因为这个时候音量其实代表的是系统在占用，系统优先级高于应用，所以在这些场景下，即使在应用内调节音量，也无法触发出自己的音量视图。</p><p>然后上面所有问题都迎刃而解了。</p><p>最后推荐一个开源库：<a href="https://github.com/gizmosachin/VolumeBar" target="_blank">VolumeBar</a></p>]]></content><tag>原创</tag></entry><entry><title>GMTC 之旅</title><link href="/posts/Some-thoughts-On-GMTC-2018"/><url>/posts/Some-thoughts-On-GMTC-2018</url><content type="html"><![CDATA[<p>上周凑巧有机会拿到 GMTC 的票，然后去现场体验了一下。这里主要记录第一次参加这种线下大会的一些感受。</p><p>大会在 6.21~6.22 进行，由于时间问题，我只去了两个自己感兴趣的专题：性能优化专场以及 iOS 新技术专场。 性能优化专场在21号下午进行，当天早上 <code>Flutter Release Preview 1</code> 放出，更多关于 Flutter 的文章，可以在我们公众号<code>知识小集</code>上获取。</p><h3>性能优化专场</h3><p>当天下午提前一小时从公司出发，1：30 到现场时，会场已经满座，只能坐地下，第二场一些人走了之后才空出一些座位。</p><p>第一场是 <code>LinkedIn</code> iOS 工程师带来的《LinkedIn 移动应用的性能优化实践》，分享了领英的一些性能优化实践。 随着应用体量（功能）变得越来越庞大，最初的应用架构会变得越来越撑不住，所以需要适时调整合理的应用架构。领英使用组件化和标准化来提高代码复用率以及项目复杂度，进而减少了线上的崩溃率和性能问题。建立完善的性能监控体系对线上用户的性能数据进行分析，发现问题并解决问题，同时使用 AB 实验来快速验证效果。最后作者通过一个实际案例来阐述，以上几点是如何在项目中落地实践的。通过线上监控发现页面加载比较慢，主要原因有：网络请求多、数据量大、页面渲染慢，对这三个分别采取对应措施来解决：网络优化，使用 <code>http/2</code>、数据简化（服务端精简返回字段）、布局优化（领英开源库 <code>LayoutKit</code>，将布局计算放到后台线程）。</p><p>其实大部分应用都可能存在上述问题，从网络发起到页面完整渲染展示，里面很多的关键节点都可能导致页面加载过慢。对于数据简化这一块，作者有提到他们内部有一个 <code>Frontend Deco</code> 平台，客户端可以根据实际情况选择需要服务端返回的字段，然后生成一个 <code>recipe_id</code>，请求时带上这个参数，则只会返回对应的数据，进而实现数据精简。</p><blockquote><p>这里有一点很疑问，理论上性能优化是肯定能改善用户体验的，这里对性能优化做 AB 实验是不是有点多此一举？</p></blockquote><blockquote><p>分享者的回答： <img class="lazyload" data-src="/oldimages/15407047702510.jpg"/></p></blockquote><p>剩下的 3 场主要是前端和安卓上的性能优化，由于自己对于安卓和前端技术一无所知，所以只是大概听了一下。 印象比较深的是阿里的监控体系，还原用户“事发现场”，大致原理就是记录首屏时的所有数据，用户操作导致的增量数据页实时记录，进而实现用户操作现场的还原。 爱奇艺的“极致”性能优化，对于功耗的测量，使用 <code>PowerMonitor</code> 来检测分析，同时使用 AI 来做自动化测试。同时开源了 <code>LiteApp</code>，感兴趣的可以自行在 <code>GitHub</code> 上搜索。</p><h3>iOS 新技术专场</h3><p>这一场在22号早上9点半开始，9点到达会场，人没有昨天那么多，空位很多。这个专题出品人是嘀嘀出行的戴铭老师。这个专场有三个主题，讲师分别来自 Instagram、美团、美甲帮。</p><p>来自 Instagram 的工程师主要分享了复杂列表的解决方案、对照实验、以及加快编译速度。 复杂列表使用他们自己开源的 <code>IGListKit</code> 以及 <code>MVVM</code> 架构来实现代码复用，各自业务团队代码集中在 <code>SectionController</code> 来达到解耦，各个业务团队只需专注于自己的业务逻辑。同样 Instagram 也通过 AB 实验来抉择出一些较好的产品需求，同时通过 AB 实验来保持产品的快速迭代。同时随着 AB 实验的增多，难免会遇到一些互斥实验或者互相影响的实验，所以在设计一些实验时，也需要尽量避免这种情况。对于可能互相干扰的实验，作者举了一个例子以及可能的几个解决方案，思路也是很不多的，具体内容大家可以去官网上找到对应的 PPT 链接，下载查看。 最后一个分享点，也是目前大部分 iOS 开发者的槽点，就是 <code>Xcode</code> 的编译速度。随着工程及代码量的增大，编译速度也随之变慢，从原来的十几秒到几分钟到半小时（真正的“带薪编译”），编译时的心情也依次改变：😀-&gt;🙂-&gt;😰-&gt;😡-&gt;💀。Facebook 内部使用 <code>Buck+Focus</code> 来加快编译速度，<a href="https://github.com/facebook/buck" target="_blank">Buck</a> 目前已开源，据作者说，使用 <code>Buck+Focus</code> 后，编译速度又能到十几秒，感兴趣的可以尝试一下。</p><p>来自美团的臧成威老师分享了他们即将开源的面向对象的响应式架构：<code>EasyReact</code> 以及 <code>EasyMVVM</code>，相信用过 <code>ReactiveCocoa</code> 的同学都很清楚，每次调试时，调用栈非常深，而且中间的调用栈内容几乎没啥用处，调试起来比较费劲，作者表示 <code>EasyReact</code> 相对于 <code>ReactiveCocoa</code>，同样的5次变换操作，前者调用栈只有10层，而 <code>ReactiveCocoa</code> 有50层。关于其它的对比，可以参考一下作者放出的 <code>benchmark</code> 对比图</p><img class="lazyload" data-src="/oldimages/15304329513135.jpg"/><p>最后美甲帮的靛青分享了他的解决异构列表的开源库 <a href="https://github.com/DianQK/Flix" target="_blank"><code>Flix</code></a>。主要是通过几个实例来一步步给出 Flix 的设计理念，以及一些使用场景，会上代码涉及的较多，感兴趣的可以自行去 GitHub 上翻阅对应源码。</p><h3>感受</h3><p>AB 实验作为一种快速验证想法的工具，目前国内外大公司应该都有在使用，相对于传统的版本迭代，AB 实验可以较好的缩小迭代周期，在以数据结果为导向的情况下，也能快速得出结论，不需要做过多争辩。但同时它也带来了一些挑战，比如 AB 实验的设计，以及对实验结果的分析等。</p><p>性能优化作为每个开发者都应该掌握的技能，开发过程中需要多考虑性能上的问题，不能一味追求需求完成速度，还要兼顾质量。</p><p>整个两场专题听下来，感受最深的就是几乎每个小主题都在分享自己的开源框架，一方面可以提高自己公司的影响力，另一方面也可以吸引到更多人。</p><blockquote><p>PS：以上所有场次的 PPT 均可在<a href="https://gmtc.geekbang.org/schedule" target="_blank">这里</a>下载到</p></blockquote>]]></content><tag>原创</tag><tag>杂谈</tag></entry><entry><title>时光的河如海流</title><link href="/posts/2018-Summary"/><url>/posts/2018-Summary</url><content type="html"><![CDATA[<p>老规矩，这次又是2018年的最后一天，是时候更新一下年终总结了，水一下，纯当一个记录~</p><h3>工作</h3><p>今年工作上的变动还是蛮大的，从年初的直播 SDK 拆分完成之后的交付，到4月份的时候去到美拍北京分部，再到12月底的离职，结束了在美图将近5年的时光，感谢在美图待的这几年，自己从一个无从下手的菜鸟慢慢变成一个得心应手的老菜鸟。由于自身原因（老婆在广州，后面生活部分也有提到），在年底的时候裸辞，然后去到广州，开启一段找工作之旅，希望年后有好消息😃。</p><img class="lazyload" data-src="/oldimages/wow.png" alt="wo"/><p>这一年来主要是在北京，自己的角色也发生了一些变化，稍微了解了一点点的“管理”的皮毛，也感谢这个机会，让自己在非技术层面上也有一定的收获。 到北京后主要是负责美拍 iOS 社区的相关开发，其中大部分都是日常迭代，乏善可陈。比较有成就感的两件事：</p><ul><li>总算实现了一套基于 YYModel 和 IGListKit 的方案来替代现有美拍基于 ResetKit(CoreData) 的方案，最终在新 App (<a href="https://itunes.apple.com/cn/app/vcus-%E7%94%A8%E9%9F%B3%E4%B9%90%E6%8B%8Dvlog/id1445969821?mt=8" target="_blank">VCUS</a>)中实践上线，不知道最终会不会在美拍中上线。后面也会更新一个系列，名字大概叫做《CoreData 从入门到放弃》，应该不会断更，可以期待一下~</li><li>优化 Feed 滚动，滚动过程中只加载最终停下的区域的 cell，并且将其解耦成通用逻辑，无明显侵入。</li></ul><h3>生活</h3><img class="lazyload" data-src="/oldimages/IMG_3390.png" alt="IMG_3390"/><p>生活应该从微信的免“单”惊喜开始，不知道是不是预兆，去年年底的时候微信支付在情人节那天，被免单了。然后在这一年，自己真的脱单了，顺便还结了婚，感恩。</p><p>4月份的时候确定了要去北京，碰巧大学好哥们研究生毕业要去北京爱奇艺，所以一起和他的两个研究生同学合租了，住在北五环上，4个人大概每个月1.2w的房租（可怕😂）。得亏大学老哥的一首好厨艺，几乎每个周末都会开荤，自己下厨，也偶尔周末一起出去健身，打球。</p><p>中间清明放假回了一趟家，然后在老家贷款买了一套房，也跻身泱泱房奴大军。。。</p><p>12月底离职来到老婆在的城市--广州，直接从冬天进入夏天，舒服。由于裸辞，没有工作，所以每天除了接老婆上下班，基本上就是提升厨艺和准备面试，以及上面提到的那个系列博客的撰写。</p><h3>旅游</h3><p>在北京其实比较少出去，也就刚来的时候去了一下南锣鼓巷以及后海酒吧一条街，喝了杯酒感受了一下。再就是团建一起自驾去了内蒙古乌兰布统大草原，挺美的，尤其是日落时候在一望无际的草原马路上开车，真的太棒了。</p><img class="lazyload" data-src="/oldimages/LRG_DSC00538.jpg" alt="LRG_DSC00538"/><p>8月份的时候和老婆去了长城、天安门、圆明园，本打算去故宫，只可惜时间太赶，过去的时候已经关门了，后面自己和同事去了一次😂。 国庆和中秋那段时间，休了一波婚假（算上中秋国庆，22天长假），带老婆和家人一起自驾去了桂林，只待了两天，后续有机会再去。 11月底的时候和老婆去了一趟成都和重庆，成都主要是春熙路和宽窄巷子那边打卡，然后吃了一些川大神推荐的成都名小吃。晚上吃蜀大侠火锅，排队排了3个多小时（尴尬），辛苦川大神下班跑这么远来请我吃火锅。本来想按川大神的建议自驾去四姑娘山，但是由于自己自驾经验少，而且川西路线都非常险，而且可能伴随高原反应，所以退而求其次，去了毕棚沟，事后也证明确实有高反，幸好没自驾。毕棚沟，5星推荐，一“图”以蔽之。</p><img class="lazyload" data-src="/oldimages/15492369881565.jpg" alt="-w912"/><p>然后由于裸辞，自己之前没买电脑，所以需要买一台 MBP，刚好小潘说他的工牌买 MBP 可以9.4折，所以元旦后去了一趟香港，买了台 MBP。</p><blockquote><p>这里需要吐槽一下，由于TimeMachine 恢复一直失败，然后我就格盘重装，结果因为家里网络问题，一直连接不上苹果的服务器，所以系统安装文件一直无法下载，然后预约天才吧，客服说帮我预约了当天晚上7.30的，然后还说如果你提前去的话可以先去周围的授权店让他们帮忙安装新系统。结果大老远跑到天河区，真是被气死，跑到其中一家客服推荐的授权店，我还没说完情况，那位店员就说装系统要收费300（？？？），然后就想着在周边吃个饭，然后等到7.30再去让天才装，结果去了之后，天才说我没有预约。呵呵，我去年买了个登山包，超耐磨。第一次预约天才吧，就遇到这种客服？？？后面自己回去倒腾半天，最后用手机热点总算下载好了安装镜像，🌶🐔🍎💊</p></blockquote><h3>游戏</h3><p>这一年，手游占比90%，基本上集中在吃鸡和农药。刚到北京的时候，主要是和同学打王者，他是王者段位，然后经常用小号带我，反正我负责坑就完事了。由于当时和老婆异地，每天都会视频，所以当时为了避免无聊，就把她也拉入坑，和我一起玩吃鸡。 英雄联盟玩的次数屈指可数，主要是不想去网吧，自己由于换电脑，没有装双系统，IG 夺冠后同学一直约，所以就装了双系统，偶尔周末玩一下午，反正我也是负责坑，有人 carry 就行。</p><h3>展望</h3><p>这一年不管是生活还是工作，都变化蛮大的。从单身变成两个人一起生活，从朝十晚七变成失业在家做“家庭煮夫”，用浩文和小潘的话来说就是“软饭硬吃”。总得来说2018算是比较惊喜的一年，感恩~</p><p>2019年（农历，嘿嘿）也即将来临，希望自己在工作和生活中都能稳步前进，订几个小目标：</p><ul><li>[ ] 多一些产出（开源项目和博客）</li><li>[ ] 学会 JS 以及 Python，最好能用在实际应用中</li><li>[ ] 刷 leetcode，重新学一下数据结构个算法</li><li>[ ] 把之前买的纸质书和电子书看完</li><li>[ ] 买车</li><li>[ ] 带老婆吃遍广州的米其林店</li></ul>]]></content><tag>杂谈</tag><tag>原创</tag></entry><entry><title>WWDC 2018：理解崩溃以及崩溃日志</title><link href="/posts/Understanding-Crash"/><url>/posts/Understanding-Crash</url><content type="html"><![CDATA[<blockquote><p>本文首发于<a href="https://juejin.im/post/5b1e833ce51d450686186557" target="_blank">掘金</a>。</p></blockquote><p>人非圣贤，孰能无过。每个人在写代码的时候，或多或少都会犯错，那么如何调试、找出问题所在呢？让我们跟随苹果工程师一起了解一下崩溃是如何产生以及如何解决它们的吧。</p><h2>1. 基础知识</h2><p>崩溃是什么？崩溃是当应用想要做某件事的时候，被意外终止。</p><h3>1.1 崩溃为什么会发生</h3><p>主要是以下几方面原因</p><ul><li>CPU 无法执行的代码。</li><li>被操作系统“强杀”，系统为了用户体验，会强制终止掉那些卡顿时间过长或者内存消耗过高的应用。</li><li>编程语言为了防止错误发生而触发的崩溃，如 <code>NSArray</code> 或者 <code>Swift.Array</code> 越界</li><li>开发者为了防止错误发生而触发的崩溃，比如一些非空判断的断言</li></ul><h3>1.2 崩溃长什么样子</h3><h4>1.2.1 调试器里</h4><p>当我们连接着 <code>Xcode</code> 进行调试的时候，遇到崩溃，大概长这个样子。 <img class="lazyload" data-src="/oldimages/15286007690540.jpg"/></p><p>当连着调试器的时候，我们能够拿到崩溃现场的一些调用栈以及对应的方法，当没有连着调试器的时候，系统会将崩溃日志存储到磁盘当中。</p><h4>1.2.2 崩溃日志里</h4><p>通常情况下，<code>release</code> 模式的应用的崩溃日志是没有符号化的，日志内记录的都是地址。我们可以通过 <code>Xcode</code> 来将崩溃日志进行符号化，解析出对应文件名、方法名以及对应崩溃在第几行。</p><h3>1.3 获取崩溃日志</h3><p>获取崩溃日志的方式很多，我们先来了解一下如何通过 <code>Xcode Organizer</code> 来获取从 <code>TestFlight</code> 或<code> App Store</code> 下载的应用的崩溃日志。</p><h4>1.3.1 Organizer Window</h4><p>先来看一下下面这张图：</p><img class="lazyload" data-src="/oldimages/15286117125343.jpg"/><blockquote><p>下面数字 1~6 分别代表图中标注的 1~6</p></blockquote><ul><li>1.可以看到所有平台发布在 <code>App Store</code> 或者 <code>TestFlight</code> 上的应用。</li><li>2.崩溃日志列表，可以看到对应影响的设备数以及对应的平台、扩展（extension），如图中蓝色框标注的位置。</li><li>3.崩溃所在调用栈及崩溃位置的高亮。</li><li>4.在对应工程中打开崩溃所在的文件，并跳转到指定位置，方便追踪问题。</li><li>5.最近数据分析，包含系统和机型两个维度。</li><li>6.在崩溃数较多时，支持翻页。</li></ul><p>PS：上面6个只是简单介绍了一下主题部分，剩余的可以自行探索使用。比如搜索、对单个日志做一些笔记、以及将已修复的崩溃标记为已解决等等。</p><p>那么如何才能在 <code>Organizer</code> 中获取对应的崩溃日志呢？很简单，只需要做到下面几步</p><ul><li>1. 在 <code>Xcode</code> 中登录已付费的开发者帐号。</li><li>2. 上传应用到 <code>App Store</code> 或 <code>TestFlight</code> 时，一并上传符号文件。</li><li>3. 打开 <code>Xcode Organizer</code> 窗口，选中 <code>Crashes</code> tab(快捷键:<code>Cmd+Shift+6</code>)。</li></ul><h4>1.3.2 Devices Window</h4><img class="lazyload" data-src="/oldimages/15286130207605.jpg"/><p>连接上设备，打开 <code>Xcode</code>，使用快捷键 <code>Cmd+Shift+2</code> 来打开 <code>Devices Window</code>，选中对应设备，然后选择 <code>View Device Logs</code>，即可查看当前设备磁盘上的所有崩溃文件，找到应用对应的日志即可展开分析。</p><blockquote><p>有些时候，获取到的崩溃日志并没有符号化。这个时候需要自己做一些额外操作，这里可以参考我之前在<strong>知识小集</strong>分享过的一个小 tip——<a href="https://github.com/awesome-tips/iOS-Tips/blob/master/2017/12.md#ios%E5%BF%AB%E9%80%9F%E8%A7%A3%E6%9E%90%E5%B4%A9%E6%BA%83%E6%97%A5%E5%BF%97" target="_blank">iOS快速解析崩溃日志</a>。</p></blockquote><h4>1.3.3 其它途径</h4><ul><li><code>Xcode</code> 的自动化测试（得到的是已符号化的日志）</li><li><code>Mac</code> 自带的 <code>Console</code> 应用，获取 <code>Mac</code> 或者模拟器的崩溃日志</li><li>iOS设备可通过这种操作获取，打开【设置】-&gt;【隐私】-&gt;【分析】-&gt;【分析数据】拿到对应的未符号化的崩溃日志，然后通过系统自带的分享即可传输到对应的设备上进行分析。</li></ul><h3>1.4 符号化最佳实践</h3><ul><li>上传应用的符号文件，以便苹果后台可以直接符号化崩溃日志，最终得以在 <code>Xcode Organizer</code> 的 <code>Crashes</code>tab 中呈现。</li><li>保留应用归档文件，以便做本地符号化，只要有归档文件在，<code>Xcode</code> 会自动进行符号化。</li><li>在 <code>Xcode Organizer</code> 的 <code>Archive</code>tab 为已开启 <code>bitcode</code> 的应用下载 <code>dSYM</code> 文件。</li></ul><h2>2. 分析奔溃日志</h2><h3>2.1 崩溃日志的组成</h3><ul><li>崩溃摘要，主要记录一些基本信息，比如机型、系统版本、崩溃时间等</li><li>崩溃原因</li><li>崩溃信息（这一部分在真机上处于隐私原因，一般都是不可见的，在模拟器和 <code>MacOS</code> 上可见）</li><li>崩溃线程的调用栈</li><li>崩溃发生时，其它线程的调用栈</li><li>寄存器状态</li><li>已加载的可执行二进制文件</li></ul><h3>2.2 如何分析</h3><p>首先从崩溃原因中的崩溃类型开始</p><img class="lazyload" data-src="/oldimages/15286161511718.jpg"/><p>如上图的崩溃类型为 <code>EXC_BAD_INSTRUCTION</code>，它代表 <code>CPU</code> 尝试在执行一段不存在或无效的代码，而导致进行被“杀死”。</p><img class="lazyload" data-src="/oldimages/15286169917791.jpg"/><p>然后我们可以找到崩溃线程的调用栈的前几行，结合崩溃信息（如果有的话）进一步分析。找到崩溃栈中第一处二进制名为应用名称所在那一行，进到对应文件对应的代码行数进行查看（如上图中标红的那一行），然后进一步分析。上图中的崩溃可以很明显看出其原因是对 <code>nil</code> 进行了强制解包。</p><h3>2.3 断言和先决条件导致的崩溃</h3><p>断言和先决条件的意义在于当错误发生时，强制终止当前进程。</p><p>上述提到的对 <code>nil</code> 强制解包导致的崩溃是断言和先决条件中的一种。而它们还包含下面几种情况：</p><ul><li>数据越界访问</li><li>算术溢出</li><li>未捕获的异常</li><li>代码中的自定义断言</li></ul><h3>2.4 操作系统“杀死”应用导致的崩溃</h3><p>某些情况下，系统处于保护目的，会将一些异常的应用“杀死”。以下几种场景可能触发系统将应用“杀死”：</p><ul><li>看门狗事件，主线程长时间无响应</li><li>设备过度发烫</li><li>内存消耗殆尽</li><li>非法的应用签名</li></ul><p>以上几种场景导致的崩溃，其崩溃日志可以在上面提到的 <code>Device Window</code> 中查看，<code>Organizer Window</code> 并不一定能够收集到这些日志。更多细节可以参考苹果的这个技术讲座 <a href="https://developer.apple.com/library/archive/technotes/tn2151/_index.html" target="_blank">Understanding and Analyzing Application Crash Reports</a>。</p><p>先来看一个关于看门狗的例子。</p><img class="lazyload" data-src="/oldimages/15286187612409.jpg"/><p>上面的崩溃类型为 <code>EXC_CRASH (SIGKILL)</code>，<code>SIGKILL</code> 一般代表的是系统终止了进程的运行，这种信号无法被应用捕获，进而也就无法处理。终止原因为 <code>Namespace SPRINGBOARD, Code 0x8badf00d</code>，如果你有查看上面提到的关于崩溃日志的讲座，你应该会知道 <code>Code 0x8badf00d</code> 代表什么。从终止描述中来看，是由于启动时长超过了 19.97 秒。</p><blockquote><p>这次总算知道为什么看门狗对应的 <code>code</code> 是 <code>0x8badf00d</code> 了，从这次苹果工程师的发音上来看，这个 <code>code</code> 的发音同 <code>ate bad food</code>。</p></blockquote><h4>2.4.1 如何避免启动超时</h4><p>应用审核被拒的比较常见的原因就包含启动超时这一项。那么如何来避免这种情况发生呢？苹果工程师给了我们这些建议：</p><ul><li>在真机上测试，因为看门狗在模拟器以及调试阶段是被禁用的</li><li>在低性能设备上测试，高性能设备响应肯定会快，无法体现出真实效果</li></ul><h4>2.4.2 如何避免内存问题</h4><p>常见的内存错误包含：过度释放、野指针（访问已释放对象）、内存访问越界（比如 C 数组）。我们还是通过一个日志来分析一下具体问题。</p><img class="lazyload" data-src="/oldimages/15286203651661.jpg"/><p>由上图中标注的1，我们知道崩溃类型为 <code>EXC_BAD_ACCESS(SIGSEGV)</code>，这种类型崩溃主要是有两种情况导致：</p><ul><li>对只读的内存地址进行写操作</li><li>访问不存在的内存地址</li></ul><p>通过崩溃栈中的<code>objc_release</code>、<code>object_dispose</code> 等，我们更加确定这是由于内存问题导致的崩溃。我们通过这几个线索可以知道，<code>LoginViewController</code> 实例在调用 <code>deinit</code> 方法销毁相关属性的时候，发生了内存问题，进而导致崩溃的产生。</p><p>我们回到日志的第一部分中的<code>Exception Codes</code>，苹果的工程师说可以根据经验以及日志中的相关信息得出结论，对应的 <code>BAD_ADDRESS</code> 为 <code>0x7fdd5e70700</code>。原因是 <code>0x7fdd5e70700</code> 刚好在日志中的这一段 <code>MALLOC_TINY            00007fdd5e400000-00007fdd5e800000</code> 地址范围内。</p><p><strong>一些关于内存及释放的基础</strong></p><img class="lazyload" data-src="/oldimages/15286214423478.jpg"/><p><code>Objective-C</code> 对象以及一些 <code>Swift</code> 对象的内存布局如图，当一个对象有效（未释放）时以 <code>isa</code> 开始，<code>isa</code> 指向它所属的类。<code>objc_release</code> 主要是读取对象的 <code>isa</code> 指针，然后将 <code>isa</code> 指针解除对 <code>Class</code> 的引用。</p><p>正常情况下，一切都能照常工作。如果对象已经被释放，会发生什么呢？<code>free</code> 函数调用后，会将对象删除，并且将其插入到包含了其它已释放对象组成的链表中，同时将之前 <code>isa</code> 区域指向链表中下一个已释放对象。</p><img class="lazyload" data-src="/oldimages/15286229962132.jpg"/><img class="lazyload" data-src="/oldimages/15286230171741.jpg"/><p>当之前的 <code>isa</code> 内存区域被写入成 <code>rotated free list</code> 指针时，意味着访问这个地址返回的将是一个无效的内存地址，进而导致崩溃。所以当 <code>objc_release</code> 去解除 <code>isa</code> 引用时，访问到的是 <code>rotated free list</code>，所以崩溃就发生了。</p><p>所以可以分析出，肯定是在释放某个属性时，该属性已经被释放。我们能知道具体是哪个属性导致的么？答案是肯定的。</p><p>目前从崩溃的那一行来看，<code>__ivar_destroyer</code> 是编译器帮我们自动生成的函数，所以我们无从知晓具体是哪一行导致的问题。我们只知道这个类有如图三个属性：</p><img class="lazyload" data-src="/oldimages/15286236439932.jpg"/><p>但是从 <code>@objc LoginViewController.__ivar_destroyer + 42</code> 可以获取到一些信息，<code>+42</code> 代表着汇编里面的该函数的偏移量。我们可以对 <code>__ivar_destroyer</code> 函数进行反汇编，然后看偏移量为42对应获取的是哪个属性，在 <code>Xcode</code> 中可以使用 <code>lldb</code> 调试。</p><img class="lazyload" data-src="/oldimages/15286240224231.jpg"/><p>断点后分别输入上图中黄色字的命令，分别为 <code>command script import lldb.macosx.crashlog</code>，<code>crashlog /Users/.../RideSharingApp-2018-05-24-1.crash</code>，后面的路径需要替换成你的崩溃日志路径。<code>Xcode</code> 会自动检索二进制文件以及对应的 <code>dSYM</code> 文件，然后符号化显示在 <code>lldb</code> 控制台中。然后我们找到崩溃处的地址，执行如下命令，即可得到对应的反汇编代码：</p><img class="lazyload" data-src="/oldimages/15286333493975.jpg"/><p>我们不需要理解每一行汇编的意思，每行后面的注释可以帮助我们理解，根据注释可以知道 1、2、3 处代码分别代表着 <code>userName</code>、<code>database</code>、<code>views</code> 的释放。回到上面提到的 <code>+42</code>，我们找到第3处的第一行，有一点需要注意的是大部分情况下汇编的偏移地址是返回地址，所以调用 <code>objc_release</code> 是在上一行。所以可以判断出是在释放 <code>database</code> 时出现了问题。虽然我们目前还不知道具体问题所在，但是可以通过这些信息缩小查找问题的范围，可以查找使用到 <code>database</code> 的地方，来找到真正的问题所在。</p><h4>2.4.2 日志分析总结</h4><ul><li>理解崩溃日志产生的原因</li><li>检查崩溃栈信息</li><li>使用反汇编帮我们找到更多线索来分析 <code>bad address</code> 问题</li></ul><h4>2.4.3 常见内存错误</h4><ul><li>objc_msgSend 或者 retain/release 崩溃 <img class="lazyload" data-src="/oldimages/15286347974394.jpg"/><ul></ul></li></ul><ul><li>无法识别的方法异常 <img class="lazyload" data-src="/oldimages/15286348142914.jpg"/><ul></ul></li></ul><ul><li>abort() inside malloc/free</li></ul><h3>2.5 日志分析建议</h3><ul><li>不要只关注崩溃发生的那一行代码，多查看一下和崩溃相关的代码，比如上面那个崩溃代码并不是真正导致 <code>bug</code> 出现的原因</li><li>查看所有调用栈，不要只关注崩溃所在线程的调用栈，非崩溃线程调用栈可以帮助我们查看崩溃时应用所处状态</li><li>多查看一些崩溃日志，有些时候很多崩溃日志都是崩溃在同一个地方，但是某些崩溃日志会包含更多的信息</li><li>使用 <code>Xcode</code> 提供的工具来复现内存问题，比如 <code>Address Sanitizer</code> 或者 <code>Zombies</code></li></ul><h2>3. 多线程问题</h2><h3>3.1 崩溃日志中多线程问题的一些“症状”</h3><ul><li>最难复现和诊断的一类 bug</li><li>多线程问题通常会引起内存竞争</li><li>多个线程执行着相似代码</li><li>同一个 bug 可能会有不同的崩溃日志</li></ul><h3>3.2 使用 Thread Sanitizer 检测多线程问题</h3><p>多线程问题即使我们拿到日志大概率情况下也无法分析问题所在，即使连着 <code>Xcode</code> 调试也不一定能够稳定复现，即使运气好能复现也可能分析不出具体问题。所以我们可以借助 <code>Xcode</code> 提供的工具来帮我们分析，这个工具就是 <code>Thread Sanitizer</code>。通过快捷键 <code>Cmd+shift+,</code>，然后选则 <code>Diagnostics</code> tab，勾选 <code>Thread Sanitizer</code> 即可。如下图所示</p><img class="lazyload" data-src="/oldimages/15286367494006.jpg"/><ul><li>可稳定复现多线程 bug</li><li>在模拟器下也可进行</li><li>只查找当前正在执行的代码的问题</li></ul><h3>3.3 实用建议</h3><p>在创建 <code>GCD Queue</code>、<code>(NS)OperationQueue</code>、<code>(NS)Thread</code> 时，使用自定义名称，方便后续调试以及崩溃日志内查看。</p><pre data-language="Swift" class="hljs"><code><span class="hljs-keyword">let</span> queue = <span class="hljs-type">DispatchQueue</span>(label: <span class="hljs-string">"com.example.myapp.networking"</span>)

<span class="hljs-keyword">let</span> operationQueue = <span class="hljs-type">OperationQueue</span>()
operationQueue.name = <span class="hljs-string">"Networking OperationQueue"</span>
 
<span class="hljs-keyword">let</span> thread = <span class="hljs-type">Thread</span>(...)
thread.name = <span class="hljs-string">"Networking Thread"</span>
</code></pre><h3>3.4 额外建议</h3><ul><li>使用真机测试</li><li>尝试复现，从用户处拿到崩溃日志后根据调用栈尝试去复现问题</li><li>使用工具来查找难以复现的 bug，下面两个工具的更多使用方式可以参考 <a href="https://developer.apple.com/videos/play/wwdc2016/412/" target="_blank">WWDC 2016 Session 412 Thread Sanitizer and Static Analysis</a><ul><li>使用 <code>Address Sanitizer</code> 来查看内存问题</li><li>使用 <code>Thread Sanitizer</code> 来查看多线程问题</li></ul></li></ul>]]></content><tag>WWDC</tag></entry><entry><title>WWDC 2018：使用日志框架测量性能</title><link href="/posts/WWDC-2018-Signpost"/><url>/posts/WWDC-2018-Signpost</url><content type="html"><![CDATA[<blockquote><p>本文是 WWDC 2018 Session 405 的观后感，原视频和 pdf 可以在<a href="https://developer.apple.com/videos/play/wwdc2018/405/" target="_blank">这里</a>看到。 首发于<a href="https://xiaozhuanlan.com/topic/3789465012" target="_blank">小专栏</a>。</p></blockquote><p>众所周知，应用交互的流畅度决定了用户对这款用户的喜爱度，所以对于每个 iOS 工程师而言，应用的流畅程度是非常重要的。而这里所说的流畅度在工程师层面来理解就是应用的性能是否处于一个比较优的状态。那我们在发现页面卡顿时，如何去检测卡顿是哪一段代码引起的呢？目前业界的卡顿检测已经非常多了，比如 Instrument 的 Time Profile，各种基于 <code>runloop</code> 的卡顿率检测开源库。但是今天主要来说一说 iOS12 苹果为我们带来的一个新的检测方案，也就是基于 <code>OSLog</code> 的一套新 API。</p><p>好了，题外话讲完，我们正式进入正题。该 Seesion 主要有下面几部分组成：</p><ul><li>集成 signposts<ul><li>异步并行操作</li><li>添加原数据</li><li>控制 signposts 的启用和禁用</li><li>使用 Instruments 分析</li></ul></li></ul><p>首先先简单回顾一下 <code>OSLog</code>，苹果在2016年推出这个现代化的日志记录框架，用来获取系统调试信息，这个框架主要是为效率而生。可以看一个简单实例</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">let</span> logHandle = <span class="hljs-type">OSLog</span>(subsystem: <span class="hljs-string">"com.example.widget"</span>, category: <span class="hljs-string">"Setup"</span>)
os_log(.info, log: logHandle, <span class="hljs-string">"Hello, %{public}s!"</span>, world)
</code></pre><blockquote><p>PS: 更多内容可以参看 <a href="https://developer.apple.com/videos/play/wwdc2016/721/" target="_blank">WWDC 2016 Session 721 Unified Logging and Activity Tracing</a></p></blockquote><p>这里要介绍的 <code>Signpost</code> 对 <code>OSLog</code> 进行了一些扩展，新增了一些用于衡量性能的 API。首先我们来看看如何在代码中集成 <code>Signpost</code>。</p><h3>集成 Signpost</h3><h4>使用 signpost 计算耗时</h4><p>想象一下我们有这样一个应用，包含了一组图片的 feed 流，滑动过程中，我们会去加载 feed 流的封面，页面如下图所示。 <img class="lazyload" data-src="/oldimages/15358675135125.jpg" alt="-w200"/> 我们想要获取每张封面的加载耗时，如果使用 <code>Signpost</code> 相关 API 我们需要如何做呢？ 使用 <code>Signpost</code> 我们可以标记每个任务的开始和结束，然后将他们关联起来，调用的相关 API 也比较简单，我们只需要做一个简单的打点，通过两个关联的打点，我们就可以记录这个任务的具体耗时，如下图所示。 <img class="lazyload" data-src="/oldimages/15358678750813.jpg"/></p><p>伪代码如下</p><pre data-language="swift" class="hljs"><code><span class="hljs-comment">// 引入 os 框架</span>
<span class="hljs-keyword">import</span> os.signpost

<span class="hljs-comment">// 使用自定义标识和分类创建一个 log，subsystem 建议使用 bundle id，category 主要用于对相关联的操作进行分类</span>
<span class="hljs-keyword">let</span> refreshLog = <span class="hljs-type">OSLog</span>(subsystem: <span class="hljs-string">"com.example.your-app"</span>, category: <span class="hljs-string">"RefreshOperations"</span>)
<span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> panel.elements {
    <span class="hljs-comment">// 任务开始前打点</span>
    os_signpost(.begin, log: refreshLog, name: <span class="hljs-string">"Fetch Asset"</span>)
    fetchAsset(<span class="hljs-keyword">for</span>: element)
    <span class="hljs-comment">// 任务结束打点，注意  log 和 name 要和开始前的匹配，这样才会自动关联</span>
    os_signpost(.end, log: refreshLog, name: <span class="hljs-string">"Fetch Asset"</span>)
}
</code></pre><p>如果想要统计所有任务的耗时，也非常简单，只需要在 for 循环前后埋点即可，不过需要注意的一点是 name 的值，如上所述因为想要计算的所有任务的耗时，所以新起了一个值，来进行关联。代码如下</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">let</span> refreshLog = <span class="hljs-type">OSLog</span>(subsystem: <span class="hljs-string">"com.example.your-app"</span>, category: <span class="hljs-string">"RefreshOperations"</span>)
os_signpost(.begin, log: refreshLog, name: <span class="hljs-string">"Refresh Panel"</span>)
<span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> panel.elements {
    os_signpost(.begin, log: refreshLog, name: <span class="hljs-string">"Fetch Asset"</span>)
    fetchAsset(<span class="hljs-keyword">for</span>: element)
    os_signpost(.end, log: refreshLog, name: <span class="hljs-string">"Fetch Asset"</span>)
}
os_signpost(.end, log: refreshLog, name: <span class="hljs-string">"Refresh Panel"</span>)
</code></pre><p>整个时间轴看起来如下图所示 <img class="lazyload" data-src="/oldimages/15358689521743.jpg"/></p><h4>异步任务耗时的计算</h4><p>如果我们的任务是一步步循序渐进的，上面的方式是没问题的，但是实际应用场景中，大部分任务是异步同时进行的。因此上面的 name 唯一标识在异步并行的场景下，不再能满足我们的需求，因为各任务的起始时间是一样的，但是结束时间肯定不一样，如果都用相同的 name 来做唯一标识，时间轴肯定会存在重叠的情况，因此无法区分各个任务的耗时时间。 <img class="lazyload" data-src="/oldimages/15358714494675.jpg"/></p><p>因此为了解决上述问题，我们可以使用另一个 <code>Signpost</code> 的 API，叫做 <code>signpost ID</code>。通过 <code>signpost ID</code>，可以区分同种类型操作中的不同任务。所以即使两个任务时间轴有重叠，但是由于 <code>signpost ID</code> 的存在，系统就可以区分出这是两个不同的时间间隔，所以只要 <code>.begin</code> 和 <code>.end</code> 打点时传入的 ID 一致，系统就会把二者自动关联起来，计算耗时。代码如下：</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">let</span> refreshLog = <span class="hljs-type">OSLog</span>(subsystem: <span class="hljs-string">"com.example.your-app"</span>, category: <span class="hljs-string">"RefreshOperations"</span>)
<span class="hljs-keyword">let</span> spidForRefresh = <span class="hljs-type">OSSignpostID</span>(log: refreshLog)
os_signpost(.begin, log: refreshLog, name: <span class="hljs-string">"Refresh Panel"</span>, signpostID: spidForRefresh)
<span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> panel.elements {
    <span class="hljs-keyword">let</span> spid = <span class="hljs-type">OSSignpostID</span>(log: refreshLog, object: element)
    os_signpost(.begin, log: refreshLog, name: <span class="hljs-string">"Fetch Asset"</span>, signpostID: spid)
    fetchAssetAsync(<span class="hljs-keyword">for</span>: element) {
        os_signpost(.end, log: refreshLog, name: <span class="hljs-string">"Fetch Asset"</span>, signpostID: spid)
    }
}
notifyWhenDone {
    os_signpost(.end, log: refreshLog, name: <span class="hljs-string">"Refresh Panel"</span>, signpostID: spidForRefresh)
}
</code></pre><p>signpost ID 可以通过 OSSignpostID 构建函数传入一个 log handler，以及任意一个对象（可选）。后面的 <code>object</code> 参数非常有用，因为只要传入的 object 是一样的，那么生成的 ID 也是一样的（当然前提是 log handler 也要一致）。</p><p>从上面示例我们可以得知，只要 <code>.begin</code> 和 <code>.end</code> 的其它参数是一致的，系统就会自动将其匹配，这样就可以在任何地方去进行“打点”。</p><p>所以整个 API 总结一下，大概是下面这样一个层级。 <img class="lazyload" data-src="/oldimages/15358748792069.jpg"/></p><table><thead><tr><th align="center">参数</th><th align="center">示例</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">Log category</td><td align="center">"RefreshOperations"</td><td align="center">相关操作</td></tr><tr><td align="center">Signpost name</td><td align="center">"Fetch Asset"</td><td align="center">想要计算的某类操作</td></tr><tr><td align="center">Signpost ID</td><td align="center">spid</td><td align="center">同一类操作下的某个任务</td></tr></tbody></table><h4>添加自定义 Metadata</h4><p>看完上面部分，你可能会有个疑问：是否可以在 signpost 中携带一些额外信息呢？答案是肯定的。<code>os_signpost</code> 函数为我们提供了一些可选参数，用于传递上下文。传入的参数得是 os_log 格式的字符串，可以传入不同类型的参数以及动态字符串，最终这些字符串都会显示在 Instrument 中。 <img class="lazyload" data-src="/oldimages/15358795943113.jpg"/></p><h4>添加独立事件</h4><p>除了上面提到的自定义元数据，我们可能还想在 <code>.begin</code> 和 <code>.end</code> 之间记录一些特定的“点”，因此苹果给了我们一种新的类型，OSSignpostType.event。我们可以使用它来记录一些过程中的特定点，比如上面提到的图片加载的某个特定进度，或者记录加载过程中的用户点击行为等等。</p><img class="lazyload" data-src="/oldimages/15358802713581.jpg"/><pre data-language="swift" class="hljs"><code>os_signpost(.event, log: log, name: <span class="hljs-string">"Fetch Asset"</span>, <span class="hljs-string">"Fetched first chunk, size %u"</span>, size)
os_signpost(.event, log: log, name: <span class="hljs-string">"Swipe"</span>, <span class="hljs-string">"For action 0x%x"</span>, actionCode)
</code></pre><h4>Signpost 禁用及启用</h4><p>默认情况下，<code>Signpost</code> 是启用的，但是某些情况下，我们并不想开启它，比如 <code>Release</code> 模式下包或者提交到 <code>Appstore</code> 的包。 苹果工程师一再强调 <code>Signpost</code> 本身非常轻量，同时在它被触发的时候也做了很多优化，同时在编译器层面也做了一些优化来确保它作用于运行时之前，把很多工作推迟到 Instrument 的处理时期，所以当它被触发时几乎不会消耗系统资源。 所以为了可以根据条件来启/禁用 Signpost，系统提供了一个默认的 <code>OSLog.disabled</code> 的 <code>log handler</code>，使用此 <code>log handler</code> 创建的 <code>Signpost</code>，都会被禁用，所以只需几行代码就可以搞定是否需要开启 <code>Signpost</code> 的需求，亦即只需要根据条件修改 <code>log handler</code> 初始化方式即可。</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">let</span> refreshLog: <span class="hljs-type">OSLog</span>
<span class="hljs-keyword">if</span> <span class="hljs-type">ProcessInfo</span>.processInfo.environment.keys.<span class="hljs-built_in">contains</span>(<span class="hljs-string">"SIGNPOSTS_FOR_REFRESH"</span>) {
    refreshLog = <span class="hljs-type">OSLog</span>(subsystem: <span class="hljs-string">"com.example.your-app"</span>, category: <span class="hljs-string">"RefreshOperations"</span>)
} <span class="hljs-keyword">else</span> {
    refreshLog = .disabled
}
</code></pre><p>当然，如果有一些 <code>Signpost</code> 代码如果比较耗时，我们也可以通过判断当前 <code>log handler</code> 是否被禁用来进行下一步操作。示例代码如下</p><pre data-language="swift" class="hljs"><code><span class="hljs-comment">// 如果获取 info 比较耗时，那可以先进行一次判断</span>
<span class="hljs-keyword">if</span> refreshLog.signpostsEnabled {
    <span class="hljs-keyword">let</span> information = copyDescription() 
    os_signpost(..., information)
}
</code></pre><p>以上示例代码都是用的 <code>Swift</code>，但是在 C 代码中，它们也是可以用的。对应关系如下图，如果需要了解更多，可以进到对应的头文件，查看其使用方式和相关说明。 <img class="lazyload" data-src="/oldimages/15358883833924.jpg"/></p><h3>与 Instruments 配合使用</h3><p>这一章节，苹果工程师以一个本地徒步旅行的应用（参照上面截图）作为示例，展示了如何使用 <code>Signpost</code> 进行埋点，然后通过 Instrument 获取埋点数据，进而来进行对埋点的耗时分析计算。</p><h4>查看 Signpost 数据</h4><p>我们可以 Instruments(10) 来记录、查看和分析我们在上面说的所有的埋点。下面是 Demo 的一些相关背景：</p><blockquote><p>通常情况下，我们为了性能优化，会把一些耗时任务放到异步线程，等任务完成后再回到主线程，这样就很难对其进行时间的测量分析。当用户滑动的时候，就会同时触发多个图片下载任务。如果用户滑动非常迅速，那么很多图片在 cell 被重用时可能还没有下载完成，所以我们就需要取消这些下载任务，如果我们没有取消的话，就会平白多出几个我们并不想要的下载任务。</p></blockquote><p>cell 有一个 startImageDownload 方法用来下载图片，代码如下 <img class="lazyload" data-src="/oldimages/15358904937593.jpg"/> 每个下载任务开始时，会根据图片名称创建 <code>downloader</code>，然后根据 <code>downloader</code> 创建一个 <code>SignpostID</code> 用来作为这个下载任务的 <code>Signpost</code> 数据唯一标识，然后通过将图片名称传入到元数据中。</p><p>然后图片下载完成的回调如下 <img class="lazyload" data-src="/oldimages/15358908311971.jpg"/> 同样直接通过 <code>downloader</code> 创建一个 <code>SignpostID</code>，这样可以确保 <code>.begin</code> 和 <code>.end</code> 能够匹配。注意到这里传入的 metadata <code>"Finished with size %{xcode:size-in-bytes}llu"</code>，这里的 <code>xcode:size-in-bytes</code> 告诉 Xcode 和 Instrument 这个参数在分析和展示时要当做 <code>bytes</code> 来处理。它们被称为工程类型（engineering types），可以在<a href="https://help.apple.com/instruments/developer/mac/current/" target="_blank">Instruments Developer Help</a>查看更多相关信息。 <img class="lazyload" data-src="/oldimages/15358914508594.jpg"/></p><p>在 cell 被重用时，我们需要记录图片下载的 cancel 操作，代码如下 <img class="lazyload" data-src="/oldimages/15358915510212.jpg"/> 处理类似，不再赘述。</p><p>通过 Xcode-&gt;Product-&gt;Profile(或者快捷键 cmd+I) 来启动 Instrument。然后选取一个空白（Blank）配置，进行下面操作</p><blockquote><p>右上角 + 按钮，然后搜索 <code>os_signpost</code>，然后选中将其拖入到左边栏，然后点击 Record 即可。 <img class="lazyload" data-src="/oldimages/15358918715861.jpg"/></p></blockquote><p>一顿滑动之后，停止录制（Record），然后查看顶部面板，我们可以看到各个图片加载的耗时，以及我们在埋点时传入的元数据。 <img class="lazyload" data-src="/oldimages/15358920774831.jpg"/> 同时后续时间的一些 signpost 数据如下 <img class="lazyload" data-src="/oldimages/15358923459450.jpg"/> 从这张图我们可以看到同时下载数不超过5个，这样证明我们的 <code>cancel</code> 方法生效了。为了证明这一点，放大得到下图 <img class="lazyload" data-src="/oldimages/15358923147799.jpg"/> 可以看到滑动过程中确实产生了很多 metadata 是 <code>cancel</code> 的 signpost 数据。</p><p>如果我们想要看图片下载耗时，我们能可以看底部数据栏 <img class="lazyload" data-src="/oldimages/15358926294639.jpg"/> Instrument 会按照 <code>SignpostID</code> 进行汇总，然后给出各项数据，比如个数、最大值、最小值、标准差、平均值。同一个 <code>SignpostID</code> 又分为 <code>Finished</code> 和 <code>Cancel</code>。还记得上面提到 <code>size-in-bytes</code> 么？这里每一个 Finished 后面都跟了一个这张图片的字节数。如果想用 metadata 数据进行分析，我们可以切到下图所示的分类。</p><img class="lazyload" data-src="/oldimages/15358929757440.jpg"/><p>Instrument 根据 <code>log handler</code> 的 <code>subsystem</code>、<code>category</code>、<code>format string</code>、<code>arguments</code> 各个参数进行了一个分层。因为我们在格式化字符串中只有一个参数，所以这里只展示了 arg0。然后会根据 <code>size-in-bytes</code> 类型，算出总加载大小以及最大值、最小值、标准差、平均值，所以通过它，我们可以快速分析一些元数据传入的数据。</p><p>前面提到为了保证 OSLog 的轻量性，大部分工作被推迟到 Instrument 来处理，所以如果我们在录制的时候采用即时模式(默认)，数据直接交由 Instrument 处理，它就会实时展示和记录相关数据。当我们触发的 signpost 足够多时，那么整个流程会变慢，甚至你的 App 和电脑都将变得卡顿。所以为了避免这种情况，在每次录制前，最好先更改它的录制模式。操作方式就是长按录制按钮，然后选择录制选项（Recording Options），然后在弹出的面板进行类似下图的操作，将默认的即使模式（Immediate Mode）更改为你想要的模式，示例中选的是最后5秒。 <img class="lazyload" data-src="/oldimages/15358940972622.jpg"/></p><h4>兴趣点</h4><p>如果我们只想简单记录一些点击事件，但是又不想让这些点击事件淹没在上面的大量 <code>signpost</code> 数据中，也不想每次都创建空白配置，然后自行添加 <code>os_signpost</code> 配置，那么我们就可以使用兴趣点(<code>Points Of Interest</code>)的方式。具体如何操作的呢？其实和其它的 <code>signpost</code> 类似，不过创建 <code>log handler</code> 时，<code>category</code> 参数要传入 <code>.pointsOfInterest</code>，这是一种会被 Instrument 自动识别的特殊分类。 创建和使用代码示例如下图 <img class="lazyload" data-src="/oldimages/15358949360440.jpg"/> <img class="lazyload" data-src="/oldimages/15358949032555.jpg"/></p><p>运行 Instrument，然后选择 <code>Time Profile</code> 配置，该配置会自带兴趣点一栏的数据。 <img class="lazyload" data-src="/oldimages/15358951679891.jpg"/></p><h4>自定义 Instrument</h4><p>通过 Demo 演示了如何通过自定义 Instrument 来快速直接地进行记录和分析，展示面板基本类似上面的数据查看。至于如何创建自定义 Instrument，可以查看 <a href="https://developer.apple.com/videos/play/wwdc2018/410/" target="_blank">Session 410 Creating Custom Instruments</a> 来了解更多。</p><h3>总结</h3><p>通过使用 <code>signpost</code>，我们可以轻易地记录时间段，捕获感兴趣的元数据，然后通过 Instruments 来查看和分析 signpost 数据，查看时间花在哪些地方，更清楚的了解到程序的行为。</p>]]></content><tag>WWDC</tag></entry><entry><title>全新后台任务框架及最佳实践</title><link href="/posts/BackgroundTask"/><url>/posts/BackgroundTask</url><content type="html"><![CDATA[<img class="lazyload" data-src="/oldimages/15603537122161.jpg" alt="-w1617"/><blockquote><p><a href="https://xiaozhuanlan.com/topic/8362954017" target="_blank">WWDC 19 专栏文章目录</a> WWDC 2019 Session 707: <a href="https://developer.apple.com/videos/play/wwdc2019/707/" target="_blank">Advances in App Background Execution</a></p></blockquote><p>2010年 iOS4 时代，iOS 的多任务系统面世，至今已经9个年头，期间后台模式及场景也逐渐增多，这为开发者和用户带来了很多可能性。随着 iOS 版本的迭代，慢慢的越来越多的后台运行场景被苹果所支持。与此同时为了改善用户体验以及延长电池寿命，苹果对于应用后台任务有着比较严苛的限制及审核规则，只有特定使用场景，应用才可能在后台持续运行，比如导航、音乐播放，VoIP 等。如果我们的应用恰好符合后台模式的场景，那么应该怎样利用好这一点来给用户好的体验呢？相信通过这一集 Session，你心中应该会有一个比较明确的答案~</p><h2>概览</h2><p>目前苹果支持9种后台模式，具体类型可使用 Xcode 的 Capabilities 来查看，如下图所示</p><img class="lazyload" data-src="/oldimages/15603558945067.jpg" alt="-w1018"/><p>通过上图对比可以看到 Xcode11 将 <code>Newsstand downloads</code> 这种后台模式移除，并新增了一个 <code>Background processing</code>(后面会具体说)。这些后台模式都有 API 与之对应，苹果在设计后台任务相关 API 时，将以下3点作为主要考虑因素来确保流畅的用户体验。</p><ul><li><strong>电池</strong></li></ul><p>电量几乎时刻都在被消耗，那么如何保证后台任务尽可能的减小电量的消耗呢？答案就是在后台任务完成时及时调用对应的 <code>completion</code> 通知系统任务已结束，以此来减小电量的消耗。</p><ul><li><strong>性能</strong></li></ul><p>在日常使用情况下，手机上通常同时运行着多个应用，某个应用在前台时，其它的应用在后台。在资源有限的情况下，为了保证设备尽可能的流畅，系统会为每个应用智能分配 CPU 及内存的阈值，一旦应用超过对应阈值，将会被系统终止。 我们日常开发中发生的 <code>OOM(Out Of Memory)</code> 以及主线程长时间未响应而触发系统的“看门狗”，都是由于应用耗尽了系统分配的资源而被系统终止。</p><blockquote><p><strong>延展阅读</strong> 触发“看门狗”通常会生成一份 <code>Crash</code> 日志，日志内容类似下面这样，经典的 <code>0x8badf00d</code> Exception Type: EXC_CRASH (SIGKILL)Exception Codes: 0x0000000000000000, 0x0000000000000000Exception Note: EXC<em>CORPSE</em>NOTIFYTermination Reason: Namespace SPRINGBOARD, Code 0x8badf00dTermination Description: SPRINGBOARD, process-launch watchdog transgression: com.xxxx exhausted real (wall clock) time allowance of 20.00 seconds | | ProcessVisibility: Unknown | ProcessState: Running | WatchdogEvent: process-launch | WatchdogVisibility: Foreground | WatchdogCPUStatistics: ( | "Elapsed total CPU time (seconds): 2.910 (user 2.910, system 0.000), 7% CPU", | "Elapsed application CPU time (seconds): 0.000, 0% CPU" | )Triggered by Thread: 0 如果对系统 Crash 日志感兴趣，可以看看我去年写的这篇文章 <a href="https://vongloo.me/2019/02/22/Understanding-Crash/" target="_blank"><strong>WWDC 2018：理解崩溃以及崩溃日志</strong></a></p></blockquote><blockquote><p>大部分 OOM 的情况下一般会生成一份 <code>JetsamEvent</code> 开头的日志文件，可在设备的 <strong>设置-&gt;隐私-&gt;分析</strong> 中查看到，里面的内容会有崩溃现场的一些进程信息以及内存分配情况。更多关于 <code>JetsamEvent</code> 的介绍，可以查看这篇文章 <a href="https://satanwoo.github.io/2017/10/18/abort/" target="_blank"><strong>iOS内存abort(Jetsam) 原理探究</strong></a>。</p></blockquote><ul><li><strong>隐私</strong></li></ul><p>由于应用在执行后台任务时，用户是无感的，但是用户对于自己的隐私信息是敏感的，所以在相关 API 的设计时会告知用户，哪些数据会被使用。 从今年的 WWDC 的动作来看，苹果对用户的隐私越来越重视，这点非常值得称赞，比如今年推出的 <code>Sign In With Apple</code>、地理位置权限的变更、后台地理位置访问的弹窗等。当然，这不是开始也不是结束，为苹果爸爸点赞👍。</p><h2>最佳实践</h2><p>了解了后台任务相关 API 的设计初衷，是时候来看看如何实践才能保证流畅的用户体验以及延长电池寿命。</p><p>想象一下一个类似微信的即时通讯软件拥有的一些功能：即时消息、勿扰模式、VoIP、历史记录下载等，对于这些功能，结合系统提供的各种后台任务应用场景，该以何种姿势使用这些 API 呢？且往下看~</p><img class="lazyload" data-src="/oldimages/15601807272586.jpg" alt="-w1045"/><h3>即时消息</h3><p>即时消息肯定需要确保时效性，尽可能快的触达对方才能保证良好的用户体验。但是某些情况下（比如较差网络环境），不一定能马上将消息发送到对方，此时用户可能切回到桌面或者其它应用，那么如何才能保证发送消息这个操作完成呢？答案就是使用 Background Task Completion 相关 API。</p><pre data-language="Swift" class="hljs"><code><span class="hljs-comment">// Guarding Important Tasks While App is Still in the Foreground</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-number">_</span> message: Message)</span></span> {
    <span class="hljs-keyword">let</span> sendOperation = <span class="hljs-type">SendOperation</span>(message: message)
    <span class="hljs-keyword">var</span> identifier: <span class="hljs-type">UIBackgroundTaskIdentifier!</span>
    <span class="hljs-comment">// 1</span>
    identifier = <span class="hljs-type">UIApplication</span>.shared.beginBackgroundTask(expirationHandler: {
        <span class="hljs-comment">// 2</span>
        sendOperation.cancel()
        postUserNotification(<span class="hljs-string">"Message not sent, please resend"</span>)
        <span class="hljs-comment">// Background task will be ended in the operation's completion block below</span>
    })
    sendOperation.completionBlock = {
        <span class="hljs-comment">// 3</span>
        <span class="hljs-type">UIApplication</span>.shared.endBackgroundTask(identifier)
    }
    operationQueue.addOperation(sendOperation)
}
</code></pre><p>让我们依次看看上面标注的步骤：</p><ol><li>应用在前台时通过对应 API 创建一个后台任务，此时即使 app 进入后台，也会获得一定的时间来处理消息发送。</li><li>在系统给出的时间内还没有处理完，应用即将被挂起，则取消发送，同时本地 push 通知用户。</li><li>如果发送成功，则通知系统该任务已结束，以此降低对电量的消耗。</li></ol><blockquote><p>如果是 <code>Extension</code>，可以使用 <code>ProcessInfo.performExpiringActivity(withReason:using:)</code>。</p></blockquote><p>相信这种方式大家或多或少都用过，有些应用甚至用这个接口去做所谓的“保活”。但是这里要提醒大家注意一个点（说多了都是泪），<strong>就是 task 的 begin 和 end 的调用要对应</strong>，你会踩到我踩过的坑：没有成对调用的 <code>task</code> 会触发 <code>0x8badf00d</code> 看门狗。但是这里的 <code>Crash</code> 堆栈和上面说的的主线程卡太久而被强杀的堆栈是不一样的，具体可以看看这篇文章的分析：<a href="http://mrpeak.cn/blog/ios-background-task/" target="_blank"><strong>iOS App 后台任务的坑</strong></a>。</p><h3>电话</h3><p>有些时候会觉得打字麻烦而直接打电话，系统同样也提供了对应的 API————VoIP 通知。它是一种特殊的通知类型，可以唤起应用，提醒用户有电话呼入，代码实现起来也比较简单</p><pre data-language="Swift" class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">registerForVoIPPushes</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">self</span>.voipRegistry = <span class="hljs-type">PKPushRegistry</span>(queue: <span class="hljs-literal">nil</span>)
    <span class="hljs-keyword">self</span>.voipRegistry.delegate = <span class="hljs-keyword">self</span>
    <span class="hljs-keyword">self</span>.voipRegistry.desiredPushTypes = [.voIP]
}
</code></pre><p>同时必须在 <code>didReceiveIncomingPush</code> 回调中使用 CallKit 来处理 VoIP push 通知，否则系统会“杀”掉应用，并且系统可能在收到 VoIP 通知时不再唤起应用，示例代码如下：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-keyword">let</span> provider = <span class="hljs-type">CXProvider</span>(configuration: providerConfiguration)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pushRegistry</span><span class="hljs-params">(<span class="hljs-number">_</span> registry: PKPushRegistry, didReceiveIncomingPushWith payload:
PKPushPayload, <span class="hljs-keyword">for</span> type: PKPushType, completion: @escaping <span class="hljs-params">()</span></span></span> -&gt; <span class="hljs-type">Void</span>) {
    <span class="hljs-keyword">if</span> type == .voIP {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> handle = payload.dictionaryPayload[<span class="hljs-string">"handle"</span>] <span class="hljs-keyword">as</span>? <span class="hljs-type">String</span> {
            <span class="hljs-keyword">let</span> callUpdate = <span class="hljs-type">CXCallUpdate</span>()
            callUpdate.remoteHandle = <span class="hljs-type">CXHandle</span>(type: .phoneNumber, value: handle)
            <span class="hljs-keyword">let</span> callUUID = <span class="hljs-type">UUID</span>()
            provider.reportNewIncomingCall(with: callUUID, update: callUpdate) { <span class="hljs-number">_</span> <span class="hljs-keyword">in</span>
                completion()
            }
            establishConnection(<span class="hljs-keyword">for</span>: callUUID)
        }
    }
}
</code></pre><p>同时以下几点也可以关注一下：</p><ul><li><code>payload</code> 中填充尽可能多的信息，以便展示更加完善的 UI（当然不能超过其限制）。</li><li>因为电话的实时性很高，<code>payload</code> 中的 <code>apns-expiration</code> 的值尽可能小或者为0，以便通知能立即触发。</li><li>如果不想要类似系统电话的全屏 UI，也可以使用标准的推送 API 来触发 banner 样式。</li><li>如果想要自定义 push 内容，则可以使用 <code>Notification Service Extension</code>，比如想要做一些加密操作。</li></ul><blockquote><p>由于笔者没有实际使用过 <code>VoIP</code> 相关技术，所以这里推荐大家看看苹果的官方文档 <a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/EnergyGuide-iOS/OptimizeVoIP.html" target="_blank">VoIP 最佳实践</a> 以及闲鱼技术团队写的这篇文章<a href="https://juejin.im/post/5ae194adf265da0b9d77eb87" target="_blank">iOS VoIP电话：CallKit与PushKit的应用</a></p></blockquote><h3>勿扰模式</h3><p>聊完 VoIP，我们紧接着看看勿扰模式的最佳实践。微信中通常聊天列表里躺着几十个甚至上百个会话，有些活跃的群可能一天有上千条信息，如果一直收到 push，肯定会不胜其烦。所以一般都会对这个群开启消息免打扰模式，但是又不想错过重要信息（比如被别人@）。那么这种勿扰模式，在后台模式下该如何实现呢？使用静默推送！~<br><br>静默推送可以在用户无感知的情况下，将数据推送到设备上。只需要将 push payload 里的 <code>content-available</code> 的值设置为 <code>1</code>，同时 <code>payload</code> 中不要包含 <code>alert</code>、<code>sound</code>、<code>badge</code> 字段，示例如下：</p><blockquote><p>示例摘抄自 <a href="https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html" target="_blank">Creating the Remote Notification Payload</a> Listing 7-1</p></blockquote><pre data-language="JSON" class="hljs"><code>{
    <span class="hljs-attr">"aps"</span> : {
        <span class="hljs-attr">"content-available"</span> : <span class="hljs-number">1</span>
    },
    <span class="hljs-attr">"acme1"</span> : <span class="hljs-string">"bar"</span>,
    <span class="hljs-attr">"acme2"</span> : <span class="hljs-number">42</span>
}
</code></pre><p>当收到静默推送后，系统出于对电池寿命和性能的保证，会智能地在后台唤起应用去下载相关内容。</p><p>下图还是以消息免打扰为例，用户在前台对某个会话开启了消息免打扰，然后回到后台，一段时间后该会话有新的内容，但是用户开了勿扰模式，所以我们需要“偷偷地”更新会话内容，但是用户却无感知。这里“偷偷地”就是系统在收到静默推送时，会在合适的时机在后台唤起应用去加载该会话的新内容（该后台任务可以持续30秒）。等用户回到前台，会发现免打扰的会话里的内容也有了更新，极大提高了用户体验。</p><img class="lazyload" data-src="/oldimages/15602632236407.jpg" alt="-w1164"/><p>关于静默推送的其它几点 tips：</p><ul><li>必须将 <code>apns-priority</code> 设置为 <code>5</code>，否则系统不会唤起应用。</li><li><code>watchOS</code> 应用必须（其它平台则强烈推荐）将 <code>apns-push-type</code> 设置为 <code>background</code>。</li></ul><blockquote><p>以上涉及到 <code>payload</code> 里的相关字段的设置，其实是在向 APNs 服务器发起请求时，请求体里的相关字段，更多内容可参考<a href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/sending_notification_requests_to_apns?language=objc" target="_blank">Sending Notification Requests to APNs</a> 关于最后一点需要稍微吐槽一下，这集 Session Keynote 上是说 <code>watchOS</code> 必须设置，其它平台强烈推荐设置。但是官方文档却说从 iOS13 和 watchOS6 起，这个 <code>key</code> 必须设置，建议还是以文档为准。 <img class="lazyload" data-src="/oldimages/15602654307840.jpg" alt="-w782"/></p></blockquote><blockquote><p>关于推送测试，推荐一下这个工具 <a href="https://github.com/KnuffApp/Knuff" target="_blank">Knuff</a></p></blockquote><h3>历史记录下载</h3><p>当我们在新设备上登录时，会同步历史聊天列表，对于一些比较久远的会话记录，我们可以使用后台下载任务（Background URL Session）将其延迟下载。其实不仅仅是会话列表可以延迟放到后台任务去同步，其他的一些任务也是可以的，比如数据统计、照片备份等。不过是否放在后台任务去执行，还是需要结合时效性以及性能稳定性来决定。</p><p>后台下载任务示例代码如下：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-comment">// 配置任务</span>
<span class="hljs-keyword">let</span> config = <span class="hljs-type">URLSessionConfiguration</span>.background(withIdentifier: <span class="hljs-string">"com.app.attachments"</span>) 
<span class="hljs-keyword">let</span> session = <span class="hljs-type">URLSession</span>(configuration: config, delegate: ..., delegateQueue: ...)
 
<span class="hljs-comment">// 设置这个值为 true，告诉系统在合适的时机触发相应任务来保证良好的性能</span>
<span class="hljs-comment">// 如果任务比较耗时，建议将这个值设为 true</span>
config.discretionary = <span class="hljs-literal">true</span>
<span class="hljs-comment">// 设置超时时间</span>
config.timeoutIntervalForResource = <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>
config.timeoutIntervalForRequest = <span class="hljs-number">60</span>
<span class="hljs-comment">// 创建请求</span>
<span class="hljs-keyword">var</span> request = <span class="hljs-type">URLRequest</span>(url: url)
request.addValue(<span class="hljs-string">"..."</span>, forHTTPHeaderField: <span class="hljs-string">"..."</span>)
<span class="hljs-keyword">let</span> task = session.downloadTask(with: request)
<span class="hljs-comment">// 设置最早触发时间</span>
task.earliestBeginDate = <span class="hljs-type">Date</span>(timeIntervalSinceNow: <span class="hljs-number">2</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>)
<span class="hljs-comment">// 设置期望的发送和接收的数据包大小</span>
task.countOfBytesClientExpectsToSend = <span class="hljs-number">160</span>
task.countOfBytesClientExpectsToReceive = <span class="hljs-number">4096</span>
task.resume()
</code></pre><blockquote><p>更多信息可以查看<a href="https://developer.apple.com/documentation/foundation/url_loading_system/downloading_files_in_the_background?language=objc" target="_blank">Downloading Files in the Background</a>。这里值得注意的是，如果在后台任务下载过程中应用被系统终止，再次启动时，使用相同 <code>identifier</code> 创建的 <code>session</code> 系统将会从上一次终止的地方继续下载对应内容。但是如果用户手动通过多任务将应用终止的话，系统会取消所有后台下载任务，同时系统也不会自动在后台唤起应用。</p></blockquote><p>通过上面的四种场景分析，系统分别为我们提供了不同场景下该使用的 API，以及对应的最佳实践。当然还有一些场景上面例子并没有涉及，比如 <code>Background Fetch</code>、<code>Background Processing</code>。某些特定的后台任务需要在 <code>Xcode</code> 的 <code>Signing &amp; Capabilities</code>（<code>Xcode 10</code> 为 <code>Capabilities</code>）中勾选才能生效，具体如下图所示。</p><img class="lazyload" data-src="/oldimages/15602695626828.jpg" alt="-w1326"/><p>而我们上面提到的 VoIP 电话和静默推送需要将 <code>Voice over IP</code> 和 <code>Remote notifications</code> 选项勾起来。</p><h2>全新后台任务框架</h2><p>以上场景都有对应的 API 可用，但是对于其它场景呢？比如数据同步、照片备份、数据库清理等，有没有更便捷的方式呢？当然，且看 iOS13 推出的全新框架 <code>BackgroundTasks.framework</code>~</p><p>如本文题图那样，<code>BackgroundTasks.framework</code> 是一个全新的后台任务调度框架，同时对iOS、iPadOS、watchOS、tvOS 以及 Mac 上的 iPad 应用都支持。同样 iOS13 新增了一种后台模式 <code>Background processing</code>，同时对现有的后台刷新相关 API 进行了改善。</p><p>进到这个框架的类 API，会发现这个框架十分简洁，两种后台任务分别对应的类为 <code>BGProcessingTask</code> 和 <code>BGAppRefreshTask</code>，这两个类都是继承自一个抽象类 <code>BGTask</code>，然后再配合对应的<code>BGTaskRequest</code> 以及 <code>BGTaskScheduler</code>，就可以满足大部分后台任务的需求。</p><p>相关 API 一览：</p><pre data-language="Swift" class="hljs"><code><span class="hljs-comment">// task</span>
<span class="hljs-meta">@available</span>(iOS <span class="hljs-number">13.0</span>, *)
<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BGTask</span> : <span class="hljs-title">NSObject</span> </span>{
    <span class="hljs-keyword">open</span> <span class="hljs-keyword">var</span> identifier: <span class="hljs-type">String</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">open</span> <span class="hljs-keyword">var</span> expirationHandler: (() -&gt; <span class="hljs-type">Void</span>)?
    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setTaskCompleted</span><span class="hljs-params">(success: Bool)</span></span>
}

<span class="hljs-meta">@available</span>(iOS <span class="hljs-number">13.0</span>, *)
<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BGProcessingTask</span> : <span class="hljs-title">BGTask</span> </span>{
}

<span class="hljs-meta">@available</span>(iOS <span class="hljs-number">13.0</span>, *)
<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BGAppRefreshTask</span> : <span class="hljs-title">BGTask</span> </span>{
}

<span class="hljs-comment">// request</span>
<span class="hljs-meta">@available</span>(iOS <span class="hljs-number">13.0</span>, *)
<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BGTaskRequest</span> : <span class="hljs-title">NSObject</span>, <span class="hljs-title">NSCopying</span> </span>{
    <span class="hljs-keyword">open</span> <span class="hljs-keyword">var</span> identifier: <span class="hljs-type">String</span> { <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">open</span> <span class="hljs-keyword">var</span> earliestBeginDate: <span class="hljs-type">Date?</span>
}

<span class="hljs-meta">@available</span>(iOS <span class="hljs-number">13.0</span>, *)
<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BGAppRefreshTaskRequest</span> : <span class="hljs-title">BGTaskRequest</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(identifier: <span class="hljs-type">String</span>)
}

<span class="hljs-meta">@available</span>(iOS <span class="hljs-number">13.0</span>, *)
<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BGProcessingTaskRequest</span> : <span class="hljs-title">BGTaskRequest</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(identifier: <span class="hljs-type">String</span>)
    <span class="hljs-keyword">open</span> <span class="hljs-keyword">var</span> requiresNetworkConnectivity: <span class="hljs-type">Bool</span>
    <span class="hljs-keyword">open</span> <span class="hljs-keyword">var</span> requiresExternalPower: <span class="hljs-type">Bool</span>
}

<span class="hljs-comment">// scheduler</span>
<span class="hljs-meta">@available</span>(iOS <span class="hljs-number">13.0</span>, *)
<span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BGTaskScheduler</span> : <span class="hljs-title">NSObject</span> </span>{
    <span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">var</span> <span class="hljs-title">shared</span>: <span class="hljs-title">BGTaskScheduler</span> </span>{ <span class="hljs-keyword">get</span> }
    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">register</span><span class="hljs-params">(forTaskWithIdentifier identifier: String, using queue: DispatchQueue?, launchHandler: @escaping <span class="hljs-params">(BGTask)</span></span></span> -&gt; <span class="hljs-type">Void</span>) -&gt; <span class="hljs-type">Bool</span>
    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">submit</span><span class="hljs-params">(<span class="hljs-number">_</span> taskRequest: BGTaskRequest)</span></span> <span class="hljs-keyword">throws</span>
    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cancel</span><span class="hljs-params">(taskRequestWithIdentifier identifier: String)</span></span>
    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cancelAllTaskRequests</span><span class="hljs-params">()</span></span>
    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getPendingTaskRequests</span><span class="hljs-params">(completionHandler: @escaping <span class="hljs-params">([BGTaskRequest])</span></span></span> -&gt; <span class="hljs-type">Void</span>)
}
</code></pre><h3>BGProcessingTask</h3><p>首先来看看今年新提供的后台模式————Background Processing Task。</p><ul><li>这种后台模式会给应用几分钟的时间来处理相关任务，相比之前的几十秒有了比较大的提升。因此我们可以将一些可延迟到后台执行的任务放到这种模式下执行，也可以将一些 Core ML 的训练放到这种模式下执行。</li><li><strong>最重要的一点是，新框架允许我们关掉 CPU 的检测</strong>，因为之前系统出于对电池寿命的考虑，会将后台 CPU 占用较高的应用“杀死”，所以新框架的这个特性对于那些 CPU 占用较高的后台任务可以说是及时雨了，而要做到这个，仅仅只需要设置 <code>bgProcessingTaskRequest.requiresExternalPower = true</code> 即可。</li><li>同时我们只要需应用在前台时提交了对应请求，系统就会在适当的时机触发相应的任务。</li></ul><h3>BGAppRefreshTask</h3><p>了解完 <code>BGProcessingTask</code>，我们继续看一看 <code>BGAppRefreshTask</code>。</p><ul><li>虽然是新 API，但是规则和之前的 Background Fetch一样：有30秒的执行时间、让应用内容保持最新。</li><li>会根据用户使用应用的频次和时间段，来决定何时触发后台刷新任务。比如用户经常在早上 8 点和晚上 10 点会打开应用，系统则会在这两个时间点之前触发刷新任务，以保证用户总是看到最新的内容。这也就意味着如果应用使用的频次较低，系统触发的刷新任务的频次也就随之变低。同时下面两个 API 被废弃了，虽然在iOS、iPadOS、tvOS 任能使用，但是在 Mac 上将无法使用，所以尽快切到新的 API 吧~<ul></ul></li></ul><pre data-language="Swift" class="hljs"><code>    - (void)setMinimumBackgroundFetchInterval:(<span class="hljs-type">NSTimeInterval</span>)minimumBackgroundFetchInterval <span class="hljs-type">API_DEPRECATED</span>(<span class="hljs-string">"Use a BGAppRefreshTask in the BackgroundTasks framework instead"</span>, ios(<span class="hljs-number">7.0</span>, <span class="hljs-number">13.0</span>), tvos(<span class="hljs-number">11.0</span>, <span class="hljs-number">13.0</span>));
    
    - (void)application:(<span class="hljs-type">UIApplication</span> *)application performFetchWithCompletionHandler:(void (^)(<span class="hljs-type">UIBackgroundFetchResult</span> result))completionHandler <span class="hljs-type">API_DEPRECATED</span>(<span class="hljs-string">"Use a BGAppRefreshTask in the BackgroundTasks framework instead"</span>, ios(<span class="hljs-number">7.0</span>, <span class="hljs-number">13.0</span>), tvos(<span class="hljs-number">11.0</span>, <span class="hljs-number">13.0</span>));
    ```
    
在我们提交了相应后台任务后，系统会根据一些条件和规则（比如电量、应用使用频次、网络等）来适时地触发对应任务。我们和系统交互，主要是通过 `<span class="hljs-type">BGTaskScheduler</span>` 这个类。

![-w1325](/oldimages/<span class="hljs-number">15603593455627</span>.jpg)

如图所示，当应用或者 `<span class="hljs-type">Extension</span>` 在前台通过 `<span class="hljs-type">BGTaskScheduler</span>` 向系统提交后台任务请求（`<span class="hljs-type">BGRequest</span>`）后（图中 <span class="hljs-number">1</span>、<span class="hljs-number">2</span> 所示），系统在条件满足的情况下会在后台唤起应用，然后将对应的后台任务（`<span class="hljs-type">BBGTask</span>`）传给应用（上图步骤 <span class="hljs-number">3</span> 所示）。值得一提的是，系统后台唤起应用后，可能同时将多个后台任务传给应用，系统会给这些任务一定的时间去执行，但这里分配的时间不是针对每个任务，而是针对每次后台唤起，所以必须保证在有限时间内能够同时处理所有任务。还有一点要注意的是，`<span class="hljs-type">Extension</span>` 提交的任务请求，也会被分发到宿主应用，因为系统只会唤起宿主应用而不是 `<span class="hljs-type">Extension</span>`。

## <span class="hljs-type">Demo</span> <span class="hljs-type">Time</span>

通过上面我们对新的框架有了一个宏观上的了解，苹果爸爸也十分贴心的为这集 <span class="hljs-type">Session</span> 提供了 [<span class="hljs-type">Demo</span>](https:<span class="hljs-comment">//developer.apple.com/documentation/backgroundtasks/refreshing_and_maintaining_your_app_using_background_tasks?language=objc)。这里就不再详细展开，只指出值得注意的地方，感兴趣的同学可以自行下载 Demo 感受一下。</span>

* 想要新框架对应的特性，必须勾选对应的后台模式， `<span class="hljs-type">BGProcessingTask</span>` 对应 `<span class="hljs-type">Background</span> processing`，`<span class="hljs-type">BGAppRefreshTask</span>` 对应 `<span class="hljs-type">Background</span> fetch`。<span class="hljs-type">Xcode11</span> 的开启步骤如图所示。
    ![-w1119](/oldimages/<span class="hljs-number">15603641916974</span>.jpg)
* 代码中用到的任务标识符必须和 `<span class="hljs-type">Info</span>.plist` 中的一致，否则任务不生效，如图所示。`<span class="hljs-type">Info</span>.plist` 中对应的 key 为 `<span class="hljs-type">Permitted</span> background task scheduler identifiers`，同时标识符要确保全局唯一，推荐使用反域名的方式。
    ![-w1025](/oldimages/<span class="hljs-number">15603607054920</span>.jpg)
* 如果任务会占用较高 <span class="hljs-type">CPU</span>，强烈推荐将 `requiresExternalPower` 设置为 `<span class="hljs-literal">true</span>`。
* 任务请求提交后，任意位置设置断点或者暂停应用进到断点模式，输入以下两条指令来模拟触发任务以及提前终止任务，输入完成后，点击继续，会发现任务被正常触发或终止。**仅真机有效**。
    
    ```objc
    <span class="hljs-comment">// 模拟触发任务，TASK_IDENTIFIER 替换为想要测试的任务对应的标识</span>
    e -l objc -- (void)[[<span class="hljs-type">BGTaskScheduler</span> sharedScheduler] _simulateLaunchForTaskWithIdentifier:@<span class="hljs-string">"TASK_IDENTIFIER"</span>]
    
    <span class="hljs-comment">// 模拟终止任务，TASK_IDENTIFIER 替换为想要测试的任务对应的标识 </span>
    e -l objc -- (void)[[<span class="hljs-type">BGTaskScheduler</span> sharedScheduler] _simulateExpirationForTaskWithIdentifier:@<span class="hljs-string">"TASK_IDENTIFIER"</span>]
    ```
* 不要把任务的最早开始日期(`earliestBeginDate`)设的太大，推荐在一周内。
* 确保文件在锁屏下可访问，最好将文件访问等级设置成 `<span class="hljs-type">FileProtectionType</span>.completeUntilFirstUserAuthentication 
`，当然这也是 iOS7 之后系统的默认行为，**设备重启到用户首次解锁的这段时间，后台任务不会被触发**。
* 支持分屏的应用需要在合适的时机调用 `<span class="hljs-type">UIApplication</span>.requestSceneSessionRefresh(<span class="hljs-number">_</span>:)` 来告诉系统来更新多任务窗口下的应用截图。
* 不要在主线程上提交任务请求，尽量放到后台线程，避免阻塞 <span class="hljs-type">UI</span>

到此整个新框架以及一些最佳实践都已经介绍完毕，各位是不是迫不及待想动手试试？心动不如行动，赶紧动手试试吧。<span class="hljs-type">Enjoy</span>~

个人想到的一些新框架可能适用的点（`<span class="hljs-type">Keynote</span>` 上提到的机器学习的模型训练之类的就不再说了）

* 使用 `<span class="hljs-type">BGAppRefreshTask</span>` 提前拉取应用首屏需要的内容，减少用户启动后的等待时间（之前的 `background fetch` 也能实现）
* 数据同步，尤其是大文件，像谷歌相册、各种云盘之类的软件
* 日志上报，一些不需要那么实时的日志，可以考虑放到后台任务

&gt; <span class="hljs-type">PS</span>: 期待谷歌相册能适配一波，避免同步时一直得保持应用在前
</code></pre>]]></content><tag>WWDC</tag><tag>原创</tag><tag>后台任务</tag></entry><entry><title>一个不规范的 Category 写法导致的“血案”</title><link href="/posts/Attention-to-Category"/><url>/posts/Attention-to-Category</url><content type="html"><![CDATA[<p>名字取得有点标题党，不然没人愿意点进来😂😂😂</p><h3>1.背景</h3><p>项目前后两个版本，线上监控显示整体启动时间缩短了近 <strong>300ms</strong>，而且包体积也变小了 <strong>5M</strong>（提交到 App Store 的ipa包）。但是新版本没有大的需求插入，只是 <code>bugfix</code> 版本，启动阶段的代码也没有相关改动。为何会引起包体积和启动时间的变化呢？</p><img class="lazyload" data-src="/media/2020-03-11/15839096586934.jpg" alt="启动耗时&amp;包体积变化"/><p>使用 <code>Instrument</code> 多次跑耗时分析，发现两个版本启动阶段的 <code>getMethodNoSuper_nolock()</code> 函数的耗时的差异非常明显。关键是这个还是系统函数，看起来是消息发送阶段的耗时增加了。</p><img class="lazyload" data-src="/media/2020-03-11/15839137733724.jpg" alt="Instrument 启动阶段耗时对比"/><h3>2.继续分析</h3><p>上面 <code>Instrument</code> 的方法耗时在设置隐藏系统库之后，对比发现没有明显的变化，说明不是启动阶段（<code>didFinishLaunching</code> 到 <code>RootVC viewDidAppear</code>）有大的改动导致的，这样一下子也没法定位到问题。所以只能比对版本间的代码，这里使用的是 <code>Kaleidoscope</code>。</p><blockquote><p><code>Kaleidoscope</code> 具体配置可以参考 nico 之前的文章<a href="https://punmy.cn/2019/02/28/%E6%95%88%E7%8E%87%E7%A5%9E%E5%99%A8%20Kaleidoscope.html" target="_blank">代码比对神器 Kaleidoscope</a>。</p></blockquote><p>两个版本对比下来，代码的主要变更点是几个 <code>pod</code> 库的更新以及不影响启动速度的其它业务代码变更。于是基于控制变量法，打算在 <code>6.4.3</code> 的代码基础上轮流更新单个 <code>pod</code>，同时在比对的时候发现一处非常怪异的变更。6.4.3版本 <code>UIView+ConstraintHolder</code> 这个分类的接口声明和实现都放在 <code>.h</code> 文件，而6.5.5版本将对应的实现移入到了新建的 <code>.m</code> 文件里，如下图</p><img class="lazyload" data-src="/media/2020-03-11/15839097887060.jpg" alt="代码比对"/><p>看起来非常可疑，于是首先在 <code>6.4.3</code> 基础上只更新了这个分类所在的 <code>pod</code>，然后跑 <code>Instrument</code>，发现 <code>getMethodNoSuper_nolock()</code> 耗时回到了和 <code>6.5.5</code> 相当的水平。然后进一步，把这个 pod 的变更只留下对 <code>UIView+ConstraintHolder</code> 分类的更改上，其他的更改暂时去除，继续跑 <code>Instrument</code>，发现耗时还是和 <code>6.5.5</code> 基本持平，这样基本上可以确认是这个分类的变更导致的问题了。但是为了严谨性，也轮流更新其它单个 <code>pod</code>，发现耗时和 <code>6.4.3</code> 持平，也就进一步肯定问题出在那个分类上。</p><h3>3.合理猜测</h3><h4>3.1 包体积</h4><p>由于这个分类会被主工程中很多地方 <code>import</code>，而实现直接写在头文件中，相当于头文件的内容直接 <code>copy</code> 到对应文件，相当于把对应符号也编译到了对应的 <code>.o</code> 中，导致 <code>.o</code> 变大，也就解释了为什么包体积会变大。</p><h4>3.2 启动耗时</h4><p>由于是 copy 到多个文件内，相当于生成了多个具有相同方法的分类，导致 <code>UIView</code> 的方法列表变长，进而导致在 <code>UIView</code> 消息发送过程中的查找时间变长，也就是上面 <code>Instrument</code> <code>getMethodNoSuper_nolock</code> 这个方法耗时增大的原因。</p><p>相信大家都知道调用对象的方法，最终都是转化成 <code>objc_msgSend</code>(或其变种)，由于它是汇编实现的，最终间接调用到 <code>lookUpImpOrForward</code>，而 查看 <code>runtime</code> 源码可以看到 <code>lookUpImpOrForward</code> 的实现，可以看到在方法没有缓存时，会走到这个函数 <code>getMethodNoSuper_nolock</code>。</p><details>
<summary>📑 点击查看 `runtime` 源码 </summary>

```C++
IMP lookUpImpOrForward(Class cls, SEL sel, id inst, 
                       bool initialize, bool cache, bool resolver)
{
    IMP imp = nil
    // 中间省略了很多有缓存或者类未实现或未初始化时的处理代码
    
    // Try this class's method lists.
    {Method meth = getMethodNoSuper_nolock(cls, sel);
        if (meth) {log_and_fill_cache(cls, meth->imp, sel, inst, cls);
            imp = meth->imp;
            goto done;
        }
    }
    
    // Try superclass caches and method lists.
    {unsigned attempts = unreasonableClassCount();
        for (Class curClass = cls->superclass;
             curClass != nil;
             curClass = curClass->superclass)
        {   
            
            // 中间省略了很多父类有缓存时的处理代码
            // Superclass method list.
            Method meth = getMethodNoSuper_nolock(curClass, sel);
            if (meth) {log_and_fill_cache(cls, meth->imp, sel, inst, curClass);
                imp = meth->imp;
                goto done;
            }
        }
    }
    
    // 省略消息转发处理代码

 done:
    runtimeLock.unlock();

    return imp;
}

static method_t *
getMethodNoSuper_nolock(Class cls, SEL sel)
{runtimeLock.assertLocked();

    assert(cls->isRealized());
    // fixme nil cls? 
    // fixme nil sel?

    for (auto mlists = cls->data()->methods.beginLists(), 
              end = cls->data()->methods.endLists(); 
         mlists != end;
         ++mlists)
    {method_t *m = search_method_list(*mlists, sel);
        if (m) return m;
    }

    return nil;
}
```
</details><p>这里只看没有缓存的情况下，<code>lookUpImpOrForward</code> 会先从当前类的方法列表查对应方法，如果查到则填充，没有查到则继续查父类的方法列表，依次类推， <code>getMethodNoSuper_nolock</code> 其实就是遍历当前类的方法列表。</p><p>从这里我们可以看出，如果方法列表比较长，查找的耗时也会增加。由于我们是给 <code>UIView</code> 加了多个具有相同方法的分类，而启动时 <code>UIView</code> 及其子类几乎时刻都在接收消息，所以导致启动阶段耗时增加。其实时时刻刻 <code>UIView</code> 的消息发送过程都会有相应的耗时增加（无方法缓存的情况下）。尽管 <code>runtime</code> 会有方法缓存，但是缓存不会一股脑的递增，会有释放时机，否则内存肯定吃不消。关于 runtime 方法缓存以及消息发送细节可以查阅<a href="https://draveness.me/message" target="_blank">从源代码看 ObjC 中消息的发送</a>。下面引用了其中关于方法缓存的一段话：</p><blockquote><p>在缓存翻倍的过程中，<strong>当前类全部的缓存都会被清空</strong>，Objective-C 出于性能的考虑不会将原有缓存的 bucket_t 拷贝到新初始化的内存中。</p></blockquote><img class="lazyload" data-src="/media/2020-03-11/15839148461085.jpg" alt="调用层级"/><p>展开 <code>Instrument</code> 的调用栈也可以发现，<code>6.4.3</code> 很多 <code>UIView</code> 的方法调用都被列了出来。</p><h3>4.Demo 验证 &amp; 给出石锤</h3><p>上面的猜想停留在理论层面，如何验证呢？由于工程比较大，编译会非常耗时，于是搞了个 <code>Demo</code> 来验证上面的猜想。</p><p>新建4个测试类，再加一个头文件，里面放上从项目里拷贝出来的 <code>UIView+ConstraintHolder</code> 对应的接口和实现代码，目录如下</p><img class="lazyload" data-src="/media/2020-03-11/15839215574196.jpg" alt="目录"/><h4>4.1 包体积验证</h4><p>在4个测试类 <code>.m</code> 中都导入 <code>UIView</code> 的分类头文件，发现导入前后，<code>.app</code> 体积增加了 <strong>12KB</strong>，测试类对应的 <code>.o</code> 每个增加 <strong>10KB</strong>（iPhone 11 模拟器）。</p><img class="lazyload" data-src="/media/2020-03-11/15839343247169.jpg" alt="体积对比"/><p>通过 <code>Xcode</code> 查看文件预处理后的样子，也证实了 <code>import</code> 确实是 <code>copy</code> 了对应 <code>.h</code> 的内容，如下图</p><img class="lazyload" data-src="/media/2020-03-11/15839334801466.jpg" alt="预处理"/><p>同样我们还可通过 <code>linkmap</code> 来看 <code>.o</code> 中的符号，对比前后的 <code>linkmap.txt</code>，截取一部分如下</p><img class="lazyload" data-src="/media/2020-03-11/15839344765704.jpg" alt="linkmap"/><p><code>Test2</code> 的符号在 <code>import</code> 了头文件之后，新增了分类中的那几个方法。</p><p>包体积增大的石锤已找到。</p><h4>4.2 消息耗时</h4><p>首先在那个 <code>UIView</code> 分类里添加 <code>+ (void)load</code> 方法，然后跑起来发现 <code>load</code> 方法执行了 <strong>4</strong> 次，和上面提到的符号会在多个 <code>.o</code> 出现吻合。 由于 <code>Demo</code> 引用的次数不多耗时不明显，直接通过在项目内获取 <code>UIView</code> 的方法列表来证实上面猜测，代码如下</p><pre data-language="objc" class="hljs"><code>- (<span class="hljs-keyword">void</span>)printViewMethods {
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> methodCount;
    Method *methodList = class_copyMethodList([<span class="hljs-built_in">UIView</span> Class], &amp;methodCount);
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSInteger</span> i = <span class="hljs-number">0</span>; i &lt; methodCount; i++) {
        Method method = methodList[i];
        <span class="hljs-built_in">NSString</span> *methodName = [<span class="hljs-built_in">NSString</span> stringWithCString:sel_getName(method_getName(method)) encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>];
        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>, methodName);
    }
    free(methodList);
    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@"</span>, @(methodCount));
}
</code></pre><p>输出来的结果真的很惊人，那个分类里的每个方法（共5个方法）在 <code>log</code> 里出现了 <strong>3165</strong> 次，也就是说项目中 <code>UIView</code> 的方法列表加长了 <strong>15820(=3164 * 5)</strong>，而正常情况下其长度为 <strong>2118</strong>。通过上面的理论分析和这里的数据，可以得出：<strong>这样写真的非常影响 <code>UIView</code> 及其子类消息发送过程中的耗时</strong>。</p><h3>5.结论及复盘</h3><p>相信看到这里大家应该有一个清晰的结论了，就是：</p><p><strong><code>@implementation</code> 不要写在头文件，尤其是这个头文件可能被 <code>import</code> 到多个地方的情况下！！！</strong> <strong><code>@implementation</code> 不要写在头文件，尤其是这个头文件可能被 <code>import</code> 到多个地方的情况下！！！</strong> <strong><code>@implementation</code> 不要写在头文件，尤其是这个头文件可能被 <code>import</code> 到多个地方的情况下！！！</strong></p><p>重要的是请说三次。 否则会影响 ①包体积 ②消息发送时间（尤其是高频使用的类）。</p><p>回过头再来看 <code>Demo</code>，分类实现放在 <code>.h</code> 却被多个类引用的情况下编译器链接时是有给出警告的。</p><img class="lazyload" data-src="/media/2020-03-11/15839361693286.jpg" alt="Xcode 警告"/><p>为啥项目中没有得到警告呢（而且我们还开启了把警告当错误处理）？是因为这个分类在 <code>pod</code> 当中，而我们在 <code>podfile</code> 中使用 <code>inhibit_all_warnings!</code> 屏蔽了所有 <code>pod</code> 的 <code>warning</code>。 同时如果直接把类的声明和实现写在 <code>.h</code>，如果只被一处引用的话，编译器不会警告也不会报错，但是超过一处引用编译器链接时就会报符号冲突的错误。</p><img class="lazyload" data-src="/media/2020-03-11/15839360983965.jpg" alt="Xcode 报错"/><blockquote><p>1、文章中使用的设备是 iPhoneX iOS13.3,Xcode 11.3.1。Demo 使用 iPhone11 模拟器编译。 2、关于 linkmap 的组成推荐阅读<a href="http://blog.cnbang.net/tech/2296/" target="_blank">iOS APP可执行文件的组成</a> 3、文章中引用的 <code>runtime(756.2)</code> 源码来自<a href="https://github.com/RetVal/objc-runtime" target="_blank">objc-runtime</a> 4、关于 runtime 的更多文章，推荐这个<a href="https://draveness.me/tag/Runtime" target="_blank">系列</a></p></blockquote>]]></content><tag>Crash</tag></entry><entry><title>WWDC20 10077 - 使用 XCTest 消除动画卡顿</title><link href="/posts/Eliminate-animation-hitches-with-XCTest"/><url>/posts/Eliminate-animation-hitches-with-XCTest</url><content type="html"><![CDATA[<blockquote><p>本文基于 <a href="https://developer.apple.com/videos/play/wwdc2020/10077/" target="_blank">Session 10077 - Eliminate animation hitches with XCTest</a></p></blockquote><h2>概述</h2><p>iOS中动画无处不在，应用中优雅流畅的动画可以显著提升用户体验，同理卡顿也会影响用户体验。通过这个 WWDC Session，我们将学会如何通过 XCTest 来检测滑动和动画过程中的掉帧，进而在开发阶段就能解决问题，避免糟糕的用户体验。</p><h2>如何定义卡顿（Hitches）</h2><p>当用户在页面上操作时，比如上下滑或者点击导航栏上的返回按钮时，主要焦点集中在手势的交互上。良好的交互体验是提供“众享丝滑”的响应速度，反之用户将会感知到明显的卡顿。我们将这些用户可感知的“抖动”称之为卡顿（Hitches），卡顿是指某一帧画面的显示比预期要晚。卡顿会影响用户体验，甚至让用户失去对应用的兴趣（即卸载🐶）。</p><img class="lazyload" data-src="https://images.xiaozhuanlan.com/photo/2020/77b300f2422ba1981ad8744443c129c8.png"/><p>如图所示，我们可以逐帧来看动画过程，当我们缓慢移动时，前2帧按预期显示在屏幕上，滑动很流畅且是“跟手”的，但是第3帧停留在屏幕上的时间超出预期，滑动不再“跟手”，第4帧出现时，列表出现了一次跳变，然后滑动再次变得“跟手”。</p><h3>渲染原理</h3><p>为了搞清楚为什么会出现上面的状况，我们首先来看看画面是如何展示到屏幕上的。iPhone 或 iPad 上的帧率一般都是60，即刷新频率为60赫兹，每帧耗时16.67毫秒，但是在 iPad Pro 的刷新频率为120赫兹，即每帧耗时8.33毫秒。垂直同步信号决定了是否需要切换当前显示的帧，当某一即将要显示的视频帧在垂直同步信号来临的时候没有显示，就发生了卡顿，卡顿的严重程度取决于那一帧延迟了多久才展示，拿上图为例，第4帧延迟了16.67毫秒才展示到屏幕上。</p><blockquote><p>更多介绍推荐参看 <a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/#2" target="_blank">《iOS 保持界面流畅的技巧》</a>。</p></blockquote><h3>量化卡顿</h3><p>有两种方式可以量化卡顿：</p><ul><li>活动.卡顿时间：某一帧比预期展示的时间晚了多少毫秒</li><li>2.卡顿率：总的卡顿时间/总时间</li></ul><p>听起来可能比较复杂，这里为什么不是直接用掉帧或者掉帧率来表述呢？因为帧率太绝对，容易造成误解。如果测试过程除了动画外还有其他（闲置）阶段，那么 FPS 的意义就没有那么大，因为闲置期间我们本身就不希望画面会变换，同时一些情况下，我们也会设置一些低于最大 FPS 的帧率，比如一些游戏的帧率是每秒30帧，视频的帧率是每秒24帧。拿iOS系统的<strong>时钟应用</strong>为例，考虑到性能及电池损耗，icon 上的指针的帧率为10。</p><p>卡顿时间通常情况下是不可比较的，活动秒内总的卡顿时间和10秒内的总的卡顿时间是没有可比性的。</p><p>我们可以通过统一卡顿率（即测试阶段每秒的卡顿时间）来制定一些度量标准来对比不同测试的场景，然后得出大概的用户影响情况。</p><h3>标准推荐</h3><p>苹果推荐使用以下几个值来定义对用户体验的影响程度：</p><img class="lazyload" data-src="https://images.xiaozhuanlan.com/photo/2020/3df986eff6c07ea23f7268f91fbf1941.png"/><table><thead><tr><th>程度</th><th>标准值</th></tr></thead><tbody><tr><td>严重</td><td>每秒钟卡顿超过10毫秒，严重影响用户体验需要立即解决</td></tr><tr><td>警告</td><td>每秒钟卡顿在5～10毫秒之间，用户可能会察觉，需要开始介入排查</td></tr><tr><td>良好</td><td>每秒钟卡顿小于5毫秒，继续保持</td></tr></tbody></table><h3>度量及优化</h3><p>从 iOS14 开始，开发者可以在开发及线上阶段均可使用系统提供的 XCTest 框架来排查动画的卡顿。在单元测试和 UI 测试中可以使用 XCTest 来收集动画相关数据及卡顿信息，同时可以使用 MetricKit 收集线上用户卡顿数据，然后结合 Xcode Organizer 来做性能分析。</p><img class="lazyload" data-src="https://images.xiaozhuanlan.com/photo/2020/3f69a444c18b13635b461bad946df431.png"/><p>这个 Session 主要关注开发阶段如何使用 XCTest 性能测试来捕获卡顿，想要了解如何查看线上用户的卡顿信息可以翻看另外两个 Session。</p><img class="lazyload" data-src="https://images.xiaozhuanlan.com/photo/2020/b41ce88a28ad7bd01a82a5e514f364d1.png"/><blockquote><p><a href="https://developer.apple.com/videos/play/wwdc2020/10081/" target="_blank">WWDC20 10081-What's New in MetricKit</a> <a href="https://developer.apple.com/videos/play/wwdc2020/10076/" target="_blank">WWDC20 10076-Diagnose Performance Issues with the Xcode Origanizer</a></p></blockquote><p>在 Xcode 11 中苹果引入了 XCTMetrics 来帮助开发者衡量一些系统性能数据，比如耗时、CPU 使用率、内存占用、os_signpost 打点以及存储。</p><img class="lazyload" data-src="https://images.xiaozhuanlan.com/photo/2020/9858c7ddda13cd191accd530c30258aa.png"/><p>Xcode 12 引入了一项独立的启动耗时的衡量标准 <code>XCTApplicationLaunchMetric</code>，同时也新增了一些模板供开发者来制定自己的性能衡量标准。</p><details>
<summary>👉点击查看新增 API</summary>
```objc
@interface XCTOSSignpostMetric (XCTBuiltinOSSignposts)

/*!
 * @property navigationTransitionMetric
 * The XCTMetric object covering navigation transitions between views
 */
@property (readonly, class) id<XCTMetric> navigationTransitionMetric API_AVAILABLE(ios(14.0), tvos(14.0)) API_UNAVAILABLE(macos);

/*!
 * @property customNavigationTransitionMetric
 * The XCTMetric object covering custom navigation transitions between views
 */
@property (readonly, class) id<XCTMetric> customNavigationTransitionMetric API_AVAILABLE(ios(14.0), tvos(14.0)) API_UNAVAILABLE(macos);

/*!
 * @property scrollDecelerationMetric
 * The XCTMetric object covering scroll deceleration animations
 */
@property (readonly, class) id<XCTMetric> scrollDecelerationMetric API_AVAILABLE(ios(14.0), tvos(14.0)) API_UNAVAILABLE(macos);

/*!
 * @property scrollDraggingMetric
 * The XCTMetric object covering scroll dragging animations
 */
@property (readonly, class) id<XCTMetric> scrollDraggingMetric API_AVAILABLE(ios(14.0), tvos(14.0)) API_UNAVAILABLE(macos);

@end

/*!
 * @class XCTApplicationLaunchMetric
 * A metric which measures application launch durations.
*/
API_AVAILABLE(macos(10.15), ios(13.0), tvos(13.0))
__attribute__((objc_subclassing_restricted))
@interface XCTApplicationLaunchMetric : NSObject <XCTMetric>

/*!
 * @method -init
 * Initializes an application launch metric that measures the duration an application takes to display its first frame to screen.
 */
- (instancetype)init;

/*!
 * @method -initWithWaitUntilResponsive
 * Initializes an application launch metric that measures the duration an application takes to display its first frame to screen.
 *
 * @param waitUntilResponsive Specifies the end of the application launch interval to be when the application has displayed the first frame and is responsive.
*/
- (instancetype)initWithWaitUntilResponsive:(BOOL)waitUntilResponsive API_AVAILABLE(macos(10.16), ios(14.0), tvos(14.0));

@end

```
</details><p>这里我们主要关注 <code>XCTOSSignpostMetric</code>；从 Xcode 11 开始，开发者可以使用 <code>XCTOSSignpostMetric</code> 来计算 <code>os_signpost</code> 的时间间隔。在 Xcode 12 中，当使用 <code>os_signpost</code> 来计算动画时间间隔时，除了可以获取到时间间隔外，还能额外得到以下几个数值：卡顿次数、卡顿总时长、卡顿时间占比、帧率、帧数（其中前三项为 iOS 特有）。</p><img class="lazyload" data-src="https://images.xiaozhuanlan.com/photo/2020/80f2b8278d95b7b8dea60a3cef810091.png"/><img class="lazyload" data-src="https://images.xiaozhuanlan.com/photo/2020/2a0a88346f13b76919d8906b59c8d85e.png"/><p>想要获取这些数据，需要在代码中集成 <code>os_signpost</code> 埋点，有3种集成场景</p><ul><li>计算无动画时间间隔</li><li>使用 <code>.animationBegin</code> 的方式计算动画时间间隔</li><li>UIKit本身的计算方式</li></ul><blockquote><p>第一种只返回时间间隔，第二种除了时间间隔以外，还会返回上面提到的几个值。</p></blockquote><img class="lazyload" data-src="https://images.xiaozhuanlan.com/photo/2020/32b02aa2994f8b730dced0dfe177536a.png"/><p>在 Xcode 11 中，我们只能调用 <code>os_signpost</code> 里的 <code>.begin</code> 和 <code>.end</code> 来测量一些非动画的时间间隔。在 Xcode 12 中，可以指定计算动画时间间隔的方式，仅需将之前的 <code>.begin</code> 接口替换为 <code>.animationBegin</code>。</p><pre data-language="swift" class="hljs"><code>os_signpost(.animationBegin, log: logHandle, name: <span class="hljs-string">"performAnimationInterval"</span>)
os_signpost(.end, log: logHandle, name: <span class="hljs-string">"performAnimationInterval"</span>)
</code></pre><p>除了使用自定义的时间间隔，还可以使用系统预置的几个 <code>UIKit</code> 相关的 <code>metric</code> 来测量导航动画转场以及滑动的场景。</p><p>一起来看看如何使用这几个预置的 <code>metric</code> 的例子。</p><pre data-language="swift" class="hljs"><code><span class="hljs-comment">// Measure scrolling animation performance using a Performance XCTest</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testScrollingAnimationPerformance</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">throws</span> {
    app.launch()
    app.staticTexts[<span class="hljs-string">"Meal Planner"</span>].tap()
    <span class="hljs-keyword">let</span> foodCollection = app.collectionViews.firstMatch
    
    measure(metrics: [<span class="hljs-type">XCTOSSignpostMetric</span>.scrollDecelerationMetric]) {
        foodCollection.swipeUp(velocity: .fast)
    }
}
</code></pre><p>启动应用后，点击 <code>Meal Planner</code> 进入文章最开始的那个列表页，然后将向上快速滑动的代码块放到 <code>measure block</code> 里，同时指定 <code>metric</code> 为 <code>scrollDecelerationMetric</code>。</p><blockquote><p>Xcode 12起，<code>swipe</code> 可以指定滑动速度。</p></blockquote><p><code>measure block</code> 里面的代码默认情况下会执行5次来搜集性能数据，这就意味着会连续向上滑动列表5次，即每一次滑动展示的是不同内容，但这不是我们想要的，我们希望5次滑动所处的场景是一致的。可以通过对上面代码做如下两处改造</p><pre data-language="Swift" class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testScrollingAnimationPerformance</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">throws</span> { 
    app.launch()
    app.staticTexts[<span class="hljs-string">"Meal Planner"</span>].tap()
    <span class="hljs-keyword">let</span> foodCollection = app.collectionViews.firstMatch

    <span class="hljs-comment">// 活动</span>
    <span class="hljs-keyword">let</span> measureOptions = <span class="hljs-type">XCTMeasureOptions</span>()
    measureOptions.invocationOptions = [.manuallyStop]
        
    measure(metrics: [<span class="hljs-type">XCTOSSignpostMetric</span>.scrollDecelerationMetric],
            options: measureOptions) {
        foodCollection.swipeUp(velocity: .fast)
        <span class="hljs-comment">// 2</span>
        stopMeasuring()
        foodCollection.swipeDown(velocity: .fast)
    }
}
</code></pre><p>活动. 创建 <code>measureOptions</code>，指定为手动停止 2. 在 <code>measure block</code> 中调用 <code>stopMeasuring</code> 方法，然后往下快速滑动重置为初始状态。</p><p>测试用例准备就绪，为了消除外部影响，还需要做一些额外设置</p><ul><li>为性能测试建一个独立的 <code>scheme</code>，然后使用 <code>release</code> 模式，同时禁用掉调试器。 <img class="lazyload" data-src="https://images.xiaozhuanlan.com/photo/2020/df070ebb38e673579f6d5a62c2e01a09.png"/></li><li>禁用掉自动截屏及覆盖率 <img class="lazyload" data-src="https://images.xiaozhuanlan.com/photo/2020/80eac3de06887c790ec30370d887d4c3.png"/></li><li>禁用一些运行时检测功能 <img class="lazyload" data-src="https://images.xiaozhuanlan.com/photo/2020/724f6bf99816106bf12afe4c102ac046.png"/></li></ul><p>做完上述操作，即可运行测试用例，然后查看对应结果。在结果页面选中 <code>Hitch Time Ratio</code>，可以看到5次运行记录的结果，页面上也会计算出平均值（每秒卡顿1.2毫秒），我们可以设置这个值作为基准值，后续这个用例的结果都会和基准值对比，确保卡顿维持在合理范围，避免将严重卡顿发布到线上，影响用户体验。</p><img class="lazyload" data-src="https://images.xiaozhuanlan.com/photo/2020/209f4d90ff96ed3280e3313b4cd7dafc.png"/><p>最后，演讲者通过一个简单的 <code>Demo</code> 来演示如何使用 <code>XCTest</code> 来优化动画中的卡顿，具体示例是在 <code>cellForItem</code> 里方法里将图片重绘改成设置视图的 <code>contentMode</code>，以此减少主线程卡顿和 CPU 占用。</p><h2>最后</h2><p>通过以上的演示和新 API 讲解，相信大家对于卡顿的检测和优化有了一个大概的了解，接下来就是亲手实践了。Have Fun～</p>]]></content><tag>WWDC</tag></entry><entry><title>聊聊最近遇到的一个Crash</title><link href="/posts/An-Abnormal-Swift-Crash"/><url>/posts/An-Abnormal-Swift-Crash</url><content type="html"><![CDATA[<h2>卖个关子</h2><pre data-language="swift" class="hljs"><code><span class="hljs-comment">// 代码段1</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span>: <span class="hljs-title">NSObject</span> </span>{
    <span class="hljs-keyword">deinit</span> {
         <span class="hljs-built_in">print</span>(<span class="hljs-string">"deinit "</span> + <span class="hljs-type">String</span>(format: <span class="hljs-string">"%p"</span>, <span class="hljs-keyword">self</span>))
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">UIViewController</span> </span>{
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">super</span>.viewDidLoad()
        <span class="hljs-keyword">var</span> x: <span class="hljs-type">Manager?</span> = <span class="hljs-type">Manager</span>()
        x = <span class="hljs-literal">nil</span>
    }
}
</code></pre><pre data-language="objectivec" class="hljs"><code><span class="hljs-comment">// 代码段2</span>
<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Manager</span> : <span class="hljs-title">NSObject</span></span>

<span class="hljs-keyword">@end</span>

<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Manager</span></span>

- (<span class="hljs-keyword">void</span>)dealloc {
    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"dealloc: %@"</span>, [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@"%p"</span>, <span class="hljs-keyword">self</span>]);
}

<span class="hljs-keyword">@end</span>

<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()</span>

<span class="hljs-keyword">@end</span>

<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span>

- (<span class="hljs-keyword">void</span>)viewDidLoad {
    [<span class="hljs-keyword">super</span> viewDidLoad];
    Manager *manager = [Manager new];
}

<span class="hljs-keyword">@end</span>
</code></pre><p>以上两段代码运行起来后会分别会发生什么？编译报错？正常输出？输出异常？Crash？</p><p>相信看了标题，肯定会有人说会 Crash，具体是代码段1还是代码段2，还是都会 Crash 呢？且往下看～</p><h2>场景一</h2><h3>现象</h3><p>线上遇到这类 Crash，基本上都是系统堆栈，如下图</p><img class="lazyload" data-src="/media/2020-09-12/Untitled.png" alt="Untitled"/><h3>排查</h3><p>唯一的业务堆栈是 #5 那一行，而那一行对应的代码是 <code>xxx = nil</code>，并且这个类的 <code>dealloc</code> 方法就这一行代码。</p><ul><li>首先排除了多线程的问题，因为都是在主线程；</li><li>另外在崩溃日志的附加信息里有一个共有的规律就是都是收到内存警告后触发，但是尝试模拟内存警告，也无法。因为 cell 是在一个常驻页面上，只有内存警告才会触发 <code>dealloc</code>；</li><li>尝试符号断点在 <code>objc_release</code> 上，分析对应的汇编代码，也没啥收获；</li><li>崩溃附加信息里记录曾经收到过内存警告；</li><li>继续尝试在 <code>xxx</code> 对应类的 <code>dealloc</code> 方法，并前后加上 log，上线后抓取崩溃的附加信息发现 <code>xxx</code> 的 <code>dealloc</code> 前后的 log 都有执行；看来也不是 <code>xxx</code>的 <code>dealloc</code> 导致的。</li></ul><p>经过上面的排查还是没法定位到具体原因，后面某天其他组同事重现了这个问题，拿到本地日志后，发现 Crash 前最后的日志是 cell 持有的某个 <code>Swift</code> 对象 <code>deinit</code> 输出的 log。于是 Review 了对应类的代码，发现没啥问题。然后找对应同学构建这个类生效的场景，再模拟内存警告，然后就必现了，堆栈和上报的是一样的。然后通过开启 <code>Xcode</code> 僵尸对象，检测到确实是那个类出现了野指针。</p><img class="lazyload" data-src="/media/2020-09-12/Untitled%201.png" alt="Untitled 1"/><blockquote><p>上面说到的模拟内存警告，如果是模拟器可以通过 Debug→Simulate Memory Warning 来模拟内存警告，如图所示</p></blockquote><img class="lazyload" data-src="/media/2020-09-12/Untitled%202.png" alt="Untitled 2"/><blockquote><p>而如果是真机的话，需要使用一个私有方法，即 <code>[[UIApplication sharedApplication] _performMemoryWarning]</code> ，这个方法需要动态调用。</p></blockquote><p>再回到上面卖的那个关子，答案是只有代码段1会 Crash，代码段2正常输出。</p><p>代码段1运行起来之后，报了一个 objc_release 的 crash</p><img class="lazyload" data-src="/media/2020-09-12/Untitled%203.png" alt="Untitled 3"/><p>开启僵尸对象，输出如下 log</p><pre data-language="swift" class="hljs"><code>*** -[<span class="hljs-type">SwiftDemo</span>.<span class="hljs-type">Manager</span> release]: message sent to deallocated instance <span class="hljs-number">0x6000013c4500</span>
</code></pre><p>代码段2正常输出，没有Crash</p><img class="lazyload" data-src="/media/2020-09-12/Untitled%204.png" alt="Untitled 4"/><p>代码段1就是上面 <code>someInstance</code>类刨去业务代码后的最简化场景。Cell 复用时为了判断是哪一个 cell 的某个逻辑触发的，写了一个类似下面的 log 函数：</p><pre data-language="swift" class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-number">_</span> des: String)</span></span> {
		<span class="hljs-built_in">print</span>(<span class="hljs-string">"log: \(des), address=\(String(format: "</span>%p<span class="hljs-string">", self))"</span>)
}
</code></pre><p>然后 deinit 时某个业务会调用上面的 log 函数，然后在退出页面或者收到内存警告时触发了类似代码段1对应的 Crash。</p><p>通过堆栈以及结论来倒推，应该是 <code>someInstance dealloc</code>之后，runloop 将要进行休眠时触发了 <code>autoreleasepool pop</code> 操作，然后对 <code>pool</code> 内的对象发送 <code>release</code> 消息，但此时<code>someInstance</code> 已经释放，所以出现了野指针。那么问题来了，<code>someInstance</code> 什么时候被加入到自动释放池的呢？从代码层面上来看，猜测是构建 log 时，<code>String(format:)</code> 生成了自动释放的 <code>String</code> 对象，该对象加入到了自动释放池中。</p><p>真的是自动释放池导致的么？因为代码中没有显式创建自动释放池，那这里肯定是主线程默认的自动释放池。既然默认的 <code>autoreleasepool</code> 会在 runloop 休眠才将池子里的对象执行release操作，那是不是直接在 <code>deinit</code> 包一层 <code>autoreleasepool</code> 就可以让这个临时对象出了作用域就会立即释放呢？动手试试～</p><pre data-language="swift" class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span>: <span class="hljs-title">NSObject</span> </span>{
    <span class="hljs-keyword">deinit</span> {
				<span class="hljs-comment">// 显式创建一个自动释放池</span>
        autoreleasepool {
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"deinit "</span> + <span class="hljs-type">String</span>(format: <span class="hljs-string">"%p"</span>, <span class="hljs-keyword">self</span>))
        }
    }
}
</code></pre><p><strong>添加如上代码，发现log能正常输出，也不会崩溃了。</strong></p><p>但是为什么同样的代码在 <code>Swift</code> 就会崩溃，而使用 <code>Objective-C</code> 就不会有问题呢？带着这个疑问，和同事一起翻了下 <code>Swift</code> 关于 <code>String</code> <code>String(format:)</code>方法的相关源码。发现这个方法里会对参数有一个持有关系。</p><p>截取源码中的几个片段</p><pre data-language="swift" class="hljs"><code><span class="hljs-comment">// https://github.com/apple/swift/blob/cc78af105faeb85a2b3d915f1959c75a919ea3dc/stdlib/public/Darwin/Foundation/NSStringAPI.swift#L447-L459</span>
<span class="hljs-comment">// 片段1</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(format: __shared <span class="hljs-type">String</span>, locale: __shared <span class="hljs-type">Locale?</span>, arguments: __shared [<span class="hljs-type">CVarArg</span>]) {
#<span class="hljs-keyword">if</span> <span class="hljs-type">DEPLOYMENT_RUNTIME_SWIFT</span>
    <span class="hljs-keyword">self</span> = <span class="hljs-built_in">withVaList</span>(arguments) {
      <span class="hljs-type">String</span>._unconditionallyBridgeFromObjectiveC(
        <span class="hljs-type">NSString</span>(format: format, locale: locale?._bridgeToObjectiveC(), arguments: $<span class="hljs-number">0</span>)
      )
    }
#<span class="hljs-keyword">else</span>
    <span class="hljs-keyword">self</span> = <span class="hljs-built_in">withVaList</span>(arguments) {
      <span class="hljs-type">NSString</span>(format: format, locale: locale, arguments: $<span class="hljs-number">0</span>) <span class="hljs-keyword">as</span> <span class="hljs-type">String</span>
    }
#endif
}

<span class="hljs-comment">// https://github.com/apple/swift/blob/da61cc8cdf7aa2bfb3ab03200c52c4d371dc6751/stdlib/public/core/VarArgs.swift#L145-L152</span>
<span class="hljs-comment">// 片段2</span>
@inlinable <span class="hljs-comment">// c-abi</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">withVaList</span>&lt;R&gt;<span class="hljs-params">(<span class="hljs-number">_</span> args: [CVarArg],
  <span class="hljs-number">_</span> body: <span class="hljs-params">(CVaListPointer)</span></span></span> -&gt; <span class="hljs-type">R</span>) -&gt; <span class="hljs-type">R</span> {
  <span class="hljs-keyword">let</span> builder = __VaListBuilder()
  <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> args {
    builder.append(a)
  }
  <span class="hljs-keyword">return</span> _withVaList(builder, body)
}

<span class="hljs-comment">// https://github.com/apple/swift/blob/da61cc8cdf7aa2bfb3ab03200c52c4d371dc6751/stdlib/public/core/VarArgs.swift#L155-L163</span>
<span class="hljs-comment">// 片段3</span>
@inlinable <span class="hljs-comment">// c-abi</span>
<span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">_withVaList</span>&lt;R&gt;<span class="hljs-params">(
  <span class="hljs-number">_</span> builder: __VaListBuilder,
  <span class="hljs-number">_</span> body: <span class="hljs-params">(CVaListPointer)</span></span></span> -&gt; <span class="hljs-type">R</span>
) -&gt; <span class="hljs-type">R</span> {
  <span class="hljs-keyword">let</span> result = body(builder.va_list())
  _fixLifetime(builder)
  <span class="hljs-keyword">return</span> result
}

<span class="hljs-comment">// https://github.com/apple/swift/blob/6636815568efa8af5a62bbd68d585691d981a82b/stdlib/public/core/LifetimeManager.swift#L49-L52</span>
<span class="hljs-comment">// 片段4</span>
@_transparent
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">_fixLifetime</span>&lt;T&gt;<span class="hljs-params">(<span class="hljs-number">_</span> x: T)</span></span> {
  <span class="hljs-type">Builtin</span>.fixLifetime(x)
}
</code></pre><p>可以看到 Swift 中的 <code>String</code> 最终还是会调用 <code>NSString</code> 来生成字符串，那理论上应该和上面 Objective-C 代码片段一样，不会 Crash。但是仔细看会发现上面在调用 <code>NSString</code> 的相关方法前，会先创建一个 __VaListBuilder，这个类的源码可以查看<a href="https://github.com/apple/swift/blob/55e7050ffc35489398246671e4029efcdd527c55/stdlib/public/core/VarArgs.swift#L440-L712" target="_blank">这里</a>。内部会持有传进去的参数，应该是这里出了些问题，具体原因暂时还没有结论。但感觉这里应该是Swift的坑，当然也有可能是我的理解有问题。</p><h2>总结</h2><p>总之目前来看，Swift <code>deinit</code> 中在使用 <code>print</code> 时尽量还是少用 <code>%p, %@</code> ，然后参数传 <code>self</code> 这种形式，避免产生一些难以捉摸的 Crash。</p><blockquote><p>最后附上上述场景出现的环境：</p></blockquote><blockquote><p>Xcode 11.7 (11E801a)、MacOS 10.15.6、Swift 5.0</p></blockquote>]]></content><tag>Crash</tag></entry><entry><title>iOS 中资源的条件编译</title><link href="/posts/Xcode-Condition-Build"/><url>/posts/Xcode-Condition-Build</url><content type="html"><![CDATA[<p>日常开发中常常遇到某些类及其引用的资源文件仅在 <code>Debug</code> 或内测版本中生效，而不希望带到线上版本。因为一来会增加包体积，二来会把一些内部功能的相关接口暴露，导致可能的一些动态调试。那么有没有避免的方案呢？</p><h2>Pod</h2><p>答案肯定是有的，通常的做法是把对应功能抽成单独的 <code>pod</code> 库，然后仅 <code>Debug</code> 模式才集成到主工程，发出去的版本不集成。通常方式如下，以 <code>FLEX</code> 为例：</p><pre data-language="ruby" class="hljs"><code>pod <span class="hljs-string">'FLEX'</span>, <span class="hljs-string">'~&gt; 2.0'</span>, <span class="hljs-symbol">:configurations</span> =&gt; [<span class="hljs-string">'Debug'</span>]
</code></pre><p>但是如果某些强耦合主工程无法拆成独立 <code>pod</code> 的功能，这种方式可能就不再适用了。</p><h2>条件编译</h2><p><code>pod</code> 这条路走不通，有没有其他方式呢？答案也是肯定的，也是大家经常采用的方式，使用条件编译。也就是将对应类文件及引用到的地方使用类似下面的方式：</p><pre data-language="undefined" class="hljs"><code>
#if DEBUG
// 放入仅Debug模式下生效的代码
#endif
</code></pre><p>以上两种方式将大部分场景 <code>cover</code> 住了，但是假设对应的类文件还引用到了图片、<code>Storyboard</code>、<code>Xib</code> 等资源时，该如何让这些资源仅在 <code>Debug</code> 下才参与编译，而其他场景不参与编译呢？</p><h2>Xcode Build Options</h2><p>既然都写了这篇文章了，那答案也是肯定的，就是使用 <code>Xcode</code> 提供的一个编译选项 <code>Excluded Source File Names</code> 来将不需要的资源排除。</p><img class="lazyload" data-src="/media/2020-03-30/15855806858197.jpg"/><blockquote><p>确切来说这个编译选项是 <code>Xcode 9</code> 才引入的，之前版本需要自行定义，可以参考这个<a href="https://stackoverflow.com/a/41495430" target="_blank">回答</a>。 摘录一段来自<a href="https://xcodebuildsettings.com/#excluded_source_file_names" target="_blank">Xcode Build Settings</a>的解释 <img class="lazyload" data-src="/media/2020-03-30/15855826179239.jpg" alt="-w849"/></p></blockquote><p>假设有下面目录结构的工程</p><pre data-language="undefined" class="hljs"><code>
# 使用 tree 命令行得到下面结构
├── ConditionBuildDemo
│   ├── A
│   │   ├── Debug
│   │   │   ├── DebugA.swift
│   │   │   ├── icon_test@2x.png
│   │   │   ├── Sub
│   │   │   │   ├── DeepSub
│   │   │   │   │   └── DeepSubA.swift
│   │   │   │   ├── SubDebugA.swift
│   │   │   │   └── icon.png
│   │   │   └── SubA.xcassets
│   │   │       ├── Contents.json
│   │   │       └── logo.imageset
│   │   │           ├── Contents.json
│   │   │           └── logo@2x.png
│   │   └── ModelA.swift
│   ├── B
│   │   ├── Debug
│   │   │   └── DebugB.swift
│   │   └── ModelB.swift
</code></pre><pre data-language="Swift" class="hljs"><code><span class="hljs-comment">//测试代码</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">super</span>.viewDidLoad()
    <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = <span class="hljs-type">ModelA</span>()
    <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = <span class="hljs-type">ModelB</span>()
    <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = <span class="hljs-type">DebugA</span>()
    <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = <span class="hljs-type">DebugB</span>()
    <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = <span class="hljs-type">SubDebugA</span>()
    <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = <span class="hljs-type">DeepSubA</span>()
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = <span class="hljs-type">UIImage</span>.<span class="hljs-keyword">init</span>(named: <span class="hljs-string">"logo"</span>) {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"has logo"</span>)
    }
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = <span class="hljs-type">UIImage</span>.<span class="hljs-keyword">init</span>(named: <span class="hljs-string">"icon"</span>) {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"has icon"</span>)
    }
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = <span class="hljs-type">UIImage</span>.<span class="hljs-keyword">init</span>(named: <span class="hljs-string">"icon_test"</span>) {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"has icon_test"</span>)
    }
}
</code></pre><blockquote><p>这里为了方便验证，直接设置 <code>Debug Configuration</code> 下的 <code>Excluded Source File Names</code>。如图 <img class="lazyload" data-src="/media/2020-04-04/15859854120322.jpg" alt="-w984"/> 实际用到项目中可根据自己项目自行对不同 <code>Configuratio</code> 进行配置。</p></blockquote><p>下面我们来探索下这个路径的配置规则。</p><p>如果我们想要排除 <code>A</code> 和 <code>B</code> 目录下的 <code>Debug</code> 文件夹的所有内容，按照常规思路，理所当然直接写上 <code>Debug/*</code>，然后编译发现上面的测试代码编译报错，找不到类 <code>DebugA</code>,<code>DebugB</code>。</p><pre data-language="undefined" class="hljs"><code>
ViewController.swift:18:22: Use of unresolved identifier 'DebugA'
ViewController.swift:19:22: Use of unresolved identifier 'DebugB'
</code></pre><p>屏蔽掉这两处代码运行，发现 <code>has logo</code> 和 <code>has icon</code> 都输出了。</p><p>所以 <code>Debug/*</code> 只能屏蔽 <code>Debug</code> 根目录下的文件，子文件夹无法屏蔽（因为 <code>.xcasset</code> 实质上也是一个文件夹，所以无法被屏蔽）。</p><p>如果确实想要屏蔽 <code>Debug</code> 下所有内容，要怎么处理呢？目前我还没找到比较好的方式😂，只能一个个目录排除了。拿上面的的结构来说，如果要排除文件夹 <code>A</code> <code>B</code> 目录下的 <code>Debug</code>，可能就得这样配置 <code>Debug/*</code> <code>Debug/*/*</code> <code>Debug/*/*/*</code>，如图</p><img class="lazyload" data-src="/media/2020-04-04/15859945623293.jpg" alt="-w589"/><p>所以这里支持的匹配模式主要有以下两种：</p><ul><li>文件名完全匹配，比如 <code>ModelA.Swift</code></li><li>通配符，如 <code>Debug/*.Swift</code> <code>Debug/*.*</code> <code>*/Debug/*</code> <code>Debug/*/*/*.png</code></li></ul><h2>Development Assets</h2><img class="lazyload" data-src="/media/2020-04-04/15859936373369.jpg" alt="-w1219"/><blockquote><p>关于这个配置项可以查看 <a href="https://developer.apple.com/videos/play/wwdc2019/233/" target="_blank">WWDC 2019 Session 233 Mastering Xcode Previews</a></p></blockquote><p><code>Xcode 11</code> 新增了一个 <code>Development Assets</code> 的配置项，简单尝试了下，但是似乎没有生效。我把上面目录结构中的 <code>SubA.xcassets</code> 加到里面，然后用<code>release</code> 模式跑起来还是能读到对应的图片，不知道是不是姿势不对。</p><p>其实重点还是 <code>Excluded Source File Names</code> 这个编译配置，有时候会有事半功倍的效果。</p><p>update 2022-09-22</p><p>最近使用 Development Assets 无意间发现，这个目录下的资源在 archive 出来的包会被排除（但 release 模式不会），具体情况如下 <img class="lazyload" data-src="/media/Xcode-Condition-Build/2022-09-25/16640814305662.jpg"/></p><p>具体入口在选中 Target 之后，选中顶部 General 即可。 <img class="lazyload" data-src="/media/Xcode-Condition-Build/2022-09-25/16640814434504.jpg"/></p>]]></content><tag>Xcode</tag></entry><entry><title>iOS16 Live Activity 初体验</title><link href="/posts/iOS16-Live-Activity"/><url>/posts/iOS16-Live-Activity</url><content type="html"><![CDATA[<p>WWDC 2022 Keynote 中苹果给我们介绍了 iOS 16 中一个比较亮眼的更新：Live Activity（实时活动），开发者可以在锁屏页面上放置一个可以“实时”更新的 Widget，比如外卖或者打车应用，在开启实时活动之后我们可以在锁屏页上实时看到外卖小哥/司机与我们的距离及预计到达时间。但是这一 API 及对应功能并没有第一时间放出，而是随着 iOS 16 Beta4 一起放出：<a href="https://developer.apple.com/cn/news/?id=hi37aek8 "【实时活动现已推出 Beta 版本】"" target="_blank">【实时活动现已推出 Beta 版本】</a>。</p><img class="lazyload" data-src="/media/iOS16-Live-Activity/16592392576265.png"/><p>这篇文章主要是对官方 API 做一个简单提炼，并梳理下一些需要注意的点。</p><h2>写在前面</h2><ul><li>Live Activity 功能及正式 API 不会随 iOS 16 的首个正式版本释出，而是在今年晚些时候释出，具体时间没有给；</li><li>只有在 Live Activity 正式释出后，才可提交带对应功能的 App 版本到 App Store；</li><li>Live Activity 仅 iPhone 可用；</li><li>下面提及到的代码及示例都是 Beta 版的，可能随时会发生变化，建议在正式版释出后着重关注</li></ul><blockquote><p>Live Activity 后续均使用实时活动来翻译。</p></blockquote><h2>实际使用/开发体验</h2><blockquote><p>设备及开发环境：iPhone 12 iOS 16 Beta 4、Xcode 14 Beta 4、macOS 12.4</p></blockquote><ol><li>当前版本（iOS16 Beta 4）锁屏页面展示实时活动，不需要用户授权也不需要用户手动添加，开启实时活动后会自动展示在锁屏页上，但是用户可以在设置中手动关闭。猜测后续大概率需要用户授权，不然可能会被某些开发者利用；</li><li>同一个应用可以展示多个实时活动，但是会被折叠（类似通知），锁屏页面可以有多个 app 同时展示，会按 app 分组，可以看下截图；</li></ol><img class="lazyload" data-src="/media/iOS16-Live-Activity/16592392576325.png"/><ol start="3"><li>没有付费账号，还没尝试使用远程推送来更新/停止实时活动；</li><li>实时活动锁屏 UI 必须使用 SwiftUI，相对来说比较简单，实时活动组件的高度不能超过 220px（原文是 220 pixels，但实际测试发现是 220pt），否则系统会自动裁切；</li><li>基于 Widget，但刷新机制不一样，widget 是根据时间线来更新，而实时活动则不受这个控制，可以使用远程推送或者宿主应用代码来更新，暂时没看到更新频率相关限制；</li><li>因为是基于 Widget，所以还是可以给控件绑定不同 deep link，使其可以跳转到对应页面；</li><li>整体上来说实时活动的适配比较容易，重要的还是结合 App 的实际场景合理运用应该能取得不错效果，后续应该会有很多有创意的 idea 出现，可以期待一波。</li></ol><p>写了个 Demo，模拟地铁到站预估时间的场景，代码放在 <a href="https://github.com/wang9262/iOS16LiveActivityDemo "GitHub/iOS16LiveActivityDemo"" target="_blank">GitHub/iOS16LiveActivityDemo</a> 上了，有啥疑问可以留言或者提 issue。</p><hr><blockquote><p>以下内容主要对文档做个翻译.</p></blockquote><h2>实时活动的要求和约束</h2><ul><li>一个实时活动在应用或用户结束前能够存活<strong>8 个小时</strong>，如果 8 小时内没有结束，系统会自动结束该实时活动；</li><li>已结束的实时活动会在在锁屏页上保留<strong>4 个小时</strong>，之后系统会自动将其移除，当然期间用户也可以手动移除；</li><li>综上，一个实时活动在锁屏页上最长可以停留<strong>12 个小时</strong>；</li><li>实时活动有自己的沙盒，跟 Widget 不一样的一点是：它无法使用网络也不能接受地理位置更新；</li><li>我们可以在应用内使用 <code>ActivityKit</code> 来更新实时活动，也可以在实时活动的 Widget 中接收远程推送来更新，下面会具体说到；</li></ul><h2>让应用适配实时活动</h2><p>如果应用之前已经有 Widget，那么可以在已有的 Widget Extension 中添加实时活动的相关实现；如果之前没有的话可以新建一个。值得注意的是：实时活动并不是 widget，他们的更新机制有较大区别。上面也有提到，实时活动是通过应用内的 ActivityKit 或者远程推送来更新的，而 widget 则依赖系统的 timeline 机制。</p><p>下面是适配的相关步骤：</p><ol><li>创建一个 Widget Extension，如果已有，则可跳过这一步；</li></ol><img class="lazyload" data-src="/media/iOS16-Live-Activity/16592392576383.png"/><ol start="2"><li>在 <code>Info.plist</code> 文件中添加一个键值对，key 为 <code>NSSupportsLiveActivities</code>，value 为 <code>YES</code>;</li></ol><img class="lazyload" data-src="/media/iOS16-Live-Activity/16592392576429.png"/><ol><li>在代码里定义一组 <code>ActivityAttributes</code> 以及 <code>Activity.ContentState</code>,后续会用它们来开始、更新及结束实时活动；</li><li>创建 Widget 并返回一个 <code>ActivityConfiguration</code>；</li><li>添加开始、更新、结束实时活动的相关代码，并设计对应的 UI 样式；</li><li>运行查看效果。</li></ol><pre data-language="Swift" class="hljs"><code><span class="hljs-keyword">import</span> ActivityKit
<span class="hljs-keyword">import</span> SwiftUI
<span class="hljs-keyword">import</span> WidgetKit

<span class="hljs-comment">// 示例代码，展示披萨配送的实时活动</span>

<span class="hljs-comment">// 继承 ActivityAttributes ，定义自定义属性用于widget UI展示</span>
<span class="hljs-comment">// Attributes 用来定义不可变的静态数据，比如这里的披萨数量和花费</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PizzaDeliveryAttributes</span>: <span class="hljs-title">ActivityAttributes</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">typealias</span> <span class="hljs-type">PizzaDeliveryStatus</span> = <span class="hljs-type">ContentState</span>

    <span class="hljs-comment">// ContentState用来封装动态（会发生变化的）数据，比如这里的配送员名字、预计送达时间</span>
    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentState</span>: <span class="hljs-title">Codable</span>, <span class="hljs-title">Hashable</span> </span>{
        <span class="hljs-keyword">var</span> driverName: <span class="hljs-type">String</span>
        <span class="hljs-keyword">var</span> estimatedDeliveryTime: <span class="hljs-type">Date</span>
    }
    <span class="hljs-keyword">var</span> numberOfPizzas: <span class="hljs-type">Int</span>
    <span class="hljs-keyword">var</span> totalAmount: <span class="hljs-type">String</span>
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PizzaDeliveryActivityWidget</span>: <span class="hljs-title">Widget</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">WidgetConfiguration</span> {
        <span class="hljs-type">ActivityConfiguration</span>(attributesType: <span class="hljs-type">PizzaDeliveryAttributes</span>.<span class="hljs-keyword">self</span>) { context <span class="hljs-keyword">in</span>
            <span class="hljs-comment">// 根据数据创建锁屏widget UI，系统默认情况下文字颜色使用白色，然后使用最适合锁屏页的背景色；也可以像下面这样使用 activityBackgroundTint(_:) 来设置自定义颜色</span>
            <span class="hljs-type">VStack</span> {
                <span class="hljs-type">Text</span>(<span class="hljs-string">"\(context.attributes.numberOfPizzas) ordered for \(context.attributes.totalAmount)."</span>)
                <span class="hljs-type">HStack</span> {
                    <span class="hljs-type">Text</span>(<span class="hljs-string">"\(context.state.driverName) is on their way with your pizza!"</span>)
                    <span class="hljs-type">Text</span>(context.state.estimatedDeliveryTime, style: .timer)
                }
            }.activityBackgroundTint(<span class="hljs-type">Color</span>.cyan)

            <span class="hljs-comment">// 或者像这样使用ZStack的方式在最底下放置背景视图</span>
            <span class="hljs-type">ZStack</span> {
                <span class="hljs-type">Color</span>.cyan
                <span class="hljs-type">VStack</span> {
                    <span class="hljs-type">Text</span>(<span class="hljs-string">"\(context.attributes.numberOfPizzas) ordered for \(context.attributes.totalAmount)."</span>)
                    <span class="hljs-type">HStack</span> {
                        <span class="hljs-type">Text</span>(<span class="hljs-string">"\(context.state.driverName) is on their way with your pizza!"</span>)
                        <span class="hljs-type">Text</span>(context.state.estimatedDeliveryTime, style: .timer)
                    }
                }
            }.activitySystemActionForegroundColor(<span class="hljs-type">Color</span>.cyan)
        }
    }
}
</code></pre><p><strong>值得注意的是实时活动 Widget 的最大高度不能超过 220px（原文是 220 pixels，但实际测试发现是 220pt），否则系统会自动裁剪</strong>。</p><h2>检查实时活动是否可用</h2><p>由于实时活动仅在 iPhone 上生效，同时用户也可以在设置中手动关闭某个应用的实时活动，所以在使用前最好要做一个检测。</p><ul><li>使用 <code>areActivitiesEnabled</code> 来同步判断开始实时活动前是否显示锁屏 UI；</li><li>使用异步接口 <code>activityEnablementUpdates</code> 来检测用户授权状态的变更。</li></ul><blockquote><p>需要注意的是：每个应用可以开启若干个实时活动，同时系统也能展示多个 app 的实时活动；所以我们在启动、更新、结束实时活动时，也要考虑出错的情况以提供更好的用户体验。</p></blockquote><h2>启动实时活动</h2><p>应用在前台的时候，我们可以使用 <code>request(attributes:contentState:pushType:)</code> 方法来启动实时活动，对应参数 attributes 作为实时活动的初始值，<code>contentState</code> 作为动态变化的数据。如果应用实现了远程推送，也可以提供 <code>pushType</code> 参数，后面远程推送部分会讲到。</p><pre data-language="Swift" class="hljs"><code><span class="hljs-comment">// 启动实时活动示例代码</span>

<span class="hljs-comment">// 提供初始化值</span>
<span class="hljs-keyword">let</span> pizzaDeliveryAttributes = <span class="hljs-type">PizzaDeliveryAttributes</span>(numberOfPizzas: <span class="hljs-number">42</span>, totalAmount:<span class="hljs-string">"$420,-"</span>)

<span class="hljs-comment">// 提供动态变化数据，预估配送到达时间为1小时后</span>
<span class="hljs-keyword">let</span> initialContentState = <span class="hljs-type">PizzaDeliveryAttributes</span>.<span class="hljs-type">PizzaDeliveryStatus</span>(driverName: <span class="hljs-string">"Bill James"</span>, estimatedDeliveryTime: <span class="hljs-type">Date</span>().addingTimeInterval(<span class="hljs-number">60</span> * <span class="hljs-number">60</span>))

<span class="hljs-comment">// 启动实时活动，这里 pushType 暂时置 nil</span>
<span class="hljs-keyword">do</span> {
    <span class="hljs-keyword">let</span> deliveryActivity = <span class="hljs-keyword">try</span> <span class="hljs-type">Activity</span>&lt;<span class="hljs-type">PizzaDeliveryAttributes</span>&gt;.request( attributes: pizzaDeliveryAttributes, contentState: initialContentState, pushType: <span class="hljs-literal">nil</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Requested a pizza delivery Live Activity \(deliveryActivity.id)"</span>)
} <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">let</span> error) {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Error requesting pizza delivery Live Activity \(error.localizedDescription)"</span>)
}
</code></pre><h2>更新实时活动</h2><p>启动实时活动后我们可以得到一个 <code>Activity</code> 实例，接着我们可以调用该实例 <code>update(using:)</code> 方法来更新实时活动。我们也可以通过 <code>Activity。activities</code> 方法来获取当前所有的实时活动实例。</p><blockquote><p>更新一个已结束的实时活动会被忽略。</p></blockquote><pre data-language="Swift" class="hljs"><code><span class="hljs-keyword">let</span> updatedDeliveryStatus = <span class="hljs-type">PizzaDeliveryStatus</span>(driverName: <span class="hljs-string">"Anne Johnson"</span>, estimatedDeliveryTime: <span class="hljs-type">Date</span>().addingTimeInterval(<span class="hljs-number">60</span> * <span class="hljs-number">60</span>))
<span class="hljs-keyword">do</span> {
    <span class="hljs-comment">// deliveryActivity是上面启动时拿到的Activity实例</span>
    <span class="hljs-comment">// 更新的数据大小不能超过4KB</span>
    <span class="hljs-keyword">try</span> await deliveryActivity.update(using: updatedDeliveryStatus)
} <span class="hljs-keyword">catch</span>(<span class="hljs-keyword">let</span> error) {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Error updating activity \(error.localizedDescription)"</span>)
}
</code></pre><h3>内容更新动画</h3><p>系统会忽略实时活动 widget 的所有动画修饰符，比如<code>withAnimation(_:_:)</code>、<code>animation(_:value:)</code>。系统会自动给动态变化的内容添加动画，比如会给 Text 添加模糊的过渡效果，给 Image 以及 SF Symbol 添加过渡动画。如果更新过程中有视图的添加或移除，系统也会给他们加上淡入淡出的过渡动画。</p><p>我们也可以使用系统内置的过渡动画：<code>opacity</code>、<code>move(edge:)</code>、<code>slide</code>、<code>push(from:)</code> 或者将它们组合使用，对于那种计时的 Text，我们也可以使用 <code>numericText(countsDown:)</code> 修饰符来做文本变化动画。</p><h2>结束实时活动</h2><p>在关联的事件/任务结束时，我们也应该结束对应的实时活动。上面也有提到结束后的实时活动在用户手动移除前还会在锁屏页上停留 4 小时。当然我们也可以使用 <code>end(using:dismissalPolicy:)</code> 方法指定实时活动结束后的移除策略。</p><pre data-language="Swift" class="hljs"><code><span class="hljs-keyword">let</span> updatedDeliveryStatus = <span class="hljs-type">PizzaDeliveryStatus</span>(driverName: <span class="hljs-string">"Anne Johnson"</span>, estimatedDeliveryTime: <span class="hljs-type">Date</span>())
<span class="hljs-keyword">do</span> {
    <span class="hljs-comment">// 指定移除策略为默认，即用户手动移除前停留4小时</span>
    <span class="hljs-comment">// 还有 im/mediate 即立即移除，以及可以指定一个移除的时间 after(Date)</span>
    <span class="hljs-keyword">try</span> await deliveryActivity.end(using: updatedDeliveryStatus, dismissalPolicy: .<span class="hljs-keyword">default</span>)
} <span class="hljs-keyword">catch</span>(<span class="hljs-keyword">let</span> error) {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Error ending activity \(error.localizedDescription)"</span>)
}
</code></pre><p>需要注意的是，用户可以在任意时间将实时活动从锁屏页面移除，该操作相应的也会结束对应的实时活动，但是他不会取消用户在启动实时活动时的一些行为。比如上面披萨配送示例里，尽管用户可以移除披萨配送信息的实时活动，但不代表取消了对应的披萨订单。</p><h2>使用远程推送更新/结束实时活动</h2><p>除了上述的更新和结束的方式，我们还可以通过推送通知来实现，具体实现流程和逻辑其实普通的推送通知区别不大，这里不做赘述。有一点不同的是：实时活动不需要使用 <code>registerForRemoteNotifications()</code> 来注册推送通知，我们使用 ActivityKit 来获取推送 token。具体流程如下：</p><ol><li>启动实时活动时需要指定 pushType 参数为 <code>.token</code>，或者不传该参数（参数默认值就为 <code>.token</code>）；</li><li>成功启动后，将拿到的 <code>pushToken</code> 发送给服务端，后续使用该 <code>token</code> 来给对应实时活动发送推送通知；</li><li>服务端使用对应 token 发送推送时需要必须要指定 <code>content-state</code> 字段的值和代码里的 <code>Activity.ContentState</code> 匹配上，这样系统才能解码对应 JSON 内容来更新实时活动；</li><li>使用推送内容来更新或结束对应的实时活动；</li><li>使用 <code>pushTokenUpdates</code> 监听实时活动实例的 pushToken 变化，并将新值发送给服务端同时废弃旧值，</li><li>当实时活动结束后，通知服务端废弃对应 token。</li></ol><p>模拟器上测试实时活动的远程推送需要使用 T2 或 M 系列芯片的 Mac，并且要求系统 &gt;=macOS 13。</p><p>如果你不清楚自己电脑是否是 T2，可以通过如图方式确认，按住 Option 键，并点击左上角  查看 系统信息-&gt;控制器即可 <img class="lazyload" data-src="/media/iOS16-Live-Activity/16592392576470.png"/></p><p>也可以使用直接在下方列表查找，基本上 18 年后的都支持。</p><p>下面是一个对应上方披萨配送示例的 push payload 数据</p><pre data-language="JSON" class="hljs"><code>{
    <span class="hljs-attr">"aps"</span>: {
        <span class="hljs-attr">"timestamp"</span>: <span class="hljs-number">1650998941</span>,
        <span class="hljs-attr">"event"</span>: <span class="hljs-string">"update"</span>,
        <span class="hljs-comment">// 这里和上述 PizzaDeliveryAttributes.ContentState 里的字段一一对应</span>
        <span class="hljs-attr">"content-state"</span>: {
            <span class="hljs-attr">"driverName"</span>: <span class="hljs-string">"Anne Johnson"</span>,
            <span class="hljs-attr">"estimatedDeliveryTime"</span>: <span class="hljs-number">1659416400</span>
        }
    }
}
</code></pre><h3>跟新追踪</h3><p>Activity 这个类除了拥有一个 id 的唯一标识外，还提供了一系列的状态变化的监听，比如内容状态、活动状态以及 push token 的变更。我们可以使用对应的监听来更新应用，让实时活动与应用保持同步。</p><ul><li>使用 <code>activityStateUpdates</code> 来监听实时活动的状态，判断是否已结束；</li><li>使用 <code>contentState</code> 来监听实时活动的动态内容变化；</li><li>使用 <code>pushTokenUpdates</code> 来监听实时活动的 push token 变化。</li></ul><h2>查看实时活动列表</h2><p>一个应用可以同时开启多个实时活动，比如用户可以同时关注多个球赛直播，我们可以使用 <code>activityUpdates</code> 来获取当前正在进行中的实时活动。 在某些场景下我们可能也会用到这个方法来获取当前进行中的实时活动，比如应用闪退后再次打开应用，如果想要结束或更新某些实时活动，就可以通过这个方法来获取到所有的实时活动。</p><pre data-language="Swift" class="hljs"><code><span class="hljs-comment">// Fetch all ongoing pizza delivery activities.</span>
<span class="hljs-keyword">let</span> activityStream = <span class="hljs-type">Activity</span>&lt;<span class="hljs-type">PizzaDeliveryAttributes</span>&gt;.activityUpdates() <span class="hljs-keyword">for</span> await activity <span class="hljs-keyword">in</span> activityStream { <span class="hljs-built_in">print</span>(<span class="hljs-string">"Pizza delivery details: \(activity.description)"</span>) }
</code></pre>]]></content><tag>WWDC</tag></entry></search>