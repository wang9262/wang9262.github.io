<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vong</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://vongloo.me/"/>
  <updated>2019-03-03T15:42:37.279Z</updated>
  <id>https://vongloo.me/</id>
  
  <author>
    <name>Vong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WWDC 2018：使用日志框架测量性能</title>
    <link href="https://vongloo.me/2019/02/22/WWDC-2018-Signpost/"/>
    <id>https://vongloo.me/2019/02/22/WWDC-2018-Signpost/</id>
    <published>2019-02-22T14:17:46.000Z</published>
    <updated>2019-03-03T15:42:37.279Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文是 WWDC 2018 Session 405 的观后感，原视频和 pdf 可以在<a href="https://developer.apple.com/videos/play/wwdc2018/405/" target="_blank" rel="external">这里</a>看到。<br>首发于<a href="https://xiaozhuanlan.com/topic/3789465012" target="_blank" rel="external">小专栏</a>。</p>
</blockquote>
<p>众所周知，应用交互的流畅度决定了用户对这款用户的喜爱度，所以对于每个 iOS 工程师而言，应用的流畅程度是非常重要的。而这里所说的流畅度在工程师层面来理解就是应用的性能是否处于一个比较优的状态。那我们在发现页面卡顿时，如何去检测卡顿是哪一段代码引起的呢？目前业界的卡顿检测已经非常多了，比如 Instrument 的 Time Profile，各种基于 <code>runloop</code> 的卡顿率检测开源库。但是今天主要来说一说 iOS12 苹果为我们带来的一个新的检测方案，也就是基于 <code>OSLog</code> 的一套新 API。</p>
<a id="more"></a>
<p>好了，题外话讲完，我们正式进入正题。该 Seesion 主要有下面几部分组成：</p>
<ul>
<li>集成 signposts<ul>
<li>异步并行操作</li>
<li>添加原数据</li>
<li>控制 signposts 的启用和禁用</li>
</ul>
</li>
<li>使用 Instruments 分析</li>
</ul>
<p>首先先简单回顾一下 <code>OSLog</code>，苹果在2016年推出这个现代化的日志记录框架，用来获取系统调试信息，这个框架主要是为效率而生。可以看一个简单实例</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> logHandle = <span class="type">OSLog</span>(subsystem: <span class="string">"com.example.widget"</span>, category: <span class="string">"Setup"</span>)</div><div class="line">os_log(.info, log: logHandle, <span class="string">"Hello, %&#123;public&#125;s!"</span>, world)</div></pre></td></tr></table></figure>
<blockquote>
<p>PS: 更多内容可以参看 <a href="https://developer.apple.com/videos/play/wwdc2016/721/" target="_blank" rel="external">WWDC 2016 Session 721 Unified Logging and Activity Tracing</a></p>
</blockquote>
<p>这里要介绍的 <code>Signpost</code> 对 <code>OSLog</code> 进行了一些扩展，新增了一些用于衡量性能的 API。首先我们来看看如何在代码中集成 <code>Signpost</code>。</p>
<h3 id="集成-Signpost"><a href="#集成-Signpost" class="headerlink" title="集成 Signpost"></a>集成 Signpost</h3><h4 id="使用-signpost-计算耗时"><a href="#使用-signpost-计算耗时" class="headerlink" title="使用 signpost 计算耗时"></a>使用 signpost 计算耗时</h4><p>想象一下我们有这样一个应用，包含了一组图片的 feed 流，滑动过程中，我们会去加载 feed 流的封面，页面如下图所示。<br><img src="http://img.cdn.punmy.cn/15358675135125.jpg!wm" alt="-w200"><br>我们想要获取每张封面的加载耗时，如果使用 <code>Signpost</code> 相关 API 我们需要如何做呢？<br>使用 <code>Signpost</code> 我们可以标记每个任务的开始和结束，然后将他们关联起来，调用的相关 API 也比较简单，我们只需要做一个简单的打点，通过两个关联的打点，我们就可以记录这个任务的具体耗时，如下图所示。<br><img src="http://img.cdn.punmy.cn/15358678750813.jpg!wm" alt=""></p>
<p>伪代码如下</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 引入 os 框架</span></div><div class="line"><span class="keyword">import</span> os.signpost</div><div class="line"></div><div class="line"><span class="comment">// 使用自定义标识和分类创建一个 log，subsystem 建议使用 bundle id，category 主要用于对相关联的操作进行分类</span></div><div class="line"><span class="keyword">let</span> refreshLog = <span class="type">OSLog</span>(subsystem: <span class="string">"com.example.your-app"</span>, category: <span class="string">"RefreshOperations"</span>)</div><div class="line"><span class="keyword">for</span> element <span class="keyword">in</span> panel.elements &#123;</div><div class="line">    <span class="comment">// 任务开始前打点</span></div><div class="line">    os_signpost(.begin, log: refreshLog, name: <span class="string">"Fetch Asset"</span>)</div><div class="line">    fetchAsset(<span class="keyword">for</span>: element)</div><div class="line">    <span class="comment">// 任务结束打点，注意  log 和 name 要和开始前的匹配，这样才会自动关联</span></div><div class="line">    os_signpost(.end, log: refreshLog, name: <span class="string">"Fetch Asset"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果想要统计所有任务的耗时，也非常简单，只需要在 for 循环前后埋点即可，不过需要注意的一点是 name 的值，如上所述因为想要计算的所有任务的耗时，所以新起了一个值，来进行关联。代码如下</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> refreshLog = <span class="type">OSLog</span>(subsystem: <span class="string">"com.example.your-app"</span>, category: <span class="string">"RefreshOperations"</span>)</div><div class="line">os_signpost(.begin, log: refreshLog, name: <span class="string">"Refresh Panel"</span>)</div><div class="line"><span class="keyword">for</span> element <span class="keyword">in</span> panel.elements &#123;</div><div class="line">    os_signpost(.begin, log: refreshLog, name: <span class="string">"Fetch Asset"</span>)</div><div class="line">    fetchAsset(<span class="keyword">for</span>: element)</div><div class="line">    os_signpost(.end, log: refreshLog, name: <span class="string">"Fetch Asset"</span>)</div><div class="line">&#125;</div><div class="line">os_signpost(.end, log: refreshLog, name: <span class="string">"Refresh Panel"</span>)</div></pre></td></tr></table></figure>
<p>整个时间轴看起来如下图所示<br><img src="http://img.cdn.punmy.cn/15358689521743.jpg!wm" alt=""></p>
<h4 id="异步任务耗时的计算"><a href="#异步任务耗时的计算" class="headerlink" title="异步任务耗时的计算"></a>异步任务耗时的计算</h4><p>如果我们的任务是一步步循序渐进的，上面的方式是没问题的，但是实际应用场景中，大部分任务是异步同时进行的。因此上面的 name 唯一标识在异步并行的场景下，不再能满足我们的需求，因为各任务的起始时间是一样的，但是结束时间肯定不一样，如果都用相同的 name 来做唯一标识，时间轴肯定会存在重叠的情况，因此无法区分各个任务的耗时时间。<br><img src="http://img.cdn.punmy.cn/15358714494675.jpg!wm" alt=""></p>
<p>因此为了解决上述问题，我们可以使用另一个 <code>Signpost</code> 的 API，叫做 <code>signpost ID</code>。通过 <code>signpost ID</code>，可以区分同种类型操作中的不同任务。所以即使两个任务时间轴有重叠，但是由于 <code>signpost ID</code> 的存在，系统就可以区分出这是两个不同的时间间隔，所以只要 <code>.begin</code> 和 <code>.end</code> 打点时传入的 ID 一致，系统就会把二者自动关联起来，计算耗时。代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> refreshLog = <span class="type">OSLog</span>(subsystem: <span class="string">"com.example.your-app"</span>, category: <span class="string">"RefreshOperations"</span>)</div><div class="line"><span class="keyword">let</span> spidForRefresh = <span class="type">OSSignpostID</span>(log: refreshLog)</div><div class="line">os_signpost(.begin, log: refreshLog, name: <span class="string">"Refresh Panel"</span>, signpostID: spidForRefresh)</div><div class="line"><span class="keyword">for</span> element <span class="keyword">in</span> panel.elements &#123;</div><div class="line">    <span class="keyword">let</span> spid = <span class="type">OSSignpostID</span>(log: refreshLog, object: element)</div><div class="line">    os_signpost(.begin, log: refreshLog, name: <span class="string">"Fetch Asset"</span>, signpostID: spid)</div><div class="line">    fetchAssetAsync(<span class="keyword">for</span>: element) &#123;</div><div class="line">        os_signpost(.end, log: refreshLog, name: <span class="string">"Fetch Asset"</span>, signpostID: spid)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">notifyWhenDone &#123;</div><div class="line">    os_signpost(.end, log: refreshLog, name: <span class="string">"Refresh Panel"</span>, signpostID: spidForRefresh)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>signpost ID 可以通过 OSSignpostID 构建函数传入一个 log handler，以及任意一个对象（可选）。后面的 <code>object</code> 参数非常有用，因为只要传入的 object 是一样的，那么生成的 ID 也是一样的（当然前提是 log handler 也要一致）。</p>
<p>从上面示例我们可以得知，只要 <code>.begin</code> 和 <code>.end</code> 的其它参数是一致的，系统就会自动将其匹配，这样就可以在任何地方去进行“打点”。</p>
<p>所以整个 API 总结一下，大概是下面这样一个层级。<br><img src="http://img.cdn.punmy.cn/15358748792069.jpg!wm" alt=""></p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">示例</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Log category</td>
<td style="text-align:center">“RefreshOperations”</td>
<td style="text-align:center">相关操作</td>
</tr>
<tr>
<td style="text-align:center">Signpost name</td>
<td style="text-align:center">“Fetch Asset”</td>
<td style="text-align:center">想要计算的某类操作</td>
</tr>
<tr>
<td style="text-align:center">Signpost ID</td>
<td style="text-align:center">spid</td>
<td style="text-align:center">同一类操作下的某个任务</td>
</tr>
</tbody>
</table>
<h4 id="添加自定义-Metadata"><a href="#添加自定义-Metadata" class="headerlink" title="添加自定义 Metadata"></a>添加自定义 Metadata</h4><p>看完上面部分，你可能会有个疑问：是否可以在 signpost 中携带一些额外信息呢？答案是肯定的。<code>os_signpost</code> 函数为我们提供了一些可选参数，用于传递上下文。传入的参数得是 os_log 格式的字符串，可以传入不同类型的参数以及动态字符串，最终这些字符串都会显示在 Instrument 中。<br><img src="http://img.cdn.punmy.cn/15358795943113.jpg!wm" alt=""></p>
<h4 id="添加独立事件"><a href="#添加独立事件" class="headerlink" title="添加独立事件"></a>添加独立事件</h4><p>除了上面提到的自定义元数据，我们可能还想在 <code>.begin</code> 和 <code>.end</code> 之间记录一些特定的“点”，因此苹果给了我们一种新的类型，OSSignpostType.event。我们可以使用它来记录一些过程中的特定点，比如上面提到的图片加载的某个特定进度，或者记录加载过程中的用户点击行为等等。</p>
<p><img src="http://img.cdn.punmy.cn/15358802713581.jpg!wm" alt=""></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">os_signpost(.event, log: log, name: <span class="string">"Fetch Asset"</span>, <span class="string">"Fetched first chunk, size %u"</span>, size)</div><div class="line">os_signpost(.event, log: log, name: <span class="string">"Swipe"</span>, <span class="string">"For action 0x%x"</span>, actionCode)</div></pre></td></tr></table></figure>
<h4 id="Signpost-禁用及启用"><a href="#Signpost-禁用及启用" class="headerlink" title="Signpost 禁用及启用"></a>Signpost 禁用及启用</h4><p>默认情况下，<code>Signpost</code> 是启用的，但是某些情况下，我们并不想开启它，比如 <code>Release</code> 模式下包或者提交到 <code>Appstore</code> 的包。<br>苹果工程师一再强调 <code>Signpost</code> 本身非常轻量，同时在它被触发的时候也做了很多优化，同时在编译器层面也做了一些优化来确保它作用于运行时之前，把很多工作推迟到 Instrument 的处理时期，所以当它被触发时几乎不会消耗系统资源。<br>所以为了可以根据条件来启/禁用 Signpost，系统提供了一个默认的 <code>OSLog.disabled</code> 的 <code>log handler</code>，使用此 <code>log handler</code> 创建的 <code>Signpost</code>，都会被禁用，所以只需几行代码就可以搞定是否需要开启 <code>Signpost</code> 的需求，亦即只需要根据条件修改 <code>log handler</code> 初始化方式即可。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> refreshLog: <span class="type">OSLog</span></div><div class="line"><span class="keyword">if</span> <span class="type">ProcessInfo</span>.processInfo.environment.keys.<span class="built_in">contains</span>(<span class="string">"SIGNPOSTS_FOR_REFRESH"</span>) &#123;</div><div class="line">    refreshLog = <span class="type">OSLog</span>(subsystem: <span class="string">"com.example.your-app"</span>, category: <span class="string">"RefreshOperations"</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    refreshLog = .disabled</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，如果有一些 <code>Signpost</code> 代码如果比较耗时，我们也可以通过判断当前 <code>log handler</code> 是否被禁用来进行下一步操作。示例代码如下</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果获取 info 比较耗时，那可以先进行一次判断</span></div><div class="line"><span class="keyword">if</span> refreshLog.signpostsEnabled &#123;</div><div class="line">    <span class="keyword">let</span> information = copyDescription() </div><div class="line">    os_signpost(..., information)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上示例代码都是用的 <code>Swift</code>，但是在 C 代码中，它们也是可以用的。对应关系如下图，如果需要了解更多，可以进到对应的头文件，查看其使用方式和相关说明。<br><img src="http://img.cdn.punmy.cn/15358883833924.jpg!wm" alt=""></p>
<h3 id="与-Instruments-配合使用"><a href="#与-Instruments-配合使用" class="headerlink" title="与 Instruments 配合使用"></a>与 Instruments 配合使用</h3><p>这一章节，苹果工程师以一个本地徒步旅行的应用（参照上面截图）作为示例，展示了如何使用 <code>Signpost</code> 进行埋点，然后通过 Instrument 获取埋点数据，进而来进行对埋点的耗时分析计算。</p>
<h4 id="查看-Signpost-数据"><a href="#查看-Signpost-数据" class="headerlink" title="查看 Signpost 数据"></a>查看 Signpost 数据</h4><p>我们可以 Instruments(10) 来记录、查看和分析我们在上面说的所有的埋点。下面是 Demo 的一些相关背景：</p>
<blockquote>
<p>通常情况下，我们为了性能优化，会把一些耗时任务放到异步线程，等任务完成后再回到主线程，这样就很难对其进行时间的测量分析。当用户滑动的时候，就会同时触发多个图片下载任务。如果用户滑动非常迅速，那么很多图片在 cell 被重用时可能还没有下载完成，所以我们就需要取消这些下载任务，如果我们没有取消的话，就会平白多出几个我们并不想要的下载任务。</p>
</blockquote>
<p>cell 有一个 startImageDownload 方法用来下载图片，代码如下<br><img src="http://img.cdn.punmy.cn/15358904937593.jpg!wm" alt=""><br>每个下载任务开始时，会根据图片名称创建 <code>downloader</code>，然后根据 <code>downloader</code> 创建一个 <code>SignpostID</code> 用来作为这个下载任务的 <code>Signpost</code> 数据唯一标识，然后通过将图片名称传入到元数据中。</p>
<p>然后图片下载完成的回调如下<br><img src="http://img.cdn.punmy.cn/15358908311971.jpg!wm" alt=""><br>同样直接通过 <code>downloader</code> 创建一个 <code>SignpostID</code>，这样可以确保 <code>.begin</code> 和 <code>.end</code> 能够匹配。注意到这里传入的 metadata <code>&quot;Finished with size %{xcode:size-in-bytes}llu&quot;</code>，这里的 <code>xcode:size-in-bytes</code> 告诉 Xcode 和 Instrument 这个参数在分析和展示时要当做 <code>bytes</code> 来处理。它们被称为工程类型（engineering types），可以在<a href="https://help.apple.com/instruments/developer/mac/current/" target="_blank" rel="external">Instruments Developer Help</a>查看更多相关信息。<br><img src="http://img.cdn.punmy.cn/15358914508594.jpg!wm" alt=""></p>
<p>在 cell 被重用时，我们需要记录图片下载的 cancel 操作，代码如下<br><img src="http://img.cdn.punmy.cn/15358915510212.jpg!wm" alt=""><br>处理类似，不再赘述。</p>
<p>通过 Xcode-&gt;Product-&gt;Profile(或者快捷键 cmd+I) 来启动 Instrument。然后选取一个空白（Blank）配置，进行下面操作</p>
<blockquote>
<p>右上角 + 按钮，然后搜索 <code>os_signpost</code>，然后选中将其拖入到左边栏，然后点击 Record 即可。<br><img src="http://img.cdn.punmy.cn/15358918715861.jpg!wm" alt=""></p>
</blockquote>
<p>一顿滑动之后，停止录制（Record），然后查看顶部面板，我们可以看到各个图片加载的耗时，以及我们在埋点时传入的元数据。<br><img src="http://img.cdn.punmy.cn/15358920774831.jpg!wm" alt=""><br>同时后续时间的一些 signpost 数据如下<br><img src="http://img.cdn.punmy.cn/15358923459450.jpg!wm" alt=""><br>从这张图我们可以看到同时下载数不超过5个，这样证明我们的 <code>cancel</code> 方法生效了。为了证明这一点，放大得到下图<br><img src="http://img.cdn.punmy.cn/15358923147799.jpg!wm" alt=""><br>可以看到滑动过程中确实产生了很多 metadata 是 <code>cancel</code> 的 signpost 数据。</p>
<p>如果我们想要看图片下载耗时，我们能可以看底部数据栏<br><img src="http://img.cdn.punmy.cn/15358926294639.jpg!wm" alt=""><br>Instrument 会按照 <code>SignpostID</code> 进行汇总，然后给出各项数据，比如个数、最大值、最小值、标准差、平均值。同一个 <code>SignpostID</code> 又分为 <code>Finished</code> 和 <code>Cancel</code>。还记得上面提到 <code>size-in-bytes</code> 么？这里每一个 Finished 后面都跟了一个这张图片的字节数。如果想用 metadata 数据进行分析，我们可以切到下图所示的分类。</p>
<p><img src="http://img.cdn.punmy.cn/15358929757440.jpg!wm" alt=""><br>Instrument 根据 <code>log handler</code> 的 <code>subsystem</code>、<code>category</code>、<code>format string</code>、<code>arguments</code> 各个参数进行了一个分层。因为我们在格式化字符串中只有一个参数，所以这里只展示了 arg0。然后会根据 <code>size-in-bytes</code> 类型，算出总加载大小以及最大值、最小值、标准差、平均值，所以通过它，我们可以快速分析一些元数据传入的数据。</p>
<p>前面提到为了保证 OSLog 的轻量性，大部分工作被推迟到 Instrument 来处理，所以如果我们在录制的时候采用即时模式(默认)，数据直接交由 Instrument 处理，它就会实时展示和记录相关数据。当我们触发的 signpost 足够多时，那么整个流程会变慢，甚至你的 App 和电脑都将变得卡顿。所以为了避免这种情况，在每次录制前，最好先更改它的录制模式。操作方式就是长按录制按钮，然后选择录制选项（Recording Options），然后在弹出的面板进行类似下图的操作，将默认的即使模式（Immediate Mode）更改为你想要的模式，示例中选的是最后5秒。<br><img src="http://img.cdn.punmy.cn/15358940972622.jpg!wm" alt=""></p>
<h4 id="兴趣点"><a href="#兴趣点" class="headerlink" title="兴趣点"></a>兴趣点</h4><p>如果我们只想简单记录一些点击事件，但是又不想让这些点击事件淹没在上面的大量 <code>signpost</code> 数据中，也不想每次都创建空白配置，然后自行添加 <code>os_signpost</code> 配置，那么我们就可以使用兴趣点(<code>Points Of Interest</code>)的方式。具体如何操作的呢？其实和其它的 <code>signpost</code> 类似，不过创建 <code>log handler</code> 时，<code>category</code> 参数要传入 <code>.pointsOfInterest</code>，这是一种会被 Instrument 自动识别的特殊分类。<br>创建和使用代码示例如下图<br><img src="http://img.cdn.punmy.cn/15358949360440.jpg!wm" alt=""><br><img src="http://img.cdn.punmy.cn/15358949032555.jpg!wm" alt=""></p>
<p>运行 Instrument，然后选择 <code>Time Profile</code> 配置，该配置会自带兴趣点一栏的数据。<br><img src="http://img.cdn.punmy.cn/15358951679891.jpg!wm" alt=""></p>
<h4 id="自定义-Instrument"><a href="#自定义-Instrument" class="headerlink" title="自定义 Instrument"></a>自定义 Instrument</h4><p>通过 Demo 演示了如何通过自定义 Instrument 来快速直接地进行记录和分析，展示面板基本类似上面的数据查看。至于如何创建自定义 Instrument，可以查看 <a href="https://developer.apple.com/videos/play/wwdc2018/410/" target="_blank" rel="external">Session 410 Creating Custom Instruments</a> 来了解更多。 </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过使用 <code>signpost</code>，我们可以轻易地记录时间段，捕获感兴趣的元数据，然后通过 Instruments 来查看和分析 signpost 数据，查看时间花在哪些地方，更清楚的了解到程序的行为。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文是 WWDC 2018 Session 405 的观后感，原视频和 pdf 可以在&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2018/405/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;看到。&lt;br&gt;首发于&lt;a href=&quot;https://xiaozhuanlan.com/topic/3789465012&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;小专栏&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;众所周知，应用交互的流畅度决定了用户对这款用户的喜爱度，所以对于每个 iOS 工程师而言，应用的流畅程度是非常重要的。而这里所说的流畅度在工程师层面来理解就是应用的性能是否处于一个比较优的状态。那我们在发现页面卡顿时，如何去检测卡顿是哪一段代码引起的呢？目前业界的卡顿检测已经非常多了，比如 Instrument 的 Time Profile，各种基于 &lt;code&gt;runloop&lt;/code&gt; 的卡顿率检测开源库。但是今天主要来说一说 iOS12 苹果为我们带来的一个新的检测方案，也就是基于 &lt;code&gt;OSLog&lt;/code&gt; 的一套新 API。&lt;/p&gt;
    
    </summary>
    
      <category term="原创" scheme="https://vongloo.me/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="WWDC" scheme="https://vongloo.me/tags/WWDC/"/>
    
  </entry>
  
  <entry>
    <title>WWDC 2018：理解崩溃以及崩溃日志</title>
    <link href="https://vongloo.me/2019/02/22/Understanding-Crash/"/>
    <id>https://vongloo.me/2019/02/22/Understanding-Crash/</id>
    <published>2019-02-22T14:13:46.000Z</published>
    <updated>2019-03-03T15:42:37.279Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文首发于<a href="https://juejin.im/post/5b1e833ce51d450686186557" target="_blank" rel="external">掘金</a>。</p>
</blockquote>
<p>人非圣贤，孰能无过。每个人在写代码的时候，或多或少都会犯错，那么如何调试、找出问题所在呢？让我们跟随苹果工程师一起了解一下崩溃是如何产生以及如何解决它们的吧。</p>
<a id="more"></a>
<h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h2><p>崩溃是什么？崩溃是当应用想要做某件事的时候，被意外终止。</p>
<h3 id="1-1-崩溃为什么会发生"><a href="#1-1-崩溃为什么会发生" class="headerlink" title="1.1 崩溃为什么会发生"></a>1.1 崩溃为什么会发生</h3><p>主要是以下几方面原因</p>
<ul>
<li>CPU 无法执行的代码。</li>
<li>被操作系统“强杀”，系统为了用户体验，会强制终止掉那些卡顿时间过长或者内存消耗过高的应用。</li>
<li>编程语言为了防止错误发生而触发的崩溃，如 <code>NSArray</code> 或者 <code>Swift.Array</code>  越界</li>
<li>开发者为了防止错误发生而触发的崩溃，比如一些非空判断的断言</li>
</ul>
<h3 id="1-2-崩溃长什么样子"><a href="#1-2-崩溃长什么样子" class="headerlink" title="1.2 崩溃长什么样子"></a>1.2 崩溃长什么样子</h3><h4 id="1-2-1-调试器里"><a href="#1-2-1-调试器里" class="headerlink" title="1.2.1 调试器里"></a>1.2.1 调试器里</h4><p>当我们连接着 <code>Xcode</code> 进行调试的时候，遇到崩溃，大概长这个样子。<br><img src="http://img.cdn.punmy.cn/15286007690540.jpg!wm" alt=""></p>
<p>当连着调试器的时候，我们能够拿到崩溃现场的一些调用栈以及对应的方法，当没有连着调试器的时候，系统会将崩溃日志存储到磁盘当中。</p>
<h4 id="1-2-2-崩溃日志里"><a href="#1-2-2-崩溃日志里" class="headerlink" title="1.2.2 崩溃日志里"></a>1.2.2 崩溃日志里</h4><p>通常情况下，<code>release</code> 模式的应用的崩溃日志是没有符号化的，日志内记录的都是地址。我们可以通过 <code>Xcode</code> 来将崩溃日志进行符号化，解析出对应文件名、方法名以及对应崩溃在第几行。</p>
<h3 id="1-3-获取崩溃日志"><a href="#1-3-获取崩溃日志" class="headerlink" title="1.3 获取崩溃日志"></a>1.3 获取崩溃日志</h3><p>获取崩溃日志的方式很多，我们先来了解一下如何通过 <code>Xcode Organizer</code> 来获取从 <code>TestFlight</code> 或<code>App Store</code> 下载的应用的崩溃日志。</p>
<h4 id="1-3-1-Organizer-Window"><a href="#1-3-1-Organizer-Window" class="headerlink" title="1.3.1 Organizer Window"></a>1.3.1 Organizer Window</h4><p>先来看一下下面这张图：</p>
<p><img src="http://img.cdn.punmy.cn/15286117125343.jpg!wm" alt=""></p>
<blockquote>
<p>下面数字 1~6 分别代表图中标注的 1~6</p>
</blockquote>
<ul>
<li>1.可以看到所有平台发布在 <code>App Store</code> 或者 <code>TestFlight</code> 上的应用。</li>
<li>2.崩溃日志列表，可以看到对应影响的设备数以及对应的平台、扩展（extension），如图中蓝色框标注的位置。</li>
<li>3.崩溃所在调用栈及崩溃位置的高亮。</li>
<li>4.在对应工程中打开崩溃所在的文件，并跳转到指定位置，方便追踪问题。</li>
<li>5.最近数据分析，包含系统和机型两个维度。</li>
<li>6.在崩溃数较多时，支持翻页。</li>
</ul>
<p>PS：上面6个只是简单介绍了一下主题部分，剩余的可以自行探索使用。比如搜索、对单个日志做一些笔记、以及将已修复的崩溃标记为已解决等等。</p>
<p>那么如何才能在 <code>Organizer</code> 中获取对应的崩溃日志呢？很简单，只需要做到下面几步</p>
<ul>
<li><ol>
<li>在 <code>Xcode</code> 中登录已付费的开发者帐号。</li>
</ol>
</li>
<li><ol>
<li>上传应用到 <code>App Store</code> 或 <code>TestFlight</code> 时，一并上传符号文件。</li>
</ol>
</li>
<li><ol>
<li>打开 <code>Xcode Organizer</code> 窗口，选中 <code>Crashes</code> tab(快捷键:<code>Cmd+Shift+6</code>)。</li>
</ol>
</li>
</ul>
<h4 id="1-3-2-Devices-Window"><a href="#1-3-2-Devices-Window" class="headerlink" title="1.3.2 Devices Window"></a>1.3.2 Devices Window</h4><p><img src="http://img.cdn.punmy.cn/15286130207605.jpg!wm" alt=""></p>
<p>连接上设备，打开 <code>Xcode</code>，使用快捷键 <code>Cmd+Shift+2</code> 来打开 <code>Devices Window</code>，选中对应设备，然后选择 <code>View Device Logs</code>，即可查看当前设备磁盘上的所有崩溃文件，找到应用对应的日志即可展开分析。</p>
<blockquote>
<p>有些时候，获取到的崩溃日志并没有符号化。这个时候需要自己做一些额外操作，这里可以参考我之前在<strong>知识小集</strong>分享过的一个小 tip——<a href="https://github.com/awesome-tips/iOS-Tips/blob/master/2017/12.md#ios%E5%BF%AB%E9%80%9F%E8%A7%A3%E6%9E%90%E5%B4%A9%E6%BA%83%E6%97%A5%E5%BF%97" target="_blank" rel="external">iOS快速解析崩溃日志</a>。</p>
</blockquote>
<h4 id="1-3-3-其它途径"><a href="#1-3-3-其它途径" class="headerlink" title="1.3.3 其它途径"></a>1.3.3 其它途径</h4><ul>
<li><code>Xcode</code> 的自动化测试（得到的是已符号化的日志）</li>
<li><code>Mac</code> 自带的 <code>Console</code> 应用，获取 <code>Mac</code> 或者模拟器的崩溃日志</li>
<li>iOS设备可通过这种操作获取，打开【设置】-&gt;【隐私】-&gt;【分析】-&gt;【分析数据】拿到对应的未符号化的崩溃日志，然后通过系统自带的分享即可传输到对应的设备上进行分析。</li>
</ul>
<h3 id="1-4-符号化最佳实践"><a href="#1-4-符号化最佳实践" class="headerlink" title="1.4 符号化最佳实践"></a>1.4 符号化最佳实践</h3><ul>
<li>上传应用的符号文件，以便苹果后台可以直接符号化崩溃日志，最终得以在 <code>Xcode Organizer</code> 的 <code>Crashes</code>tab 中呈现。</li>
<li>保留应用归档文件，以便做本地符号化，只要有归档文件在，<code>Xcode</code> 会自动进行符号化。</li>
<li>在 <code>Xcode Organizer</code> 的 <code>Archive</code>tab 为已开启 <code>bitcode</code> 的应用下载 <code>dSYM</code> 文件。</li>
</ul>
<h2 id="2-分析奔溃日志"><a href="#2-分析奔溃日志" class="headerlink" title="2. 分析奔溃日志"></a>2. 分析奔溃日志</h2><h3 id="2-1-崩溃日志的组成"><a href="#2-1-崩溃日志的组成" class="headerlink" title="2.1 崩溃日志的组成"></a>2.1 崩溃日志的组成</h3><ul>
<li>崩溃摘要，主要记录一些基本信息，比如机型、系统版本、崩溃时间等</li>
<li>崩溃原因</li>
<li>崩溃信息（这一部分在真机上处于隐私原因，一般都是不可见的，在模拟器和 <code>MacOS</code> 上可见）</li>
<li>崩溃线程的调用栈</li>
<li>崩溃发生时，其它线程的调用栈</li>
<li>寄存器状态</li>
<li>已加载的可执行二进制文件</li>
</ul>
<h3 id="2-2-如何分析"><a href="#2-2-如何分析" class="headerlink" title="2.2 如何分析"></a>2.2 如何分析</h3><p>首先从崩溃原因中的崩溃类型开始</p>
<p><img src="http://img.cdn.punmy.cn/15286161511718.jpg!wm" alt=""></p>
<p>如上图的崩溃类型为 <code>EXC_BAD_INSTRUCTION</code>，它代表 <code>CPU</code> 尝试在执行一段不存在或无效的代码，而导致进行被“杀死”。</p>
<p><img src="http://img.cdn.punmy.cn/15286169917791.jpg!wm" alt=""></p>
<p>然后我们可以找到崩溃线程的调用栈的前几行，结合崩溃信息（如果有的话）进一步分析。找到崩溃栈中第一处二进制名为应用名称所在那一行，进到对应文件对应的代码行数进行查看（如上图中标红的那一行），然后进一步分析。上图中的崩溃可以很明显看出其原因是对 <code>nil</code> 进行了强制解包。</p>
<h3 id="2-3-断言和先决条件导致的崩溃"><a href="#2-3-断言和先决条件导致的崩溃" class="headerlink" title="2.3 断言和先决条件导致的崩溃"></a>2.3 断言和先决条件导致的崩溃</h3><p>断言和先决条件的意义在于当错误发生时，强制终止当前进程。</p>
<p>上述提到的对 <code>nil</code> 强制解包导致的崩溃是断言和先决条件中的一种。而它们还包含下面几种情况：</p>
<ul>
<li>数据越界访问</li>
<li>算术溢出 </li>
<li>未捕获的异常</li>
<li>代码中的自定义断言</li>
</ul>
<h3 id="2-4-操作系统“杀死”应用导致的崩溃"><a href="#2-4-操作系统“杀死”应用导致的崩溃" class="headerlink" title="2.4 操作系统“杀死”应用导致的崩溃"></a>2.4 操作系统“杀死”应用导致的崩溃</h3><p>某些情况下，系统处于保护目的，会将一些异常的应用“杀死”。以下几种场景可能触发系统将应用“杀死”：</p>
<ul>
<li>看门狗事件，主线程长时间无响应</li>
<li>设备过度发烫</li>
<li>内存消耗殆尽</li>
<li>非法的应用签名</li>
</ul>
<p>以上几种场景导致的崩溃，其崩溃日志可以在上面提到的 <code>Device Window</code> 中查看，<code>Organizer Window</code> 并不一定能够收集到这些日志。更多细节可以参考苹果的这个技术讲座 <a href="https://developer.apple.com/library/archive/technotes/tn2151/_index.html" target="_blank" rel="external">Understanding and Analyzing Application Crash Reports</a>。</p>
<p>先来看一个关于看门狗的例子。</p>
<p><img src="http://img.cdn.punmy.cn/15286187612409.jpg!wm" alt=""></p>
<p>上面的崩溃类型为 <code>EXC_CRASH (SIGKILL)</code>，<code>SIGKILL</code> 一般代表的是系统终止了进程的运行，这种信号无法被应用捕获，进而也就无法处理。终止原因为 <code>Namespace SPRINGBOARD, Code 0x8badf00d</code>，如果你有查看上面提到的关于崩溃日志的讲座，你应该会知道 <code>Code 0x8badf00d</code> 代表什么。从终止描述中来看，是由于启动时长超过了 19.97 秒。</p>
<blockquote>
<p>这次总算知道为什么看门狗对应的 <code>code</code> 是 <code>0x8badf00d</code> 了，从这次苹果工程师的发音上来看，这个 <code>code</code> 的发音同 <code>ate bad food</code>。</p>
</blockquote>
<h4 id="2-4-1-如何避免启动超时"><a href="#2-4-1-如何避免启动超时" class="headerlink" title="2.4.1 如何避免启动超时"></a>2.4.1 如何避免启动超时</h4><p>应用审核被拒的比较常见的原因就包含启动超时这一项。那么如何来避免这种情况发生呢？苹果工程师给了我们这些建议：</p>
<ul>
<li>在真机上测试，因为看门狗在模拟器以及调试阶段是被禁用的</li>
<li>在低性能设备上测试，高性能设备响应肯定会快，无法体现出真实效果</li>
</ul>
<h4 id="2-4-2-如何避免内存问题"><a href="#2-4-2-如何避免内存问题" class="headerlink" title="2.4.2 如何避免内存问题"></a>2.4.2 如何避免内存问题</h4><p>常见的内存错误包含：过度释放、野指针（访问已释放对象）、内存访问越界（比如 C 数组）。我们还是通过一个日志来分析一下具体问题。</p>
<p><img src="http://img.cdn.punmy.cn/15286203651661.jpg!wm" alt=""></p>
<p>由上图中标注的1，我们知道崩溃类型为 <code>EXC_BAD_ACCESS(SIGSEGV)</code>，这种类型崩溃主要是有两种情况导致：</p>
<ul>
<li>对只读的内存地址进行写操作</li>
<li>访问不存在的内存地址</li>
</ul>
<p>通过崩溃栈中的<code>objc_release</code>、<code>object_dispose</code> 等，我们更加确定这是由于内存问题导致的崩溃。我们通过这几个线索可以知道，<code>LoginViewController</code> 实例在调用 <code>deinit</code> 方法销毁相关属性的时候，发生了内存问题，进而导致崩溃的产生。</p>
<p>我们回到日志的第一部分中的<code>Exception Codes</code>，苹果的工程师说可以根据经验以及日志中的相关信息得出结论，对应的 <code>BAD_ADDRESS</code> 为 <code>0x7fdd5e70700</code>。原因是 <code>0x7fdd5e70700</code> 刚好在日志中的这一段 <code>MALLOC_TINY            00007fdd5e400000-00007fdd5e800000</code> 地址范围内。</p>
<p><strong>一些关于内存及释放的基础</strong></p>
<p><img src="http://img.cdn.punmy.cn/15286214423478.jpg!wm" alt=""></p>
<p><code>Objective-C</code> 对象以及一些 <code>Swift</code> 对象的内存布局如图，当一个对象有效（未释放）时以 <code>isa</code> 开始，<code>isa</code> 指向它所属的类。<code>objc_release</code> 主要是读取对象的 <code>isa</code> 指针，然后将 <code>isa</code> 指针解除对 <code>Class</code> 的引用。</p>
<p>正常情况下，一切都能照常工作。如果对象已经被释放，会发生什么呢？<code>free</code> 函数调用后，会将对象删除，并且将其插入到包含了其它已释放对象组成的链表中，同时将之前 <code>isa</code> 区域指向链表中下一个已释放对象。</p>
<p><img src="http://img.cdn.punmy.cn/15286229962132.jpg!wm" alt=""><br><img src="http://img.cdn.punmy.cn/15286230171741.jpg!wm" alt=""></p>
<p>当之前的 <code>isa</code> 内存区域被写入成 <code>rotated free list</code> 指针时，意味着访问这个地址返回的将是一个无效的内存地址，进而导致崩溃。所以当 <code>objc_release</code> 去解除 <code>isa</code> 引用时，访问到的是 <code>rotated free list</code>，所以崩溃就发生了。</p>
<p>所以可以分析出，肯定是在释放某个属性时，该属性已经被释放。我们能知道具体是哪个属性导致的么？答案是肯定的。</p>
<p>目前从崩溃的那一行来看，<code>__ivar_destroyer</code> 是编译器帮我们自动生成的函数，所以我们无从知晓具体是哪一行导致的问题。我们只知道这个类有如图三个属性：</p>
<p><img src="http://img.cdn.punmy.cn/15286236439932.jpg!wm" alt=""></p>
<p>但是从 <code>@objc LoginViewController.__ivar_destroyer + 42</code> 可以获取到一些信息，<code>+42</code> 代表着汇编里面的该函数的偏移量。我们可以对 <code>__ivar_destroyer</code> 函数进行反汇编，然后看偏移量为42对应获取的是哪个属性，在 <code>Xcode</code> 中可以使用 <code>lldb</code> 调试。</p>
<p><img src="http://img.cdn.punmy.cn/15286240224231.jpg!wm" alt=""></p>
<p>断点后分别输入上图中黄色字的命令，分别为 <code>command script import lldb.macosx.crashlog</code>，<code>crashlog /Users/.../RideSharingApp-2018-05-24-1.crash</code>，后面的路径需要替换成你的崩溃日志路径。<code>Xcode</code> 会自动检索二进制文件以及对应的 <code>dSYM</code> 文件，然后符号化显示在 <code>lldb</code> 控制台中。然后我们找到崩溃处的地址，执行如下命令，即可得到对应的反汇编代码：</p>
<p><img src="http://img.cdn.punmy.cn/15286333493975.jpg!wm" alt=""></p>
<p>我们不需要理解每一行汇编的意思，每行后面的注释可以帮助我们理解，根据注释可以知道 1、2、3 处代码分别代表着 <code>userName</code>、<code>database</code>、<code>views</code> 的释放。回到上面提到的 <code>+42</code>，我们找到第3处的第一行，有一点需要注意的是大部分情况下汇编的偏移地址是返回地址，所以调用 <code>objc_release</code> 是在上一行。所以可以判断出是在释放 <code>database</code> 时出现了问题。虽然我们目前还不知道具体问题所在，但是可以通过这些信息缩小查找问题的范围，可以查找使用到 <code>database</code> 的地方，来找到真正的问题所在。 </p>
<h4 id="2-4-2-日志分析总结"><a href="#2-4-2-日志分析总结" class="headerlink" title="2.4.2 日志分析总结"></a>2.4.2 日志分析总结</h4><ul>
<li>理解崩溃日志产生的原因</li>
<li>检查崩溃栈信息 </li>
<li>使用反汇编帮我们找到更多线索来分析 <code>bad address</code> 问题</li>
</ul>
<h4 id="2-4-3-常见内存错误"><a href="#2-4-3-常见内存错误" class="headerlink" title="2.4.3 常见内存错误"></a>2.4.3 常见内存错误</h4><ul>
<li><p>objc_msgSend 或者 retain/release 崩溃<br>  <img src="http://img.cdn.punmy.cn/15286347974394.jpg!wm" alt=""></p>
</li>
<li><p>无法识别的方法异常<br>  <img src="http://img.cdn.punmy.cn/15286348142914.jpg!wm" alt=""></p>
</li>
<li><p>abort() inside malloc/free </p>
</li>
</ul>
<h3 id="2-5-日志分析建议"><a href="#2-5-日志分析建议" class="headerlink" title="2.5 日志分析建议"></a>2.5 日志分析建议</h3><ul>
<li>不要只关注崩溃发生的那一行代码，多查看一下和崩溃相关的代码，比如上面那个崩溃代码并不是真正导致 <code>bug</code> 出现的原因</li>
<li>查看所有调用栈，不要只关注崩溃所在线程的调用栈，非崩溃线程调用栈可以帮助我们查看崩溃时应用所处状态 </li>
<li>多查看一些崩溃日志，有些时候很多崩溃日志都是崩溃在同一个地方，但是某些崩溃日志会包含更多的信息</li>
<li>使用 <code>Xcode</code> 提供的工具来复现内存问题，比如 <code>Address Sanitizer</code> 或者 <code>Zombies</code></li>
</ul>
<h2 id="3-多线程问题"><a href="#3-多线程问题" class="headerlink" title="3. 多线程问题"></a>3. 多线程问题</h2><h3 id="3-1-崩溃日志中多线程问题的一些“症状”"><a href="#3-1-崩溃日志中多线程问题的一些“症状”" class="headerlink" title="3.1 崩溃日志中多线程问题的一些“症状”"></a>3.1 崩溃日志中多线程问题的一些“症状”</h3><ul>
<li>最难复现和诊断的一类 bug</li>
<li>多线程问题通常会引起内存竞争</li>
<li>多个线程执行着相似代码</li>
<li>同一个 bug 可能会有不同的崩溃日志</li>
</ul>
<h3 id="3-2-使用-Thread-Sanitizer-检测多线程问题"><a href="#3-2-使用-Thread-Sanitizer-检测多线程问题" class="headerlink" title="3.2 使用 Thread Sanitizer 检测多线程问题"></a>3.2 使用 Thread Sanitizer 检测多线程问题</h3><p>多线程问题即使我们拿到日志大概率情况下也无法分析问题所在，即使连着 <code>Xcode</code> 调试也不一定能够稳定复现，即使运气好能复现也可能分析不出具体问题。所以我们可以借助 <code>Xcode</code> 提供的工具来帮我们分析，这个工具就是 <code>Thread Sanitizer</code>。通过快捷键 <code>Cmd+shift+,</code>，然后选则 <code>Diagnostics</code> tab，勾选 <code>Thread Sanitizer</code> 即可。如下图所示</p>
<p><img src="http://img.cdn.punmy.cn/15286367494006.jpg!wm" alt=""></p>
<ul>
<li>可稳定复现多线程 bug</li>
<li>在模拟器下也可进行</li>
<li>只查找当前正在执行的代码的问题</li>
</ul>
<h3 id="3-3-实用建议"><a href="#3-3-实用建议" class="headerlink" title="3.3 实用建议"></a>3.3 实用建议</h3><p>在创建 <code>GCD Queue</code>、<code>(NS)OperationQueue</code>、<code>(NS)Thread</code> 时，使用自定义名称，方便后续调试以及崩溃日志内查看。</p>
<pre><code class="Swift">
<span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.example.myapp.networking"</span>)

<span class="keyword">let</span> operationQueue = <span class="type">OperationQueue</span>()
operationQueue.name = <span class="string">"Networking OperationQueue"</span>

<span class="keyword">let</span> thread = <span class="type">Thread</span>(...)
thread.name = <span class="string">"Networking Thread"</span>
</code></pre>
<h3 id="3-4-额外建议"><a href="#3-4-额外建议" class="headerlink" title="3.4 额外建议"></a>3.4 额外建议</h3><ul>
<li>使用真机测试</li>
<li>尝试复现，从用户处拿到崩溃日志后根据调用栈尝试去复现问题</li>
<li>使用工具来查找难以复现的 bug，下面两个工具的更多使用方式可以参考 <a href="https://developer.apple.com/videos/play/wwdc2016/412/" target="_blank" rel="external">WWDC 2016 Session 412 Thread Sanitizer and Static Analysis</a><ul>
<li>使用 <code>Address Sanitizer</code> 来查看内存问题</li>
<li>使用 <code>Thread Sanitizer</code> 来查看多线程问题</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文首发于&lt;a href=&quot;https://juejin.im/post/5b1e833ce51d450686186557&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;掘金&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;人非圣贤，孰能无过。每个人在写代码的时候，或多或少都会犯错，那么如何调试、找出问题所在呢？让我们跟随苹果工程师一起了解一下崩溃是如何产生以及如何解决它们的吧。&lt;/p&gt;
    
    </summary>
    
      <category term="原创" scheme="https://vongloo.me/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="WWDC" scheme="https://vongloo.me/tags/WWDC/"/>
    
  </entry>
  
  <entry>
    <title>时光的河如海流</title>
    <link href="https://vongloo.me/2019/02/03/2018-Summary/"/>
    <id>https://vongloo.me/2019/02/03/2018-Summary/</id>
    <published>2019-02-03T14:13:46.000Z</published>
    <updated>2019-03-03T15:42:37.279Z</updated>
    
    <content type="html"><![CDATA[<p>老规矩，这次又是2018年的最后一天，是时候更新一下年终总结了，水一下，纯当一个记录~</p>
<a id="more"></a>
<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>今年工作上的变动还是蛮大的，从年初的直播 SDK 拆分完成之后的交付，到4月份的时候去到美拍北京分部，再到12月底的离职，结束了在美图将近5年的时光，感谢在美图待的这几年，自己从一个无从下手的菜鸟慢慢变成一个得心应手的老菜鸟。由于自身原因（老婆在广州，后面生活部分也有提到），在年底的时候裸辞，然后去到广州，开启一段找工作之旅，希望年后有好消息😃。</p>
<p><img src="http://img.cdn.punmy.cn/wow.png!wm" alt="wo"></p>
<p>这一年来主要是在北京，自己的角色也发生了一些变化，稍微了解了一点点的“管理”的皮毛，也感谢这个机会，让自己在非技术层面上也有一定的收获。<br>到北京后主要是负责美拍 iOS 社区的相关开发，其中大部分都是日常迭代，乏善可陈。比较有成就感的两件事：</p>
<ul>
<li>总算实现了一套基于 YYModel 和 IGListKit 的方案来替代现有美拍基于 ResetKit(CoreData) 的方案，最终在新 App (<a href="https://itunes.apple.com/cn/app/vcus-%E7%94%A8%E9%9F%B3%E4%B9%90%E6%8B%8Dvlog/id1445969821?mt=8" target="_blank" rel="external">VCUS</a>)中实践上线，不知道最终会不会在美拍中上线。后面也会更新一个系列，名字大概叫做《CoreData 从入门到放弃》，应该不会断更，可以期待一下~</li>
<li>优化 Feed 滚动，滚动过程中只加载最终停下的区域的 cell，并且将其解耦成通用逻辑，无明显侵入。</li>
</ul>
<h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p><img src="http://img.cdn.punmy.cn/IMG_3390.png!wm" alt="IMG_3390"></p>
<p>生活应该从微信的免“单”惊喜开始，不知道是不是预兆，去年年底的时候微信支付在情人节那天，被免单了。然后在这一年，自己真的脱单了，顺便还结了婚，感恩。</p>
<p>4月份的时候确定了要去北京，碰巧大学好哥们研究生毕业要去北京爱奇艺，所以一起和他的两个研究生同学合租了，住在北五环上，4个人大概每个月1.2w的房租（可怕😂）。得亏大学老哥的一首好厨艺，几乎每个周末都会开荤，自己下厨，也偶尔周末一起出去健身，打球。</p>
<p>中间清明放假回了一趟家，然后在老家贷款买了一套房，也跻身泱泱房奴大军。。。</p>
<p>12月底离职来到老婆在的城市–广州，直接从冬天进入夏天，舒服。由于裸辞，没有工作，所以每天除了接老婆上下班，基本上就是提升厨艺和准备面试，以及上面提到的那个系列博客的撰写。</p>
<h3 id="旅游"><a href="#旅游" class="headerlink" title="旅游"></a>旅游</h3><p>在北京其实比较少出去，也就刚来的时候去了一下南锣鼓巷以及后海酒吧一条街，喝了杯酒感受了一下。再就是团建一起自驾去了内蒙古乌兰布统大草原，挺美的，尤其是日落时候在一望无际的草原马路上开车，真的太棒了。</p>
<p><img src="http://img.cdn.punmy.cn/LRG_DSC00538.jpg!wm" alt="LRG_DSC00538"></p>
<p>8月份的时候和老婆去了长城、天安门、圆明园，本打算去故宫，只可惜时间太赶，过去的时候已经关门了，后面自己和同事去了一次😂。<br>国庆和中秋那段时间，休了一波婚假（算上中秋国庆，22天长假），带老婆和家人一起自驾去了桂林，只待了两天，后续有机会再去。<br>11月底的时候和老婆去了一趟成都和重庆，成都主要是春熙路和宽窄巷子那边打卡，然后吃了一些川大神推荐的成都名小吃。晚上吃蜀大侠火锅，排队排了3个多小时（尴尬），辛苦川大神下班跑这么远来请我吃火锅。本来想按川大神的建议自驾去四姑娘山，但是由于自己自驾经验少，而且川西路线都非常险，而且可能伴随高原反应，所以退而求其次，去了毕棚沟，事后也证明确实有高反，幸好没自驾。毕棚沟，5星推荐，一“图”以蔽之。</p>
<p><img src="http://img.cdn.punmy.cn/15492369881565.jpg!wm" alt="-w912"></p>
<p>然后由于裸辞，自己之前没买电脑，所以需要买一台 MBP，刚好小潘说他的工牌买 MBP 可以9.4折，所以元旦后去了一趟香港，买了台 MBP。</p>
<blockquote>
<p>这里需要吐槽一下，由于TimeMachine 恢复一直失败，然后我就格盘重装，结果因为家里网络问题，一直连接不上苹果的服务器，所以系统安装文件一直无法下载，然后预约天才吧，客服说帮我预约了当天晚上7.30的，然后还说如果你提前去的话可以先去周围的授权店让他们帮忙安装新系统。结果大老远跑到天河区，真是被气死，跑到其中一家客服推荐的授权店，我还没说完情况，那位店员就说装系统要收费300（？？？），然后就想着在周边吃个饭，然后等到7.30再去让天才装，结果去了之后，天才说我没有预约。呵呵，我去年买了个登山包，超耐磨。第一次预约天才吧，就遇到这种客服？？？后面自己回去倒腾半天，最后用手机热点总算下载好了安装镜像，🌶🐔🍎💊</p>
</blockquote>
<h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><p>这一年，手游占比90%，基本上集中在吃鸡和农药。刚到北京的时候，主要是和同学打王者，他是王者段位，然后经常用小号带我，反正我负责坑就完事了。由于当时和老婆异地，每天都会视频，所以当时为了避免无聊，就把她也拉入坑，和我一起玩吃鸡。<br>英雄联盟玩的次数屈指可数，主要是不想去网吧，自己由于换电脑，没有装双系统，IG 夺冠后同学一直约，所以就装了双系统，偶尔周末玩一下午，反正我也是负责坑，有人 carry 就行。</p>
<h3 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h3><p>这一年不管是生活还是工作，都变化蛮大的。从单身变成两个人一起生活，从朝十晚七变成失业在家做“家庭煮夫”，用浩文和小潘的话来说就是“软饭硬吃”。总得来说2018算是比较惊喜的一年，感恩~</p>
<p>2019年（农历，嘿嘿）也即将来临，希望自己在工作和生活中都能稳步前进，订几个小目标：</p>
<ul>
<li style="list-style: none"><input type="checkbox"> 多一些产出（开源项目和博客）</li>
<li style="list-style: none"><input type="checkbox"> 学会 JS 以及 Python，最好能用在实际应用中</li>
<li style="list-style: none"><input type="checkbox"> 刷 leetcode，重新学一下数据结构个算法</li>
<li style="list-style: none"><input type="checkbox"> 把之前买的纸质书和电子书看完</li>
<li style="list-style: none"><input type="checkbox"> 买车</li>
<li style="list-style: none"><input type="checkbox"> 带老婆吃遍广州的米其林店</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;老规矩，这次又是2018年的最后一天，是时候更新一下年终总结了，水一下，纯当一个记录~&lt;/p&gt;
    
    </summary>
    
      <category term="扯淡集" scheme="https://vongloo.me/categories/%E6%89%AF%E6%B7%A1%E9%9B%86/"/>
    
    
      <category term="杂谈" scheme="https://vongloo.me/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="原创" scheme="https://vongloo.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>使用 Travis CI 实现 Hexo 博客自动部署</title>
    <link href="https://vongloo.me/2018/10/28/Blog-Automation/"/>
    <id>https://vongloo.me/2018/10/28/Blog-Automation/</id>
    <published>2018-10-28T15:18:46.000Z</published>
    <updated>2019-03-03T15:42:37.279Z</updated>
    
    <content type="html"><![CDATA[<p>现在使用的博客系统是 Hexo+GitHub Pages，每次发布新的文章时流程甚是繁琐，是否有好的方式来提高效率，专注于【写】这件事上呢？</p>
<a id="more"></a>
<p>之前从 Jeklly 转到 Hexo，发现 Hexo 比较符合我的习惯，但是每次写一篇新文章要发布，流程有点麻烦，具体我们可以来看看。在流程介绍前，先说一下我的写作环境。</p>
<blockquote>
<p>Markdown 编辑器：MWeb<br>博客系统：Hexo</p>
</blockquote>
<p>至于如何搭建基于 Hexo + GitHub Pages，这里就不说了，网上教程一大堆，而 MWeb 的一些基本使用以及进阶使用，在其官网上作者已经给了充分的介绍，这里也不再赘述，在我们只关心如何优化现有流程。好了，废话说完我们看下现有流程，以及我们期望的流程。</p>
<h2 id="现有流程"><a href="#现有流程" class="headerlink" title="现有流程"></a>现有流程</h2><ul>
<li>用 <code>hexo n &quot;some title&quot;</code> 生成一个 <code>markdown</code> 文件</li>
<li>MWeb 写文章，可能还要插入图片</li>
<li>上传图片到图床，替换 markdown 中的本地图片路径为图床链接</li>
<li><code>hexo g</code>、<code>hexo s</code> 确认无误后，<code>hexo d</code></li>
</ul>
<blockquote>
<p>这里要推荐一波 MWeb，他可以真正让你专注于写作，如果需要插入图片，只需要截图后粘贴，或复制后粘贴，或直接把图片拖到编辑窗口中即可。<br>得益于 MWeb 外部文档的概念，我们只需要把 Hexo 的 source 文件加添加到 MWeb 当中，然后进行简单的配置即可，如下图所示<br><img src="http://img.cdn.punmy.cn/15408215810799.jpg" alt=""></p>
</blockquote>
<p>现有流程有哪些麻烦的地方呢？需要本地安装 Hexo，每次换电脑都要重新安装，有时候因为国内这尿性，Hexo 根本就安装不下来，也是很无奈。然后每次还得 <code>hexo g/s/d</code>，让写作欲大大降低。</p>
<h2 id="期望的流程"><a href="#期望的流程" class="headerlink" title="期望的流程"></a>期望的流程</h2><ul>
<li>直接使用 MWeb 生成 md 文件</li>
<li>图片加水印</li>
<li>写完之后，推送到 GitHub，自动生成博客</li>
</ul>
<h2 id="动手实现"><a href="#动手实现" class="headerlink" title="动手实现"></a>动手实现</h2><p>第一个就不多说了，直接说下图片加水印。</p>
<h3 id="图片加水印"><a href="#图片加水印" class="headerlink" title="图片加水印"></a>图片加水印</h3><p>上面说到 MWeb 会帮我们自动上传文章引用的图片到图床，前提是我们配置了图床。我这里使用的是七牛作为图床。先来看下我的七牛相关配置以及 MWeb 中关于七牛的配置。</p>
<p>由于<a href="https://developer.qiniu.com/fusion/kb/1319/test-domain-access-restriction-rules" target="_blank" rel="external">七牛测试域名已经无法再使用</a>，所以必须要绑定一个域名，而且该域名需要备案过。</p>
<p><img src="http://img.cdn.punmy.cn/15408224031789.jpg" alt=""><br><img src="http://img.cdn.punmy.cn/15408228089469.jpg" alt=""></p>
<blockquote>
<p>关于上面的第五点，图片处理样式的别名，七牛上我配置的是 <code>wm</code>，样式分割线我设置的是 <code>!</code>，所以 MWeb 里面我填的是 <code>!wm</code>，你只需要按照你自己的样式去弄即可。最后 MWeb 给的链接类似 <code>http://sub.your.domain/xxxx.jpg!wm</code> 这样的。</p>
</blockquote>
<p>其中如何绑定域名，七牛上都有对应的<a href="https://support.qiniu.com/hc/kb/article/68977/" target="_blank" rel="external">开发文档</a>，对着弄就行。</p>
<p>到这一步，我们实现了图片加水印，当然这是七牛提供的在线服务。<strong>这里关键点是，你需要一个备案过的域名。</strong></p>
<h3 id="自动生成博客"><a href="#自动生成博客" class="headerlink" title="自动生成博客"></a>自动生成博客</h3><p>一篇文章写完后我们就需要把它发布到博客上，这里不再采取 <code>hexo g/s/d</code> 的方式，而是使用 <code>Travis CI</code> 来帮我们做自动部署，我们只需要关心文章的推送，而不关心博客的生成，生成直接交给 <code>Travis CI</code>。</p>
<p>相信你已经有了名为 <code>xxx.github.io</code> 的 repo，然后博客应该是放在 <code>master</code> 分支上的。把远端 repo 拉到本地，然后新建一个分支，分支名随意，假设为 <code>hexo</code>，删除所有内容，然后把 Hexo 生成的整个文件夹内容移到这个文件夹中，包括 theme 文件夹，这里需要注意的是如果子文件夹中包含 <code>.git</code> 文件，你需要删除，或者使用 submodule 的形式，我这里采用的是删除的方式。</p>
<h4 id="生成-Personal-access-tokens"><a href="#生成-Personal-access-tokens" class="headerlink" title="生成 Personal access tokens"></a>生成 Personal access tokens</h4><p><img src="http://img.cdn.punmy.cn/15408253054127.jpg!wm" alt=""></p>
<p>按照图中步骤生成 Token，这一步在后面要用到，生成之后最好复制一下，以免关掉页面后，就看不到只能重新生成了。</p>
<h4 id="Travis-CI-配置"><a href="#Travis-CI-配置" class="headerlink" title="Travis CI 配置"></a>Travis CI 配置</h4><p>首先我们用 GitHub 登录上 <a href="https://travis-ci.org" target="_blank" rel="external"><code>Travis CI</code></a>，然后找到你想要开启的 Repo，然后将其开关打开，做如下图配置即可。</p>
<p><img src="http://img.cdn.punmy.cn/15408248530555.jpg!wm" alt=""></p>
<p>紧接着我们在电脑上需要使用命令 <code>sudo gem install travis</code> 安装 <code>travis</code>，然后在 hexo 文件夹下创建一个 <code>.travis.yml</code>。下面是我的整个安装记录步骤及日志，关键点我都加了注释：</p>
<details><br><summary>👈点击安装步骤日志</summary><br><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 当前在 hexo 根目录下，且 .travis.yml 文件已在根目录下创建好了</div><div class="line"><span class="meta">$</span> sudo gem install travis    </div><div class="line">Password:</div><div class="line">Fetching: backports-3.11.4.gem (100%)</div><div class="line">Successfully installed backports-3.11.4</div><div class="line">Fetching: addressable-2.4.0.gem (100%)</div><div class="line">Successfully installed addressable-2.4.0</div><div class="line">... # 中间一堆日志省略了</div><div class="line"></div><div class="line"><span class="meta">$</span> travis login           # 使用 GitHub 登录，下面是日志不用管                                                                                                                                  </div><div class="line">We need your GitHub login to identify you.</div><div class="line">This information will not be sent to Travis CI, only to api.github.com.</div><div class="line">The password will not be displayed.</div><div class="line"></div><div class="line">Try running with --github-token or --auto if you don't want to enter your password anyway.</div><div class="line"></div><div class="line">Username: wang9262     # 输入 GitHub 用户名</div><div class="line">Password for wang9262: **************  # 输入 GitHub 密码</div><div class="line">Successfully logged in as wang9262!</div><div class="line"></div><div class="line">travis encrypt ENVName=yourtoken --add   #  ENVName 可以换成任意字符串，yourtoken 换成上面生成的 token，比如我的是 BlogToken=12345</div></pre></td></tr></table></figure><br><br></details>

<p>以上操作执行完，打开 <code>.travis.yml</code>，会发现已经生成了一些类似下面代码</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">env:</span></div><div class="line">  <span class="symbol">global:</span></div><div class="line">    - <span class="symbol">secure:</span> wrewrewrwebJ+XFbrUGTM0kIr.....</div></pre></td></tr></table></figure>
<p>然后 <code>.travis.yml</code> 具体内容，可以参考我这个<a href="https://github.com/wang9262/wang9262.github.io/blob/hexo/.travis.yml" target="_blank" rel="external">分支</a>上的内容即可。其中上面那个<a href="https://github.com/wang9262/wang9262.github.io/blob/hexo/commit-message.sh" target="_blank" rel="external">脚本</a>需要说明的是为了给每次 <code>commit</code> 时添加记录用的，同时为了防止之前的记录被覆盖，需要先将远端的 <code>.git</code> 拷贝到本地，然后再进行 <code>commit</code>，这样可以保证所有历史记录都在，这个脚本也是放在根目录下的。</p>
<blockquote>
<p>我用的命令行方式，如果用的不是命令行方式，可以参考网上的，在网页上设置环境变量，把 Token 填入到网页上，也就是上图中的2、3两个标记点，2填入环境变量名，3处填入 Token，也可以新增其它环境变量。</p>
</blockquote>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>现在每次有新文章发布，只需要本地写好后，把 markdown 文件推到远端的 <code>hexo</code> 分支即可，不需要额外操作，这样可以便捷地在多台电脑上发布内容，不必为环境配置而担心。当然这篇文章也是通过这种方式发布的，效果还行吧。</p>
<p><img src="http://img.cdn.punmy.cn/15408284851484.jpg!wm" alt=""></p>
<p>接下来的计划就是把文章顶部的一些 hexo 用到的元信息通过脚本自动生成而不需要手动去添加。</p>
<p>如果你根据上面步骤，没有达到想要的效果，可以在下方留言，一起交流沟通。当然如果你有更高效的方式，也欢迎分享一下~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在使用的博客系统是 Hexo+GitHub Pages，每次发布新的文章时流程甚是繁琐，是否有好的方式来提高效率，专注于【写】这件事上呢？&lt;/p&gt;
    
    </summary>
    
      <category term="备忘记录" scheme="https://vongloo.me/categories/%E5%A4%87%E5%BF%98%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="原创" scheme="https://vongloo.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="笔记" scheme="https://vongloo.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>GMTC 之旅</title>
    <link href="https://vongloo.me/2018/10/28/Some-thoughts-On-GMTC-2018/"/>
    <id>https://vongloo.me/2018/10/28/Some-thoughts-On-GMTC-2018/</id>
    <published>2018-10-28T05:27:58.000Z</published>
    <updated>2019-03-03T15:42:37.279Z</updated>
    
    <content type="html"><![CDATA[<p>上周凑巧有机会拿到 GMTC 的票，然后去现场体验了一下。这里主要记录第一次参加这种线下大会的一些感受。</p>
<a id="more"></a>
<p>大会在 6.21~6.22 进行，由于时间问题，我只去了两个自己感兴趣的专题：性能优化专场以及 iOS 新技术专场。<br>性能优化专场在21号下午进行，当天早上 <code>Flutter Release Preview 1</code> 放出，更多关于 Flutter 的文章，可以在我们公众号<code>知识小集</code>上获取。</p>
<h3 id="性能优化专场"><a href="#性能优化专场" class="headerlink" title="性能优化专场"></a>性能优化专场</h3><p>当天下午提前一小时从公司出发，1：30 到现场时，会场已经满座，只能坐地下，第二场一些人走了之后才空出一些座位。</p>
<p>第一场是 <code>LinkedIn</code> iOS 工程师带来的《LinkedIn 移动应用的性能优化实践》，分享了领英的一些性能优化实践。<br>随着应用体量（功能）变得越来越庞大，最初的应用架构会变得越来越撑不住，所以需要适时调整合理的应用架构。领英使用组件化和标准化来提高代码复用率以及项目复杂度，进而减少了线上的崩溃率和性能问题。建立完善的性能监控体系对线上用户的性能数据进行分析，发现问题并解决问题，同时使用 AB 实验来快速验证效果。最后作者通过一个实际案例来阐述，以上几点是如何在项目中落地实践的。通过线上监控发现页面加载比较慢，主要原因有：网络请求多、数据量大、页面渲染慢，对这三个分别采取对应措施来解决：网络优化，使用 <code>http/2</code>、数据简化（服务端精简返回字段）、布局优化（领英开源库 <code>LayoutKit</code>，将布局计算放到后台线程）。</p>
<p>其实大部分应用都可能存在上述问题，从网络发起到页面完整渲染展示，里面很多的关键节点都可能导致页面加载过慢。对于数据简化这一块，作者有提到他们内部有一个 <code>Frontend Deco</code> 平台，客户端可以根据实际情况选择需要服务端返回的字段，然后生成一个 <code>recipe_id</code>，请求时带上这个参数，则只会返回对应的数据，进而实现数据精简。</p>
<blockquote>
<p>这里有一点很疑问，理论上性能优化是肯定能改善用户体验的，这里对性能优化做 AB 实验是不是有点多此一举？</p>
<p>分享者的回答：<br><img src="http://img.cdn.punmy.cn/15407047702510.jpg" alt=""></p>
</blockquote>
<p>剩下的 3 场主要是前端和安卓上的性能优化，由于自己对于安卓和前端技术一无所知，所以只是大概听了一下。<br>印象比较深的是阿里的监控体系，还原用户“事发现场”，大致原理就是记录首屏时的所有数据，用户操作导致的增量数据页实时记录，进而实现用户操作现场的还原。<br>爱奇艺的“极致”性能优化，对于功耗的测量，使用 <code>PowerMonitor</code> 来检测分析，同时使用 AI 来做自动化测试。同时开源了 <code>LiteApp</code>，感兴趣的可以自行在 <code>GitHub</code> 上搜索。</p>
<h3 id="iOS-新技术专场"><a href="#iOS-新技术专场" class="headerlink" title="iOS 新技术专场"></a>iOS 新技术专场</h3><p>这一场在22号早上9点半开始，9点到达会场，人没有昨天那么多，空位很多。这个专题出品人是嘀嘀出行的戴铭老师。这个专场有三个主题，讲师分别来自 Instagram、美团、美甲帮。</p>
<p>来自 Instagram 的工程师主要分享了复杂列表的解决方案、对照实验、以及加快编译速度。<br>复杂列表使用他们自己开源的 <code>IGListKit</code> 以及 <code>MVVM</code> 架构来实现代码复用，各自业务团队代码集中在 <code>SectionController</code> 来达到解耦，各个业务团队只需专注于自己的业务逻辑。同样 Instagram 也通过 AB 实验来抉择出一些较好的产品需求，同时通过 AB 实验来保持产品的快速迭代。同时随着 AB 实验的增多，难免会遇到一些互斥实验或者互相影响的实验，所以在设计一些实验时，也需要尽量避免这种情况。对于可能互相干扰的实验，作者举了一个例子以及可能的几个解决方案，思路也是很不多的，具体内容大家可以去官网上找到对应的 PPT 链接，下载查看。<br>最后一个分享点，也是目前大部分 iOS 开发者的槽点，就是 <code>Xcode</code> 的编译速度。随着工程及代码量的增大，编译速度也随之变慢，从原来的十几秒到几分钟到半小时（真正的“带薪编译”），编译时的心情也依次改变：😀-&gt;🙂-&gt;😰-&gt;😡-&gt;💀。Facebook 内部使用 <code>Buck+Focus</code> 来加快编译速度，<a href="https://github.com/facebook/buck" target="_blank" rel="external">Buck</a> 目前已开源，据作者说，使用 <code>Buck+Focus</code> 后，编译速度又能到十几秒，感兴趣的可以尝试一下。</p>
<p>来自美团的臧成威老师分享了他们即将开源的面向对象的响应式架构：<code>EasyReact</code> 以及 <code>EasyMVVM</code>，相信用过 <code>ReactiveCocoa</code> 的同学都很清楚，每次调试时，调用栈非常深，而且中间的调用栈内容几乎没啥用处，调试起来比较费劲，作者表示 <code>EasyReact</code> 相对于 <code>ReactiveCocoa</code>，同样的5次变换操作，前者调用栈只有10层，而 <code>ReactiveCocoa</code> 有50层。关于其它的对比，可以参考一下作者放出的 <code>benchmark</code> 对比图</p>
<p><img src="http://img.cdn.punmy.cn/15304329513135.jpg" alt=""></p>
<p>最后美甲帮的靛青分享了他的解决异构列表的开源库 <a href="https://github.com/DianQK/Flix" target="_blank" rel="external"><code>Flix</code></a>。主要是通过几个实例来一步步给出 Flix 的设计理念，以及一些使用场景，会上代码涉及的较多，感兴趣的可以自行去 GitHub 上翻阅对应源码。</p>
<h3 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h3><p>AB 实验作为一种快速验证想法的工具，目前国内外大公司应该都有在使用，相对于传统的版本迭代，AB 实验可以较好的缩小迭代周期，在以数据结果为导向的情况下，也能快速得出结论，不需要做过多争辩。但同时它也带来了一些挑战，比如 AB 实验的设计，以及对实验结果的分析等。</p>
<p>性能优化作为每个开发者都应该掌握的技能，开发过程中需要多考虑性能上的问题，不能一味追求需求完成速度，还要兼顾质量。</p>
<p>整个两场专题听下来，感受最深的就是几乎每个小主题都在分享自己的开源框架，一方面可以提高自己公司的影响力，另一方面也可以吸引到更多人。</p>
<blockquote>
<p>PS：以上所有场次的 PPT 均可在<a href="https://gmtc.geekbang.org/schedule" target="_blank" rel="external">这里</a>下载到</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周凑巧有机会拿到 GMTC 的票，然后去现场体验了一下。这里主要记录第一次参加这种线下大会的一些感受。&lt;/p&gt;
    
    </summary>
    
      <category term="扯淡集" scheme="https://vongloo.me/categories/%E6%89%AF%E6%B7%A1%E9%9B%86/"/>
    
    
      <category term="杂谈" scheme="https://vongloo.me/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="原创" scheme="https://vongloo.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>替换系统音量提示的实现和遇到的坑</title>
    <link href="https://vongloo.me/2018/06/03/Replace-System-Volume-View/"/>
    <id>https://vongloo.me/2018/06/03/Replace-System-Volume-View/</id>
    <published>2018-06-03T09:47:58.000Z</published>
    <updated>2019-03-03T15:42:37.279Z</updated>
    
    <content type="html"><![CDATA[<p>相信平时大家在用 iPhone 看视频调节音量时，总会被系统的音量提示所打扰，因为它会遮住一部分内容。所以很多视频应用都使用自定义音量视图的方式来替代系统的音量提示。</p>
<a id="more"></a>
<p>比如下面三张截图，分别来自 Instagram、哔哩哔哩、即刻</p>
<p><img src="http://img.cdn.punmy.cn/15247541167324.jpg" alt=""></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>这里主要记录一下在项目中如何替换系统音量提示视图的过程。通过 <code>Google</code> 和 <code>stackoverflow</code>，可以查到，如果要自定义音量提示，需要做到以下几步：</p>
<ol>
<li>激活 <code>AudioSession</code></li>
<li>创建一个 <code>MPVolumeView</code>，并将其添加到当前可见的视图层级当中，同时将其 frame 设置到不可见区域</li>
<li>监听音量按钮触发事件，改变音量提示</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>然后为了调用统一且音量视图层级永远在最上方（即不被 <code>Alert</code> 等挡住），首先想到使用一个 <code>UIWindow</code>，然后自定义视图和系统的视图加到这个视图层级上，初始化时 <code>frame</code> 为 <code>CGRectZero</code>，<code>hidden</code> 属性为 <code>NO</code>（注意这里必须为 <code>NO</code>，不然系统音量提示仍会出现，上面说到的第2点）；要显示时设置其 <code>frame</code> 设置成 <code>mainScreen</code> 的 <code>bounds</code>，然后展示即可。</p>
<blockquote>
<p>由于自己创建的 <code>UIWindow</code> 的 <code>hidden</code> 属性默认是 <code>YES</code>，所以需要手动将其设成 <code>NO</code>。<br>音量按钮每触发一次，变化量都是 6.25%，连续按16次，即可调节至最大或最小</p>
</blockquote>
<p>上述的第3步有两种方式可以做到，各有优劣，下面来做一个简单介绍。</p>
<h4 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h4><p>通过 <code>KVO</code> 监听 <code>[AVAudioSession sharedInstance]</code> 的 <code>outputVolume</code> 属性，然后来显示自定义的 UI 控件。这种方式有一个不好的地方就是，在音量调节至最大/最小时，这个时候再调大/调小音量，由于 <code>outputVolume</code> 的值不变，所以不会触发 <code>KVO</code>，也就无法展示自定义音量视图。代码大概长下面这样</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    [[<span class="built_in">AVAudioSession</span> sharedInstance] removeObserver:<span class="keyword">self</span></div><div class="line">                                         forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(outputVolume))];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addObserver &#123;</div><div class="line">    [[<span class="built_in">AVAudioSession</span> sharedInstance] addObserver:<span class="keyword">self</span></div><div class="line">                                      forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(outputVolume))</div><div class="line">                                         options:<span class="built_in">NSKeyValueObservingOptionNew</span></div><div class="line">                                         context:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</div><div class="line">                      ofObject:(<span class="keyword">id</span>)object</div><div class="line">                        change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change</div><div class="line">                       context:(<span class="keyword">void</span> *)context &#123;</div><div class="line">    <span class="keyword">if</span> ([change isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        <span class="built_in">NSNumber</span> *volumeNum = change[<span class="string">@"new"</span>];</div><div class="line">        <span class="keyword">if</span> (volumeNum) &#123;</div><div class="line">            [<span class="keyword">self</span> volumeDidChange:[volumeNum floatValue]];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)volumeDidChange:(<span class="built_in">CGFloat</span>)volume &#123;</div><div class="line">    <span class="comment">// 显示自定义音量提示</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p>这种方式通过监听系统私有（未公开的）通知，名字是 <code>AVSystemController_SystemVolumeDidChangeNotification</code>，这个监听不会受到最大/最小音量时，调大/调小音量的影响，只要音量键按下，始终都会触发。但是这个通知由于是私有的，可能存在被拒风险，而且将来系统版本该通知名字发生改变，由于是硬编码而不像其它系统通知使用的是常量，会导致监听不到的问题。</p>
<p>代码大概长这样</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">NSNotificationName</span> <span class="keyword">const</span> kSystemVolumeDidChangeNotification = <span class="string">@"AVSystemController_SystemVolumeDidChangeNotification"</span>;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addObserver &#123;</div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></div><div class="line">                                             selector:<span class="keyword">@selector</span>(volumeDidChange:)</div><div class="line">                                                 name:kSystemVolumeDidChangeNotification</div><div class="line">                                               object:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)volumeDidChange:(<span class="built_in">NSNotification</span> *)notification &#123;</div><div class="line">    <span class="built_in">NSString</span> *category = notification.userInfo[<span class="string">@"AVSystemController_AudioCategoryNotificationParameter"</span>];</div><div class="line">    <span class="built_in">NSString</span> *changeReason = notification.userInfo[<span class="string">@"AVSystemController_AudioVolumeChangeReasonNotificationParameter"</span>];</div><div class="line">    <span class="keyword">if</span> (![category isEqualToString:<span class="string">@"Audio/Video"</span>] || ![changeReason isEqualToString:<span class="string">@"ExplicitVolumeChange"</span>]) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">CGFloat</span> volume = [[notification userInfo][<span class="string">@"AVSystemController_AudioVolumeNotificationParameter"</span>] floatValue];</div><div class="line">    <span class="comment">// 显示自定义音量提示</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上两种方式各自优劣势都已经列出来了，上面说到的三个应用，<code>Instagram</code> 使用的是通知的方式，即刻和哔哩哔哩都是用 <code>KVO</code> 的方式。具体要选那种方式，就看具体需求了，如果在最大或最小时，调节音量可以接受不展示音量视图的话，个人推荐使用 <code>KVO</code> 的形式。</p>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>上面阐明了原理和实现方式，接下来就是接入到项目中真正使用了，接入项目后发现问题还不少。</p>
<h4 id="坑0x0001"><a href="#坑0x0001" class="headerlink" title="坑0x0001"></a>坑0x0001</h4><p>由于我们使用了 <code>window</code> 来显示自定义音量提示，所以 <code>window</code> 需要提前创建好，有一个需要注意的是 <code>UIWindow</code> 的 <code>hidden</code> 默认是 <code>YES</code>，由于上面说到系统的音量视图必须在可见视图层级内，所以创建的这个 <code>window</code> 必须要可见，然后尽量不影响交互，将其 <code>userInteractionEnabled</code> 置为 <code>NO</code>，且要让其不可见时层级最低，<code>windowLevel</code> 设置为 <code>UIWindowLevelNormal</code>。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.window = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen].bounds];</div><div class="line"><span class="keyword">self</span>.window.hidden = <span class="literal">NO</span>;</div><div class="line"><span class="keyword">self</span>.window.windowLevel = <span class="built_in">UIWindowLevelNormal</span> - <span class="number">1</span>;</div><div class="line"><span class="keyword">self</span>.window.rootViewController = [[<span class="built_in">UIViewController</span> alloc] init];</div><div class="line"><span class="keyword">self</span>.window.backgroundColor = [<span class="built_in">UIColor</span> clearColor];</div><div class="line"><span class="keyword">self</span>.window.userInteractionEnabled = <span class="literal">NO</span>;</div></pre></td></tr></table></figure>
<h4 id="坑0x0010"><a href="#坑0x0010" class="headerlink" title="坑0x0010"></a>坑0x0010</h4><p>这样一切看起来很正常，但是有一个问题就是有一些地方通过 <code>[[UIApplication sharedApplication].windows firstObject]</code> 来进行一些操作，比如展示 <code>toast</code> 或者收起键盘的 <code>UIControl</code>，所以会导致其不可见或者无法响应交互。<br>所以上面代码改成</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.window = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:<span class="built_in">CGRectZero</span>];</div><div class="line"><span class="keyword">self</span>.window.clipsToBounds = <span class="literal">YES</span>;</div><div class="line"><span class="keyword">self</span>.window.windowLevel = <span class="built_in">UIWindowLevelNormal</span>;</div></pre></td></tr></table></figure>
<p>嗯，运行起来，那些寻找 <code>firstObject</code> 的地方都正常了，但是…由于存在开屏广告，而且开屏广告用的也是 <code>window</code>，而且他会在自己要显示时，调用 <code>makeKeyAndVisible</code> 方法，消失的时候直接将其置为 <code>nil</code>，导致系统会自己寻找其它的 <code>window</code> 当做 <code>keyWindow</code>，这个时候不知道为什么会找到我们音量提示的 <code>window</code>？难道是因为 <code>[UIApplication sharedApplication].delegate.window</code> 层级是 <code>Normal</code>，音量提示 <code>window</code> 层级也是 <code>Normal</code>，然后会将后加入的  层级为 <code>Normal</code> 的 <code>window</code> 设置为 <code>key window</code>？暂时还不懂，有知道的大神麻烦指点一下。<br>这样看来，这种修改方式也不太行，会导致其它地方取 <code>keyWindow</code> 的时候，取错掉。</p>
<h4 id="坑0x0011"><a href="#坑0x0011" class="headerlink" title="坑0x0011"></a>坑0x0011</h4><p>嗯，那索性直接用 <code>[UIApplication sharedApplication].delegate.window</code> 这个来显示音量提示，最多也就出现 <code>Alert</code> 或键盘的时候，音量提示会被遮罩挡住，概率也比较小还好。于是改成下面代码</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.window = [<span class="built_in">UIApplication</span> sharedApplication].delegate.window;</div></pre></td></tr></table></figure>
<p>但是这个时候会发现，iPhoneX 下音量提示会被状态栏挡住，wtf！！！那么好吧，在音量显示的时候隐藏一下状态栏，音量消失的时候回复一下之前记住的状态栏状态，但是如果存在两个页面状态栏显隐不一致的情况，就会出现问题。同时在某些 <code>present</code> 起来的页面，音量提示死活不显示，但是用 <code>Xcode</code> 自带视图层级调试工具看，音量提示视图的 <code>frame</code>、<code>alpha</code>、<code>hidden</code> 属性都是正常的，但就是没有显示出来。后面将提示视图 <code>layer</code> 的 <code>zPosition</code> 提高之后，就可以显示出来了，真的很神奇。</p>
<p>一步步下来，填完一个坑，又来一个，感觉是个无底洞，永远填不满。搞了一晚上，一筹莫展。</p>
<h5 id="完美填坑"><a href="#完美填坑" class="headerlink" title="完美填坑"></a>完美填坑</h5><p>最后灵光一闪，如果自定义一个 <code>Window</code>，继承自 <code>UIWindow</code>，然后复写 <code>becomeKeyWindow</code> 方法，在这个方法里让自身不成为 <code>keyWindow</code> 同时将 <code>[UIApplication sharedApplication].delegate.window</code> 设置为 <code>keyWindow</code>，大致代码长这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">VolumeWindow</span> : <span class="title">UIWindow</span></span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">VolumeWindow</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)becomeKeyWindow &#123;</div><div class="line">    [<span class="keyword">self</span> resignKeyWindow];</div><div class="line">    [[<span class="built_in">UIApplication</span> sharedApplication].delegate.window makeKeyWindow];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h4 id="坑0x0100"><a href="#坑0x0100" class="headerlink" title="坑0x0100"></a>坑0x0100</h4><p>拍摄页拍摄之前系统音量提示是可以被替换的，但是拍摄一段之后，莫名其妙音量按钮按下后自定义提示不见了，出现了系统的铃声提示。一脸懵逼，后面发现是由于设置了 <code>AVCaptureSession</code> 的 <code>usesApplicationAudioSession</code> 为 <code>NO</code>，会导致在拍摄之后会变成铃声，这个和是否替换系统音量提示无关。这个属性是由于项目中很久之前需要兼容 <code>iOS6</code>，然后一直遗留着这个属性设置没有删除。由于 <code>iOS7</code> 之后，<code>AVCaptureSession</code> 和应用使用的是同一个 <code>AudioSession</code>，支持同时播放和录制且不会受到影响和打断，所以不需要再去设置这个属性。</p>
<h4 id="坑0x0101"><a href="#坑0x0101" class="headerlink" title="坑0x0101"></a>坑0x0101</h4><p>做了以上操作，在 iPhoneX 下，当拉起控制中心，并上下滑调整音量后，再回到应用，会发现自定义音量视图会出现在状态栏下面，猜测虽然在应用内自定义音量视图 <code>window</code> 层级高于状态栏 <code>window</code> 层级，但是由于状态栏是全局的，在重新进入到应用时会出现状态栏层级高于音量视图。所以就索性仅在应用为 <code>active</code> 的情况下才处理 <code>KVO</code>。</p>
<p>最后一个需要注意的点是在语音电话（或者其它使用系统音量的场景下）时，去自己应用内调节音量是无效，因为这个时候音量其实代表的是系统在占用，系统优先级高于应用，所以在这些场景下，即使在应用内调节音量，也无法触发出自己的音量视图。</p>
<p>然后上面所有问题都迎刃而解了。</p>
<p>最后推荐一个开源库：<a href="https://github.com/gizmosachin/VolumeBar" target="_blank" rel="external">VolumeBar</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信平时大家在用 iPhone 看视频调节音量时，总会被系统的音量提示所打扰，因为它会遮住一部分内容。所以很多视频应用都使用自定义音量视图的方式来替代系统的音量提示。&lt;/p&gt;
    
    </summary>
    
      <category term="Tips" scheme="https://vongloo.me/categories/Tips/"/>
    
    
      <category term="原创" scheme="https://vongloo.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>Pod 中资源引入方式对比</title>
    <link href="https://vongloo.me/2018/03/17/Pod-Resource/"/>
    <id>https://vongloo.me/2018/03/17/Pod-Resource/</id>
    <published>2018-03-17T05:18:38.000Z</published>
    <updated>2019-03-03T15:42:37.279Z</updated>
    
    <content type="html"><![CDATA[<p>写这篇博客起因是由于周四在知识小集发了一个 <a href="https://weibo.com/3129068073/G7rJx4Pag" target="_blank" rel="external">Tip</a>，讲 <code>Pod</code> 里面使用了 <code>.xcassets</code> 会导致 <code>Xcode 9</code> 打出来的包没有 <code>icon</code> 的解决方案。然后和 <a href="https://weibo.com/damonone" target="_blank" rel="external">@Damonwong</a> 展开了一下讨论。当然这条 Tip 讲得不全对，而且表达得不是很清晰，所以这里专门开一篇文章来讲一下那个 Tip 想要表达的意思，最后也会附上对应的 Demo。也当做之后要写的模块化系列的文章开篇吧。</p>
<a id="more"></a>
<p>首先我们先来给出结论：</p>
<ul>
<li><strong><code>podspec</code> 里面写资源时，最好用 <code>s.resource_bundle</code> 而不是 <code>s.resource</code></strong></li>
<li><strong>只有 <code>podspec</code> 使用 <code>resource</code> 且明确写了 <code>.xcassets</code> 的情况下才会导致 <code>Xcode 9</code> 打出来的包没有 <code>icon</code></strong></li>
</ul>
<blockquote>
<p>环境配置：Xcode 9.2 、Cocoapods 1.4.0<br>本文所涉及到的资源主要是指 <code>png</code> 格式的图片</p>
</blockquote>
<p>下面我们先来了解一下这两种方式的具体情况，以及各自的优劣势，最后通过一个 <code>Demo</code> 来验证我们上面给的结论。</p>
<h2 id="resource-和-resource-bundle"><a href="#resource-和-resource-bundle" class="headerlink" title="resource 和 resource_bundle"></a>resource 和 resource_bundle</h2><h3 id="resource"><a href="#resource" class="headerlink" title="resource"></a>resource</h3><p>通过<a href="https://guides.cocoapods.org/syntax/podspec.html#resources" target="_blank" rel="external">官方文档</a>描述</p>
<blockquote>
<p>A list of resources that should be copied into the target bundle.</p>
</blockquote>
<p>这种方式会引用的文件夹下的所有资源拷贝到 <code>target</code> 的 <code>bundle</code> 中去，可以简单的理解为 <code>.app</code> 目录下或者 <code>.app</code> 的 <code>Assets.car</code> 文件中（<strong>如果是 <code>.xcassets</code> 的资源</strong>）。</p>
<blockquote>
<p>Tips: 注意一下上面加粗的部分。</p>
</blockquote>
<p>这里抄一下官网上给的几个示例写法</p>
<blockquote>
<p>#单个路径<br>spec.resource = ‘Resources/HockeySDK.bundle’<br>#多个路径<br>spec.resources = [‘Images/*.png’, ‘Sounds/*‘]</p>
</blockquote>
<h3 id="resource-bundle"><a href="#resource-bundle" class="headerlink" title="resource_bundle"></a>resource_bundle</h3><p>还是一样，我们来看一下 <code>Cocoapods</code> <a href="https://guides.cocoapods.org/syntax/podspec.html#resource_bundles" target="_blank" rel="external">官方文档</a>上的描述</p>
<blockquote>
<p>This attribute allows to define the name and the file of the resource bundles which should be built for the Pod. They are specified as a hash where the keys represent the name of the bundles and the values the file patterns that they should include.</p>
</blockquote>
<p>这种方式可以将指定路径下的资源打包打 <code>=&gt;</code> 之前的 <code>key</code> 命名的 bundle 中，这个 <code>bundle</code> 最终会被拷贝到 <code>target</code> 也就是 <code>.app</code> 根目录下。<strong>如果有指定 <code>.xcassets</code> 资源，会被打包到以 <code>key</code> 命名的 <code>bundle</code> 里的 <code>Assets.car</code> 文件中。</strong></p>
<blockquote>
<p>Tips: 注意一下上面加粗的部分。</p>
</blockquote>
<p>官方示例写法</p>
<blockquote>
<p>#单个路径<br>spec.ios.resource_bundle = { ‘MapBox’ =&gt; ‘MapView/Map/Resources/*.png’ }<br>#多个路径，生成多个 bundle<br>spec.resource_bundles = {<br>    ‘MapBox’ =&gt; [‘MapView/Map/Resources/*.png’],<br>    ‘OtherResources’ =&gt; [‘MapView/Map/OtherResources/*.png’]<br>  }</p>
</blockquote>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>其实上面官网上的描述我故意漏附了后面的几段话，文档上在两种方式下都<strong>强烈(strongly)</strong>推荐使用 <code>resource_bundle</code> 的方式。</p>
<blockquote>
<p><strong>resource</strong> 下的描述<br>We <strong>strongly</strong> recommend library developers to adopt resource bundles as there can be name collisions using the resources attribute. Moreover, resources specified with this attribute are copied directly to the client target and therefore they are not optimised by Xcode.</p>
<p><strong>resource_bundle</strong> 下的描述<br>We <strong>strongly</strong> recommend library developers to adopt resource bundles as there can be name collisions using the resources attribute.<br>The names of the bundles should at least include the name of the Pod to minimise the chance of name collisions.</p>
</blockquote>
<p>综合上述所说，就是使用 resource_bundle 主要有以下两点好处：</p>
<ul>
<li>避免命名冲突（<code>bundle</code> 命名时最好包含 Pod 的名字来尽可能避免掉命名冲突）</li>
<li>Xcode 会对资源做优化，比如 <code>.xcassets</code> 里的图片压缩、Slicing、以及 @2x/@3x 图片资源分离</li>
</ul>
<p>我们来对比下两种方式下最终打包出来的应用目录结构：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方式</th>
<th style="text-align:center">生成的 <code>.app</code> 目录</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="http://img.cdn.punmy.cn/15213450850565.jpg" alt=""></td>
<td style="text-align:center"><img src="http://img.cdn.punmy.cn/15213516588016.jpg" alt=""></td>
</tr>
<tr>
<td style="text-align:center"><img src="http://img.cdn.punmy.cn/15213484478130.jpg" alt=""></td>
<td style="text-align:center"><img src="http://img.cdn.punmy.cn/15213515637040.jpg" alt=""></td>
</tr>
</tbody>
</table>
<p>可以看出 <code>resource_bundle</code> 的形式会生成对应的 <code>bundle</code>(上图中的 <code>Pod1.bundle</code>)，并且 <code>.xcassets</code> 最终会被打包到对应 <code>bundle</code> 下的 <code>Assets.car</code> 文件下（该文件可用这个工具打开：<a href="https://github.com/devcxm/iOS-Images-Extractor" target="_blank" rel="external">iOS-Images-Extractor</a>）。<br>而 <code>resource</code> 的形式，会把 <code>.xcassets</code> 打包到应用根目录下的 <code>Assets.car</code> 中。</p>
<p>而要读取对应的图片时，<code>resource</code> 对应的代码长下面这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"your-image-name"</span></div><div class="line">                            inBundle:[<span class="built_in">NSBundle</span> bundleForClass:[<span class="keyword">self</span> <span class="keyword">class</span>]]</div><div class="line">       compatibleWithTraitCollection:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<p>而 <code>resource_bundle</code> 对应的读取代码如下面所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSBundle</span> *bundle = [<span class="built_in">NSBundle</span> bundleForClass:[<span class="keyword">self</span> <span class="keyword">class</span>]];</div><div class="line"><span class="built_in">NSURL</span> *url = [bundle URLForResource:<span class="string">@"your-bundle-name"</span> withExtension:<span class="string">@"bundle"</span>];</div><div class="line"><span class="built_in">NSBundle</span> *targetBundle = [<span class="built_in">NSBundle</span> bundleWithURL:url];</div><div class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"your-image-name"</span></div><div class="line">                            inBundle:targetBundle</div><div class="line">       compatibleWithTraitCollection:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<p>通过以上两个代码片段，相信各位已经知道代码片段1、2都可能存在图片命名冲突的问题，但是一般情况下片段2的冲突概率远小于片段1的。因为一般情况下，模块内的图片命名肯定是不会冲突的，而模块间的图片的命名就不好说了。当然如果团队里有明确的命名规范，片段1和片段2都不会有问题。<br>虽然片段2代码较片段1稍复杂一些，但是如果我们将其封装成一个 <code>NSBundle</code> 的分类，就免去了冗长的写法，对于 <code>Storyboard/Xib</code> 同样适用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 具体代码可以在 Demo 中找到</span></div><div class="line"><span class="comment">//.h</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSBundle</span> (<span class="title">Pod1Bundle</span>)</span></div><div class="line"></div><div class="line">+ (<span class="built_in">NSBundle</span> *)pod1_bundle;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//.m</span></div><div class="line"><span class="comment">// FakeClass 仅作占位符用，即只为分类中的 `bundleForClass:` 方法服务</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Pod1FakeClass</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Pod1FakeClass</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSBundle</span> (<span class="title">Pod1Bundle</span>)</span></div><div class="line"></div><div class="line">+ (<span class="built_in">NSBundle</span> *)pod1_bundle &#123;</div><div class="line">    <span class="built_in">NSBundle</span> *bundle = [<span class="keyword">self</span> bundleForClass:[Pod1FakeClass <span class="keyword">class</span>]];</div><div class="line">    <span class="built_in">NSURL</span> *url = [bundle URLForResource:<span class="string">@"Pod1"</span> withExtension:<span class="string">@"bundle"</span>];</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> bundleWithURL:url];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// 片段2可以简写为：</span></div><div class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"your-image-name"</span></div><div class="line">                            inBundle:[<span class="built_in">NSBundle</span> pod1_bundle]</div><div class="line">       compatibleWithTraitCollection:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a><a href="https://github.com/wang9262/PodResourceDemo" target="_blank" rel="external">Demo</a></h2><p>第一个 <a href="https://github.com/wang9262/PodResourceDemo/commit/c397c6d15ee1f54e99d333ad9e85a6600fdf34bf" target="_blank" rel="external"><code>commit</code></a> 写好了两个 <code>podspec</code>，一个用 <code>resource_bundle</code>(Pod1)，一个用 <code>resource</code>(Pod2)，然后都引用 <code>.xassets</code> 资源，里面都有一个名为<code>Pod</code>的图片，主工程也有。区别在于 <code>Pod</code> 中的图片顶部会有该 <code>Pod</code> 名称的水印。然后页面上有3个 <code>ImageView</code>，目前只设置了中间那个 <code>ImageView</code> 的图片为主工程的图片。运行起来，一切表现正常，展示出来的图片也确实是主工程的图片。</p>
<p>第二个 <a href="https://github.com/wang9262/PodResourceDemo/commit/f2f7cfc979e13fc42e4dc2dd51631c4ce94e9861" target="_blank" rel="external"><code>commit</code></a> 在主工程内分别读取 <code>Pod1</code> 和 <code>Pod2</code> 的名为 <code>Pod</code> 的图片，然后分别塞到上下两个 <code>ImageView</code> 中，运行起来，最下面那个 <code>ImageView</code> 的图片变成主工程的图片了，而最上面的 <code>ImageView</code> 的图片是正常的！！！这就是我们上面说到的那个问题，由于 <code>Pod2</code> 使用 <code>resource</code> 的方式，<code>.xcassets</code> 中图片是直接和主工程的 <code>.xcassets</code> 中图片一样是打包到 <code>.app</code> 根目录下的 <code>Assets.car</code> 中，命名一致，导致被主工程的图片给覆盖掉了（可以使用上面说到的解压工具解压，查看根目录 <code>.car</code> 下的文件内容，只有主工程的图片）。</p>
<p>第三个 <a href="https://github.com/wang9262/PodResourceDemo/commit/c6a1c9bd15dd24e1ef165edce948989306df6ad9" target="_blank" rel="external"><code>commit</code></a> 及 <a href="https://github.com/wang9262/PodResourceDemo/tree/ruby-shell" target="_blank" rel="external"><code>ruby-shell</code></a> 分支主要解决应用 icon 为空的问题。当我们 Home 键回到桌面时，回发现 Demo 的 icon 是空的，但是我们是有设置 icon 的。所以我们有两种解决方案来解决这个问题。</p>
<h3 id="方案一：不使用-xcassets"><a href="#方案一：不使用-xcassets" class="headerlink" title="方案一：不使用 .xcassets"></a>方案一：不使用 <code>.xcassets</code></h3><p>把图片放到 <code>Pod2</code> 目录下，不再放到 <code>.xcassets</code> 里面，然后 <code>podspec</code> 里的写法改成：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s.resources = [<span class="string">'Pod2/**/*.png'</span>]</div></pre></td></tr></table></figure>
<p><code>pod install</code> 之后再跑一下，发现 <code>icon</code> 回来了，但是图片还是被主工程覆盖了，查看 <code>.app</code> 文件，我们发现根目录下多了两张图片，他们来自于 <code>Pod2</code> 目录下。</p>
<p><img src="http://img.cdn.punmy.cn/15213565093908.jpg" alt=""></p>
<p>相应的我们的读取代码就需要改成下面这种形式，还需要区分 <code>@2x</code> 和 <code>@3x</code>，非常麻烦，但是这个时候确实能读到对应的图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// @2x 读取</div><div class="line">_podImage = [UIImage imageNamed:@&quot;Pod@2x&quot;</div><div class="line">                       inBundle:[NSBundle bundleForClass:[self class]]</div><div class="line">  compatibleWithTraitCollection:nil];</div><div class="line">// @3x</div><div class="line">_podImage = [UIImage imageNamed:@&quot;Pod@3x&quot;</div><div class="line">                       inBundle:[NSBundle bundleForClass:[self class]]</div><div class="line">  compatibleWithTraitCollection:nil];</div></pre></td></tr></table></figure>
<h3 id="方案二：脚本"><a href="#方案二：脚本" class="headerlink" title="方案二：脚本"></a>方案二：脚本</h3><p>在 podfile 中加入下面这一段脚本</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">post_install <span class="keyword">do</span> <span class="params">|installer|</span></div><div class="line">copy_pods_resources_path = <span class="string">"Pods/Target Support Files/Pods-ResourceDemo_Example/Pods-ResourceDemo_Example-resources.sh"</span></div><div class="line">string_to_replace = <span class="string">'--compile "$&#123;BUILT_PRODUCTS_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;"'</span></div><div class="line">assets_compile_with_app_icon_arguments = <span class="string">'--compile "$&#123;BUILT_PRODUCTS_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;" --app-icon "$&#123;ASSETCATALOG_COMPILER_APPICON_NAME&#125;" --output-partial-info-plist "$&#123;BUILD_DIR&#125;/assetcatalog_generated_info.plist"'</span></div><div class="line">text = File.read(copy_pods_resources_path)</div><div class="line">new_contents = text.gsub(string_to_replace, assets_compile_with_app_icon_arguments)</div><div class="line">File.open(copy_pods_resources_path, <span class="string">"w"</span>) &#123;<span class="params">|file|</span> file.puts new_contents &#125;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>然后 <code>pod install</code> 之后，运行即可。</p>
<blockquote>
<p>以上两种方式执行之前最好 <code>clean</code> 一下，防止 <code>Xcode</code> 缓存，导致以上方法执行后也会出现 <code>icon</code> 消失的情况。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综合以上，我们再总结一下 <code>resource_bundle</code> 的优势：</p>
<ul>
<li>绝大多数(99.999%)情况下不会有资源命名冲突问题</li>
<li>如果图片资源放到 <code>.xcasset</code> 里面 <code>Xcode</code> 会帮我们自动优化、可以使用 Slicing 等（这里不仅仅指的是 <code>resource_bundle</code> 下的 <code>xcassets</code>，只不过 <code>s.resource</code> 中如果引用会导致 <code>icon</code> 消失的问题）。</li>
</ul>
<p>至于劣势，我觉得根本就没有，上面那个硬编码问题，完全可以通过我说的分类或者你自定义宏的方式把这个硬编码问题 Cover 掉。</p>
<p>如果认为文章中的观点或结论有问题，欢迎指出，一起沟通探讨。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote>
<p><a href="https://github.com/CocoaPods/CocoaPods/issues/7003" target="_blank" rel="external">App Icons not included in build from Xcode 9</a><br><a href="http://zhoulingyu.com/2018/02/02/pod-resource-reference/" target="_blank" rel="external">关于 Pod 库的资源引用 resource_bundles or resources</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写这篇博客起因是由于周四在知识小集发了一个 &lt;a href=&quot;https://weibo.com/3129068073/G7rJx4Pag&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Tip&lt;/a&gt;，讲 &lt;code&gt;Pod&lt;/code&gt; 里面使用了 &lt;code&gt;.xcassets&lt;/code&gt; 会导致 &lt;code&gt;Xcode 9&lt;/code&gt; 打出来的包没有 &lt;code&gt;icon&lt;/code&gt; 的解决方案。然后和 &lt;a href=&quot;https://weibo.com/damonone&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@Damonwong&lt;/a&gt; 展开了一下讨论。当然这条 Tip 讲得不全对，而且表达得不是很清晰，所以这里专门开一篇文章来讲一下那个 Tip 想要表达的意思，最后也会附上对应的 Demo。也当做之后要写的模块化系列的文章开篇吧。&lt;/p&gt;
    
    </summary>
    
      <category term="模块化" scheme="https://vongloo.me/categories/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
    
      <category term="原创" scheme="https://vongloo.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="Xcode" scheme="https://vongloo.me/tags/Xcode/"/>
    
      <category term="Pod" scheme="https://vongloo.me/tags/Pod/"/>
    
  </entry>
  
  <entry>
    <title>亦无岁月可回头</title>
    <link href="https://vongloo.me/2018/02/16/2017-Summary/"/>
    <id>https://vongloo.me/2018/02/16/2017-Summary/</id>
    <published>2018-02-15T16:13:46.000Z</published>
    <updated>2019-03-03T15:42:37.279Z</updated>
    
    <content type="html"><![CDATA[<p>2018 即将来到(哈哈哈哈哈哈，我说的是农历年)，这篇文章纯当一篇水文，做个2017的年终总结。</p>
<a id="more"></a>
<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p><img src="http://img.cdn.punmy.cn/15187013079738.jpg" alt=""></p>
<p>来美图工作已经快4年了（算上实习的话），从一个 CollectionView 都不会用的人，到现在慢慢得能够比较轻松应对现在的工作。</p>
<p>去年工作上最有成就感的两件事情：</p>
<ul>
<li>在业界的几种模块化方式上结合美拍实际情况进行了简单的实践。年后写篇文章分享一下这个过程和思路。</li>
<li>配合架构同学让美拍直播实现了真正的秒开。</li>
</ul>
<blockquote>
<p>讲真陌陌直播秒开真的很牛逼，现在美拍也能达到这个水平了！</p>
</blockquote>
<p>年中的时候，买了几本书，目前只看了其中三本，年后再继续吧。<br>12月的时候美拍开始996，说真的有点累，每天晚上10点多到家，洗完澡差不多到睡觉时间，希望年后不要再继续了😂还是比较怀念之前有双休的日子。<br>对于学习的方式也发生了一点变化，以前总是想着要学很多，列了很多待学习项，但是最后都是不了了之，现在慢慢开始往某一个方向去深入了解，其他的做个基本了解就 ok。</p>
<h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>随着毕业季到来，和公司的两个小鲜肉合租，周末偶尔自己做做饭，刚开始兴趣比较大，后面由于996，基本上也就没怎么用过厨房了。<br>今年夏天在小鲜肉们的带领下，学会了一项求生技能—-游泳。现在还不会换气，一口气只能游10m，姿势是狗刨试。<br>基本上每个月至少会和他们一起看一部电影，烂片除外。<br>国庆和小伙伴们去了一趟台湾，本来去年就计划好的，但是又去通行证时间来不及坑了熊哥，所以原计划就推到了今年。台湾旅程感觉最有意思的地方非绿岛莫属了，环岛骑了半天机车，傍晚时分一起去潜水。第一次比较紧张，到十几米水下的时候感觉不舒服，然后手脚错乱，还好教练在身边，马上浮了上来，差点 GG。后面再下去就比较顺利了，如果后面有机会，值得再去一次。</p>
<h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><p>周末一般会和同学玩一玩英雄联盟，S7世界赛和同事们在家里一起投屏看比赛，只是很可惜零封 SSG 的 RNG 没有赢下对 SKT 的比赛。当然 EDG 是被喷的最惨的，不过 iBoy 这个小朋友很皮，S8可以期待一下。</p>
<p>996之后英雄联盟就玩的比较少了，一般就中午的时候吃一吃鸡。</p>
<p>不过不管玩什么游戏，都很菜，而且有时候反应很慢，可能不是玩游戏的料，纯属娱乐😂。哈哈哈哈哈，只能用这个来安慰自己了，感谢队友的不杀之恩！！！</p>
<h3 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h3><h4 id="技术方面"><a href="#技术方面" class="headerlink" title="技术方面"></a>技术方面</h4><ul>
<li><strong>初识逆向</strong> 发现逆向还是蛮好玩的，但是基础知识不够，还没有深入玩下去，只是做了个简单的了解。改善了一下平时写正向代码的思路。</li>
<li><strong>RAC 实践</strong> 之前组内同事一直在推广，但是自己没有真正实践过，都是停留在他的分享上。今年接手美拍直播这一块之后，慢慢开始使用，很多值得注意的地方，也踩了一些坑，目前只是算对 RAC 有一个基本的了解，以及初步实践，后面还需要继续实践，以及完整读一遍源码。</li>
</ul>
<h4 id="生活方面"><a href="#生活方面" class="headerlink" title="生活方面"></a>生活方面</h4><ul>
<li><strong>做菜</strong> 上面说到合租后有自己做过一段时间饭，有照着食谱做，也有回忆着老爸做菜时候的一些操作和步骤。从难吃到慢慢变成勉强能吃，到后面每次大家都能把菜吃光，也算是一种进步了吧。</li>
<li><strong>游泳</strong> 之前对游泳是抗拒的，主要是不会游，觉得去了很尴尬，后面看了几集视频教程以及实践，开始学会了一丁点，能有一点点距离了，但还是不会换气。</li>
</ul>
<h3 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h3><p>躺在床上，敲着这些流水账，听着外面鞭炮声，这真的是一篇写了“一年”的文章。</p>
<p>2017已经过去，希望2018自己能够继续成长。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018 即将来到(哈哈哈哈哈哈，我说的是农历年)，这篇文章纯当一篇水文，做个2017的年终总结。&lt;/p&gt;
    
    </summary>
    
      <category term="扯淡集" scheme="https://vongloo.me/categories/%E6%89%AF%E6%B7%A1%E9%9B%86/"/>
    
    
      <category term="杂谈" scheme="https://vongloo.me/tags/%E6%9D%82%E8%B0%88/"/>
    
      <category term="原创" scheme="https://vongloo.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>Modern Objective-C</title>
    <link href="https://vongloo.me/2017/04/21/Modern-Objective-C/"/>
    <id>https://vongloo.me/2017/04/21/Modern-Objective-C/</id>
    <published>2017-04-21T12:51:41.000Z</published>
    <updated>2019-03-03T15:42:37.279Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍一些 Objective-C 的一些新特性。<br><a id="more"></a></p>
<h3 id="从一个-Bug-来说说-Objective-C-中的指定构造器"><a href="#从一个-Bug-来说说-Objective-C-中的指定构造器" class="headerlink" title="从一个 Bug 来说说 Objective-C 中的指定构造器"></a>从一个 Bug 来说说 Objective-C 中的指定构造器</h3><p>某天测试反馈，iOS8 点击按钮时弹出一个列表视图出现必现崩溃，看了下崩溃日志，是野指针导致导出乱崩，具体是 <code>[xxx collectionView:numberOfItemsInSection:] unrecognized selector send to instance xxxxx</code>。<br>连上设备调试，发现 <code>setupDataSource</code> 走了两次，由于调用栈非常类似，一开始没注意它调了两次，一直没找到问题所在。后面各种断点上去，发现 <code>setupDataSource</code> 方法被调用了两次，进一步 <code>commonInit</code> 被调用了两次。最后查看初始化代码，才发现调用 <code>convenience init method</code> 时，没有调 <code>designed init method</code>，并且调完之后又再调了一次 <code>commonInit</code>。具体看下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PanelView</span>()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UICollectionView</span> *collectionView;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> initWithCoder:aDecoder]) &#123;</div><div class="line">        [<span class="keyword">self</span> commonInit];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame]) &#123;</div><div class="line">        [<span class="keyword">self</span> commonInit];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initWithType:(PanelType)type &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</div><div class="line">        [<span class="keyword">self</span> commonInit];</div><div class="line">        <span class="keyword">self</span>.type = type;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)commonInit &#123;</div><div class="line">    <span class="keyword">self</span>.colletionView = ...</div><div class="line">    [<span class="keyword">self</span> addSubview:<span class="keyword">self</span>.colletionView];</div><div class="line">    [<span class="keyword">self</span> setupDataSource];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)setupDataSource &#123;</div><div class="line">    DataSource *dataSource = [[DataSource alloc] initWithCollectionView:<span class="keyword">self</span>.collectionView];</div><div class="line">    dataSource.delegate = <span class="keyword">self</span>;</div><div class="line">    <span class="keyword">self</span>.collectionView.dataSource = dataSource;</div><div class="line">    <span class="keyword">self</span>.dataSource = dataSource;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 外面使用 initWithType: 做了初始化</span></div></pre></td></tr></table></figure>
<p>由于调了两次 <code>commonInit</code>，导致创建了两个 <code>collectionView</code> 和 <code>dataSource</code>，由于第一次创建的 <code>dataSource</code> 没有持有者，被释放为 <code>nil</code>，而第一次创建的 <code>collectionView</code> 被加到视图层级当中被 <code>self</code> 持有，所以在第一个 <code>collectionView</code> 在执行调用数据源方法时，<code>dataSource</code> 为 <code>nil</code>，但是在 iOS9 之前 <code>UICollectionView</code> 和 <code>UITableView</code> 的 <code>delegate</code> 和 <code>dataSource</code> 属性用 <code>assign</code> 而非 <code>weak</code> 修饰，导致这一块内存被污染，继续调用时会出现野指针崩溃。</p>
<p>归根结底，就是初始化的姿势不对。</p>
<p>正确的姿势应该是：</p>
<ol>
<li>子类指定构造器必须调用父类指定构造器</li>
<li>便捷构造器只能通过调用自身指定构造器来完成初始化</li>
<li>指定构造器必须要用 <code>NS_DESIGNATED_INITIALIZER</code> 标示</li>
</ol>
<p>可参考下图</p>
<p><img src="http://img.cdn.punmy.cn/14912017895530.jpg" alt=""></p>
<blockquote>
<p>图片出自 《The Swift Programming Language (Swift 3.0.1)》 Initialization - Syntax for Designated and Convenience Initializers 小节</p>
</blockquote>
<p>关于指定构造器，iOS 自身内部实现也有一个 bug <a href="http://www.openradar.me/23709930" target="_blank" rel="external">UITableViewController subclass designated initializer Crash</a>、<a href="http://stackoverflow.com/questions/25139494/how-to-subclass-uitableviewcontroller-in-swift" target="_blank" rel="external">How to subclass UITableViewController in Swift</a>。iOS8 下自定义一个 <code>UIViewController</code> 继承自 <code>UITableViewController</code>，然后自定义指定构造器，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 指定构造器</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithTitle:(<span class="built_in">NSString</span> *)title &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> initWithStyle:<span class="built_in">UITableViewStyleGrouped</span>]) &#123;</div><div class="line">        <span class="comment">//....</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initWithNibName:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)nibNameOrNil bundle:(<span class="keyword">nullable</span> <span class="built_in">NSBundle</span> *)nibBundleOrNil &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithTitle:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initWithStyle:(<span class="built_in">UITableViewStyle</span>)style &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithTitle:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 外面调用，iOS8 下调用此段代码，必崩</span></div><div class="line"><span class="comment">// 所以 iOS8 最好不要继承自 UITableViewController</span></div><div class="line">TestViewController *vc = [[TestViewController alloc] initWithTitle:<span class="string">@"Hello"</span>];</div></pre></td></tr></table></figure>
<h4 id="几个小问题"><a href="#几个小问题" class="headerlink" title="几个小问题"></a>几个小问题</h4><ul>
<li><strong>Question 1</strong>: <code>instancetype</code> 和 <code>id</code> 两者有什么区别？</li>
</ul>
<blockquote>
<p><code>instancetype</code> 能够做到类型检测而 <code>id</code> 不行。前者仅可做方法返回值，不能作为参数，见示例代码<br>比如如下代码：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestObjectA</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">id</span>)createObjectA;</div><div class="line">- (<span class="keyword">void</span>)methodA;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestObjectB</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">instancetype</span>)createObjectB;</div><div class="line">- (<span class="keyword">void</span>)methodB;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">[[TestObjectA createObjectA] methodB];      <span class="comment">// no compile error or warning but crash</span></div><div class="line">[[TestObjectB createObjectB] methodA];      <span class="comment">// compile error --&gt; No visible @interface for 'TestObjectB' declares the selector 'methodA'</span></div></pre></td></tr></table></figure>
<p>延伸问题：为什么<code>(id)initWithXXX:</code> 也可以做到类型检测？</p>
<blockquote>
<p>类方法只要以 <code>alloc</code>、<code>new</code> 开头就会有关联返回类型（即类型检测）<br>实例方法只要以 <code>init</code>、<code>autorelease</code>、<code>retain</code>、<code>self</code> 开头就会有关联返回类型<br><a href="https://clang.llvm.org/docs/LanguageExtensions.html#objective-c-features" target="_blank" rel="external">Clang Language Extensions–Objective-C Features</a><br><strong>Note</strong>: ARC 下实测，实例方法只有 <code>init</code> 开头的才有关联返回类型。</p>
</blockquote>
<ul>
<li><strong>Question 2</strong>: 新建一个VC 文件同时勾选 <code>Also create XIB file</code> 后，初始化 <code>VC *vc = [[VC alloc] init]</code> 得到的是否和 <code>initWithNibName:bundle:</code> 初始化得到的 UI 一致？为什么？</li>
</ul>
<blockquote>
<p>是一致的，因为最终都会调到指定构造器 <code>initWithNibName:bundle:</code>，但此时 <code>nibName</code> 为 <code>nil</code>，关于 <code>nibName</code> 的相关设置文档是这么说的<br>However, if you do not specify a nib name, and do not override the loadView method in your custom subclass, the view controller searches for a nib file using other means. Specifically, it looks for a nib file with an appropriate name (without the .nib extension) and loads that nib file whenever its view is requested. Specifically, it looks (in order) for a nib file with one of the following names:<br>If the view controller class name ends with the word ‘Controller’, as in MyViewController, it looks for a nib file whose name matches the class name without the word ‘Controller’, as in MyView.nib.<br>It looks for a nib file whose name matches the name of the view controller class. For example, if the class name is MyViewController, it looks for a MyViewController.nib file.</p>
<p>简单来说，如果没设置该属性也没有复写 <code>loadView</code> 方法，则系统有一套自己的寻找机制来看是否有对应的 xib 文件，如果有，则加载 xib 文件。</p>
</blockquote>
<ul>
<li><strong>Question 3</strong>: 如下代码输出的是什么？为什么？ 选自 <a href="http://blog.sunnyxx.com/2014/11/06/runtime-nuts/" target="_blank" rel="external">神经病院objc runtime入院考试</a></li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestSubclass</span> : <span class="title">TestSuperclass</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestSubclass</span></span></div><div class="line">- (<span class="keyword">instancetype</span>)init &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]));</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">super</span> <span class="keyword">class</span>]));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<blockquote>
<p>输出的都是 <code>TestSubclass</code>，因为两者的 receiver 都是 self。当我们给 super 发消息的时候，实际上是给 self 发消息，只不过在查找方法列表时会自动跳过当前类的方法列表，而从父类方法列表中开始查找。归根结底，最后产生的消息是 <code>objc_msgSendSuper(self, @selector(init));</code>。</p>
</blockquote>
<ul>
<li><strong>Question 4</strong>: 为什么我们初始化方法的写法都长这样？</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SomeClass</span> : <span class="title">TestSuperClass</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span></span></div><div class="line">- (<span class="keyword">instancetype</span>)init </div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line">SomeClass *aInstance = [[SomeClass alloc] init];</div></pre></td></tr></table></figure>
<blockquote>
<p>我们可以将上面代码拆成以下几个步骤：</p>
<ol>
<li><code>[SomeClass alloc]</code> 返回一个 <code>SomeClass</code> 的实例</li>
<li>紧接着给 <strong>步骤1</strong> 生成的实例发 <code>init</code> 消息，所以 <strong>init</strong> 方法中的 self 为 <strong>步骤1</strong> 生成的实例</li>
<li><code>[super init]</code> 实际上调用的是父类的初始化方法，在父类的方法中，<strong>self</strong> 依然是 <strong>步骤1</strong> 生成的实例，<strong>对于这一点的理解很重要</strong></li>
<li>父类的 <code>init</code> 方法要么做一些基本的初始化工作，要么修改 self，然后返回一个新的实例</li>
<li>回到 SomeClass 的<code>init</code>方法中来，此时得到的要么是 <strong>步骤1</strong> 生成的实例，要么是新生成的实例。这就是为什么我们要加 if 判断的原因。</li>
</ol>
</blockquote>
<h3 id="新增关键字及特性"><a href="#新增关键字及特性" class="headerlink" title="新增关键字及特性"></a>新增关键字及特性</h3><h4 id="Nullability"><a href="#Nullability" class="headerlink" title="Nullability"></a>Nullability</h4><p><code>nonnull/_Nonnull</code> 表达的意思是一样的，<code>nullable/_Nullable</code> 同理，只是修饰符的位置不同<br><code>_Nonnull</code> 和 <code>_Nullable</code> 的位置和 C语言的 <code>const</code> 关键字位置一致。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 写法1和2 表达的意思完全一致</span></div><div class="line"><span class="comment">// 写法1</span></div><div class="line">- (AAPLListItem * _Nullable)itemWithName:(<span class="built_in">NSString</span> * _Nonnull)name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span> * _Nonnull allItems;</div><div class="line"><span class="comment">// 写法2</span></div><div class="line">- (<span class="keyword">nullable</span> AAPLListItem *)itemWithName:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">readonly</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSArray</span> *allItems;</div></pre></td></tr></table></figure>
<p>几个特例：</p>
<ul>
<li><code>typedef</code> 类型由于可以从上下文中推断出它是空（nullable）或非空（nonnull），所以内部不需要写 <code>nullable</code> 或 <code>nonnull</code>。</li>
<li>复杂指针必须显式声明其是否可为空，比如指定一个指向非空对象的可空指针可声明为 <code>_Nullable id * _Nonnull</code></li>
<li><code>NSError **</code> 类型通常为一个指向可空对象的可空指针。</li>
</ul>
<p>为了避免重复写 <code>nonnull</code>，有一对宏 <code>NS_ASSUME_NONNULL_BEGIN</code> 和 <code>NS_ASSUME_NONNULL_END</code>，被这两个宏包裹的代码，默认都是 <code>nonnull</code>，如果可为空，则需显式声明为 <code>nullable</code> 或者 <code>_Nullable</code>。</p>
<p><code>null_resettable</code>: 可被置 nil，但是调用 getter 时又会重新创建，可参考 <code>UIViewController</code> 的 <code>view</code> 属性 或者 <code>UIView</code> 的 <code>tintColor</code> 属性。</p>
<p>更多关于 Nullability 可参考：</p>
<blockquote>
<p><a href="https://developer.apple.com/swift/blog/?id=25" target="_blank" rel="external">Nullability and Objective-C</a><br><a href="http://stackoverflow.com/questions/32452889/difference-between-nullable-nullable-and-nullable-in-objective-c" target="_blank" rel="external">Difference between nullable, __nullable and _Nullable in Objective-C</a></p>
</blockquote>
<h4 id="kindof"><a href="#kindof" class="headerlink" title="__kindof"></a>__kindof</h4><p>该关键字的出现可以很好的避免做强转，比如 <code>UIView</code>、<code>UITableView</code> 的如下方法/属性</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// UIView.h</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;__kindof <span class="built_in">UIView</span> *&gt; *subviews;</div><div class="line">- (<span class="keyword">nullable</span> __kindof <span class="built_in">UIView</span> *)viewWithTag:(<span class="built_in">NSInteger</span>)tag;</div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">// UITableView.h</span></div><div class="line">- (<span class="keyword">nullable</span> __kindof <span class="built_in">UITableViewCell</span> *)cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;__kindof <span class="built_in">UITableViewCell</span> *&gt; *visibleCells;</div><div class="line"></div><div class="line"><span class="comment">// 无警告，不需要做强转</span></div><div class="line"><span class="built_in">UIlabel</span> *textLabel = view.subviews.firstObject; </div><div class="line">CustomCell *cell = <span class="keyword">self</span>.tableView.visibleCells.lastObject;</div></pre></td></tr></table></figure>
<h4 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h4><p>为了更好的桥接 Swift，Objective-C 新增了轻量级的泛型支持，之所以是轻量级泛型，是因为它只是编译时的泛型。目前 Swift 仅支持 NSArray,、NSDictionary、NSSet 这 3 个类的泛型桥接，其它类(含自定义)，不支持。<br><a href="https://useyourloaf.com/blog/using-objective-c-lightweight-generics/" target="_blank" rel="external">Using Objective-C Lightweight Generics</a></p>
<h5 id="covariant"><a href="#covariant" class="headerlink" title="__covariant"></a>__covariant</h5><p>子类可赋给父类</p>
<h5 id="contravariant"><a href="#contravariant" class="headerlink" title="__contravariant"></a>__contravariant</h5><p>父类可赋给子类，目前没有想到适用的场景，<code>__kindof</code> 和这个有点类似，但是又不一样，<code>__kindof</code> 可直接修饰属性。<br>比如 <code>@property (nullable, nonatomic, strong) __kindof NSObject *object;</code></p>
<p>协变和逆变的具体区别可参考，sunnyxx 的博客<a href="http://blog.sunnyxx.com/2015/06/12/objc-new-features-in-2015/" target="_blank" rel="external">2015 Objective-C 新特性</a></p>
<h3 id="attributes-命令"><a href="#attributes-命令" class="headerlink" title="__attributes__ 命令"></a>__attributes__ 命令</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><code>__attribute__</code> 命令是用来修饰 C/C++/Objective-C 中的代码片段，让它们拥有额外的属性，进而使编译器做出对应的优化或者为代码调用者提供有用的上下文（警告或提示）。进一步来讲，就是 <code>__attributes__</code> 命令为我们提供了阅读代码的上下文，便于编译器提前做出优化，达到事半功倍的效果。</p>
<h4 id="什么时候用"><a href="#什么时候用" class="headerlink" title="什么时候用"></a>什么时候用</h4><p>Twitter 官方博客是推荐，能用且可以提供额外上下文的地方就尽量用。这样不仅可以让编译器做优化，同时可以让其他阅读代码的人（包括你自己）受益匪浅。当你想用却又在犹豫该不该用时，就不要用了。</p>
<h4 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h4><p>虽然上面说到在能够使用的地方尽量使用，但是也不能乱用、滥用。具体例子可以参考下面提到的 Twitter 官方博客。</p>
<p>最开始接触 <code>__attribute__</code> 命令是在 <code>PSPDFUIKitMainThreadGuard.m</code>，第一次看到这个的时候一脸懵逼，仅仅一个 <code>.m</code> 文件，就可以起到检测是否在主线程执行的作用，而且对项目毫无侵入。后面看了下源代码，然后每个方法都设置了一个断点，然后在非主线程操作 UI，看断点位置。结果运行后，就走到了一个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This installs a small guard that checks for the most common threading-errors in UIKit.</span></div><div class="line"><span class="comment">// This won't really slow down performance but still only is compiled in DEBUG versions of PSPDFKit.</span></div><div class="line"><span class="comment">// @note No private API is used here.</span></div><div class="line">__attribute__((constructor)) <span class="keyword">static</span> <span class="keyword">void</span> PSPDFUIKitMainThreadGuard(<span class="keyword">void</span>) &#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> *selStr <span class="keyword">in</span> @[PROPERTY(setNeedsLayout), PROPERTY(setNeedsDisplay), PROPERTY(setNeedsDisplayInRect:)]) &#123;</div><div class="line">            SEL selector = <span class="built_in">NSSelectorFromString</span>(selStr);</div><div class="line">            SEL newSelector = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"pspdf_%@"</span>, selStr]);</div><div class="line">            <span class="keyword">if</span> ([selStr hasSuffix:<span class="string">@":"</span>]) &#123;</div><div class="line">                PSPDFReplaceMethodWithBlock(<span class="built_in">UIView</span>.class, selector, newSelector, ^(__<span class="keyword">unsafe_unretained</span> <span class="built_in">UIView</span> *_<span class="keyword">self</span>, <span class="built_in">CGRect</span> r) &#123;</div><div class="line">                    PSPDFAssertIfNotMainThread();</div><div class="line">                    ((<span class="keyword">void</span> ( *)(<span class="keyword">id</span>, SEL, <span class="built_in">CGRect</span>))objc_msgSend)(_<span class="keyword">self</span>, newSelector, r);</div><div class="line">                &#125;);</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">                PSPDFReplaceMethodWithBlock(<span class="built_in">UIView</span>.class, selector, newSelector, ^(__<span class="keyword">unsafe_unretained</span> <span class="built_in">UIView</span> *_<span class="keyword">self</span>) &#123;</div><div class="line">                    PSPDFAssertIfNotMainThread();</div><div class="line">                    ((<span class="keyword">void</span> ( *)(<span class="keyword">id</span>, SEL))objc_msgSend)(_<span class="keyword">self</span>, newSelector);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体代码就不分析了，就是 hook 了一些布局才会调用的函数，然后判断其是否在主线程。最有意思的是前面的修饰符<code>__attribute__((constructor))</code>，后面查阅资料才知道，该修饰符修饰的方法，在 <code>main()</code> 函数执行前， <code>+load</code> 方法执行后。</p>
<blockquote>
<p>constructor 和 +load 都是在 main 函数执行前调用，但 +load 比 constructor 更加早一丢丢，因为 dyld（动态链接器，程序的最初起点）在加载 image（可以理解成 Mach-O 文件）时会先通知 objc runtime 去加载其中所有的类，每加载一个类时，它的 +load 随之调用，全部加载完成后，dyld 才会调用这个 image 中所有的 constructor 方法。<br><a href="http://blog.sunnyxx.com/2016/05/14/clang-attributes/" target="_blank" rel="external">Clang Attributes 黑魔法小记</a></p>
</blockquote>
<p><code>__attribute__</code> 是编译器命令，后面会跟随两个括号对，主要是为了防止宏的歧义，方便宏的展开。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// +(void)load 执行之后，main() 执行之前，只对 C 方法生效</span></div><div class="line"><span class="comment">// 若有多个 constructor 且想控制优先级的话，可以写成 __attribute__((constructor(101)))</span></div><div class="line"><span class="comment">// 里面的数字越小优先级越高，1 ~ 100 为系统保留</span></div><div class="line">__attribute__((constructor))</div><div class="line">__attribute__((objc_requires_super)) <span class="comment">// 子类复写时，必须先调用父类方法</span></div><div class="line"></div><div class="line"><span class="comment">// ---------- </span></div><div class="line"><span class="comment">// 用于 @interface 或 @protocol，将类或协议的名字在编译时指定成另一个</span></div><div class="line">__attribute__((objc_runtime_name(<span class="string">"SomeClass"</span>)))</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Some</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([Some <span class="keyword">class</span>]));  <span class="comment">// "SomeClass"</span></div></pre></td></tr></table></figure>
<p>更多的 <code>__attribute__</code> 命令可参考：</p>
<blockquote>
<p>Twitter 官方博客：<a href="https://blog.twitter.com/2014/attribute-directives-in-objective-c" target="_blank" rel="external"><strong>attribute</strong> directives in Objective-C</a><br>NSHipster 关于 <code>__attribute__</code> 的讨论： <a href="http://nshipster.com/__attribute__/" target="_blank" rel="external"><strong>attribute</strong></a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍一些 Objective-C 的一些新特性。&lt;br&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vongloo.me/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Objective-C" scheme="https://vongloo.me/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Xcode 常用插件</title>
    <link href="https://vongloo.me/2016/09/17/Useful-Xcode-Plugins/"/>
    <id>https://vongloo.me/2016/09/17/Useful-Xcode-Plugins/</id>
    <published>2016-09-17T12:29:00.000Z</published>
    <updated>2019-03-03T15:42:37.279Z</updated>
    
    <content type="html"><![CDATA[<p>工欲善其事，必先利其器。随着 Xcode 的一步步变得强(yong)大(zhong)，许多功能已经被集成到 Xcode 中，但是日常开发还是会遇到很多小问题，影响效率，于是 Xcode plugins 便派上用场了。下面介绍一下自己在开发中常用的插件，排名不分先后，仅按字母排序。</p>
<a id="more"></a>
<blockquote>
<p>关于 Xcode8 不能使用插件的问题，可以在我上一篇文章<a href="http://vongloo.me/2016/09/10/Make-Your-Xcode8-Great-Again/">让你的 Xcode8 继续使用插件</a>找到解决方案。</p>
</blockquote>
<h3 id="Alcatraz"><a href="#Alcatraz" class="headerlink" title="Alcatraz"></a><a href="https://github.com/alcatraz/Alcatraz/" target="_blank" rel="external">Alcatraz</a></h3><p><img src="http://img.cdn.punmy.cn/14740910538405.jpg" alt=""></p>
<p>这个就不用多说了吧，所有插件包管理器，快捷键 <code>cmd + shift + 9</code>。</p>
<h3 id="ATProperty"><a href="#ATProperty" class="headerlink" title="ATProperty"></a><a href="https://github.com/Draveness/ATProperty" target="_blank" rel="external">ATProperty</a></h3><p><img src="http://img.cdn.punmy.cn/14740919509236.gif" alt=""><br>平时在属性声明时，总要写一堆的诸如 <code>@property (strong, nonatomic) UIWindow *window;</code>之类的，前面那一长串在属性一多时，写起来挺累的。这个插件正是为了解决这个痛点而存在，快捷键如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">快捷键</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">@t</td>
<td style="text-align:left">@property (nonatomic, strong)</td>
</tr>
<tr>
<td style="text-align:left">@w</td>
<td style="text-align:left">@property (nonatomic, weak)</td>
</tr>
<tr>
<td style="text-align:left">@y</td>
<td style="text-align:left">@property (nonatomic, copy)</td>
</tr>
<tr>
<td style="text-align:left">@a</td>
<td style="text-align:left">@property (nonatomic, assign)</td>
</tr>
</tbody>
</table>
<p><code>readonly</code> 只需在 <code>@</code> 后插入 <code>r</code> 即可，比如 <code>@rt</code>，就是 <code>@property (nonatomic, strong, readonly)</code></p>
<h3 id="Auto-Importer"><a href="#Auto-Importer" class="headerlink" title="Auto-Importer"></a><a href="https://github.com/citrusbyte/Auto-Importer-for-Xcode" target="_blank" rel="external">Auto-Importer</a></h3><p><img src="http://img.cdn.punmy.cn/14740927781208.gif" alt=""></p>
<p>在写代码过程中，比如处在 line500 的时候要引入一个新的类，这个时候不得不滑到顶部，去写一次 <code>#import&quot;xxxx.h&quot;</code>，然后又滑回来继续写代码，严重影响效率。此时你需要这个插件来解决这个苦恼，随便一个地方，使用快捷键 <code>cmd + ctrl + h</code> 来呼出弹窗，在搜索框中输入想要导入的头文件即可，无需在滑到文件顶部，参考上图。</p>
<h3 id="CATweakerSense"><a href="#CATweakerSense" class="headerlink" title="CATweakerSense"></a><a href="https://github.com/keefo/CATweaker" target="_blank" rel="external">CATweakerSense</a></h3><p><img src="http://img.cdn.punmy.cn/14740930409569.png" alt=""><br>用的不是很多，主要是在做动画比较有用，时间缓冲函数，将时间曲线可视化。</p>
<h3 id="ColorSenseRainbow"><a href="#ColorSenseRainbow" class="headerlink" title="ColorSenseRainbow"></a><a href="https://github.com/NorthernRealities/ColorSenseRainbow" target="_blank" rel="external">ColorSenseRainbow</a></h3><p><img src="http://img.cdn.punmy.cn/14740932923044.png" alt=""><br>一目了然，颜色可视化。</p>
<h3 id="DBSmartPanels"><a href="#DBSmartPanels" class="headerlink" title="DBSmartPanels"></a><a href="https://github.com/chaingarden/DBSmartPanels/" target="_blank" rel="external">DBSmartPanels</a></h3><p><img src="http://img.cdn.punmy.cn/14740934576865.jpg" alt=""><br>智能化的区域隐藏插件，在输入时自动隐藏底部 <code>debug</code>、右侧 <code>inspector</code> 区域，具体可以自定义。</p>
<h3 id="DXXcodeConsoleUnicodePlugin"><a href="#DXXcodeConsoleUnicodePlugin" class="headerlink" title="DXXcodeConsoleUnicodePlugin"></a><a href="https://github.com/dhcdht/DXXcodeConsoleUnicodePlugin" target="_blank" rel="external">DXXcodeConsoleUnicodePlugin</a></h3><p>有时候在调试时，服务端返回的中文字符在 <code>debug console</code> 中总是显示成 <code>unicode</code>，这个插件可以将其自动转成中文字符。具体可到其 GitHub 主页查看用法。</p>
<h3 id="FastStub"><a href="#FastStub" class="headerlink" title="FastStub"></a><a href="https://github.com/music4kid/FastStub-Xcode" target="_blank" rel="external">FastStub</a></h3><p><img src="http://img.cdn.punmy.cn/14740940467700.gif" alt=""></p>
<p>检测头文件、父类、协议等中的方法，然后自动在 <code>.m</code> 文件插入。快捷键 <code>cmd + ctrl + k</code></p>
<h3 id="FuzzyAutocomplete"><a href="#FuzzyAutocomplete" class="headerlink" title="FuzzyAutocomplete"></a><a href="https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin" target="_blank" rel="external">FuzzyAutocomplete</a></h3><p><img src="http://img.cdn.punmy.cn/14740942597943.gif" alt=""><br>快速补全。</p>
<h3 id="GitDiff"><a href="#GitDiff" class="headerlink" title="GitDiff"></a><a href="https://github.com/johnno1962/GitDiff" target="_blank" rel="external">GitDiff</a></h3><p><img src="http://img.cdn.punmy.cn/14740943628859.jpg" alt=""><br>检测文件中的 git 状态。</p>
<h3 id="RRConstraintsPlugin"><a href="#RRConstraintsPlugin" class="headerlink" title="RRConstraintsPlugin"></a><a href="https://github.com/RolandasRazma/RRConstraintsPlugin" target="_blank" rel="external">RRConstraintsPlugin</a></h3><p>对系统 Auto Layout 的一些补充。</p>
<h3 id="SCXcodeSwitchExpander"><a href="#SCXcodeSwitchExpander" class="headerlink" title="SCXcodeSwitchExpander"></a><a href="https://github.com/stefanceriu/SCXcodeSwitchExpander" target="_blank" rel="external">SCXcodeSwitchExpander</a></h3><p><img src="http://img.cdn.punmy.cn/14741022908523.gif" alt=""></p>
<p><code>switch</code> 时根据枚举类型，自动补全所有枚举</p>
<h3 id="SCXcodeTabSwitcher"><a href="#SCXcodeTabSwitcher" class="headerlink" title="SCXcodeTabSwitcher"></a><a href="https://github.com/stefanceriu/SCXcodeTabSwitcher" target="_blank" rel="external">SCXcodeTabSwitcher</a></h3><p><img src="http://img.cdn.punmy.cn/14741091449161.gif" alt=""></p>
<p>此插件用于存在多个 <code>tab</code> 时在 <code>tab</code> 间快速切换，类似 Chrome。快捷键 <code>Cmd + 1...9</code> 切换。</p>
<h3 id="VVDocumenter-Xcode"><a href="#VVDocumenter-Xcode" class="headerlink" title="VVDocumenter-Xcode"></a><a href="https://github.com/onevcat/VVDocumenter-Xcode" target="_blank" rel="external">VVDocumenter-Xcode</a></h3><p>这个不用多说了吧。快速注释，现已集成到 Xcode8。</p>
<h3 id="XAlign"><a href="#XAlign" class="headerlink" title="XAlign"></a><a href="https://github.com/qfish/XAlign" target="_blank" rel="external">XAlign</a></h3><p><img src="http://img.cdn.punmy.cn/14741140642718.gif" alt=""><br>对齐插件，可自定义对齐方式。</p>
<h3 id="XQuit"><a href="#XQuit" class="headerlink" title="XQuit"></a><a href="https://github.com/StefanLage/XQuit" target="_blank" rel="external">XQuit</a></h3><p><img src="http://img.cdn.punmy.cn/14741141444896.png" alt=""><br>完全退出(cmd + q) Xcode 之前，弹出一个确认框，防止误操作。</p>
<h3 id="XToDo"><a href="#XToDo" class="headerlink" title="XToDo"></a><a href="https://github.com/trawor/XToDo" target="_blank" rel="external">XToDo</a></h3><p><img src="http://img.cdn.punmy.cn/14741143739724.png" alt=""><br><img src="http://img.cdn.punmy.cn/14741143787410.png" alt=""><br>用于工程中的一些标注，及快速查找这些标注的插件。</p>
<h3 id="XVim"><a href="#XVim" class="headerlink" title="XVim"></a><a href="https://github.com/XVimProject/XVim" target="_blank" rel="external">XVim</a></h3><p>Vim 控必备。</p>
<p>以上便是个人常用的 Xcode 插件，欢迎推荐。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工欲善其事，必先利其器。随着 Xcode 的一步步变得强(yong)大(zhong)，许多功能已经被集成到 Xcode 中，但是日常开发还是会遇到很多小问题，影响效率，于是 Xcode plugins 便派上用场了。下面介绍一下自己在开发中常用的插件，排名不分先后，仅按字母排序。&lt;/p&gt;
    
    </summary>
    
      <category term="Tips" scheme="https://vongloo.me/categories/Tips/"/>
    
    
      <category term="Xcode" scheme="https://vongloo.me/tags/Xcode/"/>
    
      <category term="插件" scheme="https://vongloo.me/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="Xcode8" scheme="https://vongloo.me/tags/Xcode8/"/>
    
  </entry>
  
  <entry>
    <title>让你的 Xcode8 继续使用插件</title>
    <link href="https://vongloo.me/2016/09/10/Make-Your-Xcode8-Great-Again/"/>
    <id>https://vongloo.me/2016/09/10/Make-Your-Xcode8-Great-Again/</id>
    <published>2016-09-10T12:08:39.000Z</published>
    <updated>2019-03-03T15:42:37.279Z</updated>
    
    <content type="html"><![CDATA[<p>随着 iOS10 的正式版即将发布，Xcode8 GM 也在发布会后放出，本文不会涉及到 Xcode8 有哪些更新，而是记录了如何让 Xcode8 继续支持 Plugin。</p>
<a id="more"></a>
<h3 id="Update"><a href="#Update" class="headerlink" title="Update:"></a>Update:</h3><p><strong>2017.4.9</strong></p>
<p>Xcode 8.3 生成 XcodeGr8 后，XVim 即使用脚本更新也会失效，需要重新编译一次。下载 XVim 到本地后，需要删除删除如下几个文件：</p>
<blockquote>
<p>IDEPlaygroundEditor+XVim.h<br>IDEPlaygroundEditor+Xvim.m<br>同时屏蔽掉 XVim/XVimHookManager.m 里面对上面两个文件的引用和调用</p>
</blockquote>
<p>详情参考这个 <a href="https://github.com/XVimProject/XVim/issues/1058#issuecomment-289703908" target="_blank" rel="external">issue: Build failure with Xcode 8.3</a></p>
<p><strong>2016.10.8</strong><br>如果你的 XcodeGr8 时不时就转菊花卡死，可以试下这种方式：打开<code>系统偏好设置-&gt;安全性与隐私-&gt;通讯录-&gt;将 Xcode 前面的勾去掉</code>，如下图所示，解决方案来自 <code>Xvim</code> 的这个 <a href="https://github.com/XVimProject/XVim/issues/966#issuecomment-247276024" target="_blank" rel="external">issue</a>。</p>
<p><img src="http://img.cdn.punmy.cn/14759295440293.jpg" alt=""></p>
<p><strong>2016.9.16</strong><br>看到 GitHub 上有一个 repo 可以一句命令即可解决本文提到的所有问题 <a href="https://github.com/inket/update_xcode_plugins" target="_blank" rel="external">update_xcode_plugins</a>，没有亲测，如果觉得本文方法比较麻烦，可以一试。</p>
<p>我个人常用的 Xcode 插件可以参见这篇文章<a href="http://vongloo.me/2016/09/17/Useful-Xcode-Plugins/">Xcode 常用插件</a>。</p>
<hr>
<p>相信各位已经有尝试过 Xcode-beta 了，但是会发现之前所有的插件都失效了。一开始我以为是和之前一样 Xcode 升级了，需要更新 Xcode info.plsit 中的 DVTPlugInCompatibilityUUID,于是运行了如下命令，具体修复原理和方案可以参考这篇文章 <a href="http://joeshang.github.io/2015/04/10/fix-xcode-upgrade-plugin-invalid/" target="_blank" rel="external">Xcode升级后插件失效的原理与修复办法</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I&#123;&#125; defaults write &#123;&#125; DVTPlugInCompatibilityUUIDs -array-add `defaults read /Applications/Xcode-beta.app/Contents/Info.plist DVTPlugInCompatibilityUUID`</div></pre></td></tr></table></figure>
<p>结果还是无效，去 Github 上看，果然一堆人遇到了这个问题，可以看下这个 <a href="https://github.com/alcatraz/Alcatraz/issues/475" target="_blank" rel="external">issue</a>。由于 Xcode8 没了插件支持，我用的时候勉强还能习惯，一个用习惯了 Xvim 的同事表示不能忍，于是就去到 <a href="https://github.com/XVimProject/XVim" target="_blank" rel="external">XVim</a> 看有没有提这个 issue，果然也是有一堆人提到了这个问题，作者也给出了对应的解决方案，摘录最主要的一段如下：</p>
<blockquote>
<p>With Xcode 8 and above, you’ll be asked if you want to remove code singature from Xcode. It is required to make the XCode load XVim. So if you are OK just type ‘y’ to proceed and remove code signature from your Xcode.</p>
</blockquote>
<p>但是我并没有按照这种方式来操作，而是结合这个 <a href="https://github.com/XVimProject/XVim/issues/979#issuecomment-242976786" target="_blank" rel="external">issue</a> 中的解决方案，总结起来步骤如下：</p>
<blockquote>
<ol>
<li>编译 <a href="https://github.com/fpg1503/MakeXcodeGr8Again" target="_blank" rel="external">MakeXcodeGr8Again</a> 并且导出其 product (关于 MakeXcodeGr8Again，下文会详细说到)。</li>
<li>退出 Xcode8，同时运行刚刚导出的 MakeXcodeGr8Again，将 Xcode8 拖入其中，等待一段时间(3~10分钟)。</li>
<li>等菊花转完后，应用程序文件夹下会生成一个 XcodeGr8 的应用，运行命令 <code>sudo xcode-select -s /Applications/XcodeGr8.app/Contents/Developer</code> 将 Xcode 开发路径指向刚生成的 XcodeGr8。</li>
<li>既然 Xcode8 的签名已被移除，那么就可以继续使用上面的修复插件失效代码。但是上面的脚本要稍微改一下就是把 Xcode.app 换成 XcodeGr8.app 即可。代码如下：</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I&#123;&#125; defaults write &#123;&#125; DVTPlugInCompatibilityUUIDs -array-add `defaults read /Applications/XcodeGr8.app/Contents/Info.plist DVTPlugInCompatibilityUUID`</div></pre></td></tr></table></figure>
<p>下面我们来看下步骤1提到的 MakeXcodeGr8Again，其 <a href="https://github.com/fpg1503/MakeXcodeGr8Again/blob/master/README.md" target="_blank" rel="external">ReadMe</a> 也有对应的介绍。这里大概摘录一下:</p>
<blockquote>
<p>苹果为了避免类似 <a href="https://en.wikipedia.org/wiki/XcodeGhost" target="_blank" rel="external">Xcode Ghost 👻</a> 事件的再次发生，Xcode8 禁用了插件机制，而开放了另一种形式：<a href="https://developer.apple.com/videos/play/wwdc2016/414/" target="_blank" rel="external">Source Editor extensions</a>，但是这种形式局限性太大。MakeXcodeGr8Again 只是去除了它的签名，这样使得 Xcode8 也可以继续使用插件了。由于签名被移除，所以它的安全性又重回 Xcode7 时代，也就是还有可能受到类似 Xcode Ghost 的攻击。所以不推荐用 XcodeGr8 来提交应用到 Appstore。Use at your own risk.</p>
</blockquote>
<p>PS：可能遇到的问题</p>
<ul>
<li>1.生成了 XcodeGr8 之后，打不开。  解决方法：重启。</li>
<li>2.如果之前对其它版本的 Xcode-beat 也有使用这种方式，再对 Xcode8 GM 也是用该方式可能 MakeXcodeGr8Again 这个 APP 会一直闪退。  解决方法：卸载之前生成的 XcodeGr8，再重试。卸载后记得将开发路径重新指回原来的路径，即 <code>sudo xcode-select -s /Applications/Xcode.app/Contents/Developer</code>。如果这种方式还不行，卸载所有版本的 Xcode，然后再安装 GM 版，重复上述步骤。</li>
</ul>
<p>PPS：如果要卸载 XcodeGr8，记得将重新开发路径置回初始状态。</p>
<p>最后，重要的事情说三遍：<br><strong>不要使用 XcodeGr8 打包上传 Appstore，最好使用服务器打包，保证服务器 Xcode 是 Appstore 下载的！！！<br>不要使用 XcodeGr8 打包上传 Appstore，最好使用服务器打包，保证服务器 Xcode 是 Appstore 下载的！！！<br>不要使用 XcodeGr8 打包上传 Appstore，最好使用服务器打包，保证服务器 Xcode 是 Appstore 下载的！！！</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着 iOS10 的正式版即将发布，Xcode8 GM 也在发布会后放出，本文不会涉及到 Xcode8 有哪些更新，而是记录了如何让 Xcode8 继续支持 Plugin。&lt;/p&gt;
    
    </summary>
    
      <category term="Tips" scheme="https://vongloo.me/categories/Tips/"/>
    
    
      <category term="Xcode" scheme="https://vongloo.me/tags/Xcode/"/>
    
      <category term="插件" scheme="https://vongloo.me/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="Xcode8" scheme="https://vongloo.me/tags/Xcode8/"/>
    
  </entry>
  
  <entry>
    <title>iOS Animations by Tutorials 2.0 笔记</title>
    <link href="https://vongloo.me/2016/08/27/Note-for-iOS-Animations-by-Tutorials/"/>
    <id>https://vongloo.me/2016/08/27/Note-for-iOS-Animations-by-Tutorials/</id>
    <published>2016-08-26T16:08:21.000Z</published>
    <updated>2019-03-03T15:42:37.279Z</updated>
    
    <content type="html"><![CDATA[<p>这本书主要分成七个部分，二十七个章节，涵盖了从底层的 Core Animation 到上层的 UIView 的动画封装，AutoLayout 动画以及 ViewController 之间的转场动画。最后选择了两个开源动画库（<a href="https://github.com/icanzilb/EasyAnimation" target="_blank" rel="external">Easy Animation</a>、<a href="https://github.com/facebook/pop" target="_blank" rel="external">pop</a>）进行实践。本篇文章主要是在阅读、学习过程中的一些笔记，留下记录，日后忘记可以再来翻看。</p>
<a id="more"></a>
<h2 id="Section-Ⅰ-View-Animation"><a href="#Section-Ⅰ-View-Animation" class="headerlink" title="Section Ⅰ View Animation"></a>Section Ⅰ View Animation</h2><p>这部分主要是关于 UIView 的动画，UIView 层次的动画是一些经过封装的上层 API，简单但是实用。基本都是日常用到的，比如位置、大小、透明度、旋转、关键帧动画等等，所以没啥好记录的。</p>
<h3 id="View-之间的过渡转场"><a href="#View-之间的过渡转场" class="headerlink" title="View 之间的过渡转场"></a>View 之间的过渡转场</h3><p>主要是使用如下两个方法:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)transitionWithView:(<span class="built_in">UIView</span> *)view duration:(<span class="built_in">NSTimeInterval</span>)duration options:(<span class="built_in">UIViewAnimationOptions</span>)options animations:(<span class="keyword">void</span> (^ __<span class="keyword">nullable</span>)(<span class="keyword">void</span>))animations completion:(<span class="keyword">void</span> (^ __<span class="keyword">nullable</span>)(<span class="built_in">BOOL</span> finished))completion <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">4</span>_0);</div><div class="line"></div><div class="line"><span class="comment">// toView added to fromView.superview, fromView removed from its superview</span></div><div class="line">+ (<span class="keyword">void</span>)transitionFromView:(<span class="built_in">UIView</span> *)fromView toView:(<span class="built_in">UIView</span> *)toView duration:(<span class="built_in">NSTimeInterval</span>)duration options:(<span class="built_in">UIViewAnimationOptions</span>)options completion:(<span class="keyword">void</span> (^ __<span class="keyword">nullable</span>)(<span class="built_in">BOOL</span> finished))completion <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">4</span>_0);</div></pre></td></tr></table></figure>
<h2 id="Section-Ⅱ-Auto-Layout"><a href="#Section-Ⅱ-Auto-Layout" class="headerlink" title="Section Ⅱ Auto Layout"></a>Section Ⅱ Auto Layout</h2><p>这部分主要是 Auto Layout 的相关动画，首先基本介绍了它的使用，然后通过同一个 Demo 层层递进。总得来说，不管是手写还是 IB,布局虽然看似静态的，但是它也是能做动画的。</p>
<p>这一部分的动画，无非就是改了约束，然后把 <code>[view layoutIfNeeded]</code> 放到动画 block 里面。不过在这里学会了一招，就是在 IB 里面可以为约束设置标识（identifier）有点类似于 view 的 tag。</p>
<h2 id="Section-Ⅲ-Layer-Animation"><a href="#Section-Ⅲ-Layer-Animation" class="headerlink" title="Section Ⅲ Layer Animation"></a>Section Ⅲ Layer Animation</h2><p>这一部分通过几个 Demo 来着重介绍 CALayer 及其几个常用的子类、CAAnimation 及其子类。其中使用 CAShapeLayer、CAGradientLayer、CAReplicatorLayer 的实例都比较有趣。<br>当 UIView 的那一套动画 API 已经无法满足需要时，这个时候应该转向更为底层的 Core Animation。UIView 的那一套动画 API 归根结底也是对 Core Animation 的封装。说白了，UIView 是 CALyaer 的 delegate.两者的具体区别如下:</p>
<table>
<thead>
<tr>
<th style="text-align:center">UIView</th>
<th style="text-align:center">CALayer</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">拥有复杂的视图布局及层级等</td>
<td style="text-align:center">较简单的层级结构，所以能快速布局及绘制</td>
</tr>
<tr>
<td style="text-align:center">可交互</td>
<td style="text-align:center">不可交互</td>
</tr>
<tr>
<td style="text-align:center">利用 CPU 在主线程做一些自定义绘制及其它逻辑</td>
<td style="text-align:center">默认没有自定义逻辑，直接使用 GPU 绘制及缓存</td>
</tr>
<tr>
<td style="text-align:center">灵活、实用</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<p>这里作者给出了选择 UIView 还是 Core Animation 来做动画的一些建议：</p>
<blockquote>
<p>choose view animations any time you can to do the job; you will know when you need more performance or flexibility and have to switch to layer animations instead.<br>Don’t stress yourself about it though, because you can mix and match view and layer animations freely.</p>
</blockquote>
<p>简单来说就是在 UIView 满足需求的时候尽量使用 UIView，当追求更好的性能及灵活性时可以考虑使用 Core Animation.当然，两者也可以混合使用。</p>
<h3 id="fillMode"><a href="#fillMode" class="headerlink" title="fillMode"></a>fillMode</h3><p>这里借用书中的几张图来阐明一下各种模式</p>
<ul>
<li><strong>kCAFillModeRemoved</strong><br>img.cdn.punmy.cn<br>  默认模式：动画执行完毕后恢复原样</li>
</ul>
<p><img src="http://img.cdn.punmy.cn/QQ20160826-0@2x.png" alt="QQ20160826-0@2x"></p>
<ul>
<li><p><strong>kCAFillModeBackwards</strong>img.cdn.punmy.cn</p>
<p>  动画开始前展示第一帧<br><img src="http://img.cdn.punmy.cn/QQ20160826-1@2x.png" alt="QQ20160826-1@2x"></p>
</li>
<li><p><strong>kCAFillModeForwards</strong><br>img.cdn.punmy.cn<br>  动画结束后 layer 维持最后一帧的状态</p>
</li>
</ul>
<p><img src="http://img.cdn.punmy.cn/QQ20160826-2@2x.png" alt="QQ20160826-2@2x"></p>
<ul>
<li><strong>kCAFillModeBoth</strong><br>img.cdn.punmy.cn<br>  是上面两种模式的结合，动画开始前维持第一帧，动画结束后维持最后一帧</li>
</ul>
<p><img src="http://img.cdn.punmy.cn/QQ20160826-3@2x.png" alt="QQ20160826-3@2x"></p>
<h3 id="Layer-弹性动画"><a href="#Layer-弹性动画" class="headerlink" title="Layer 弹性动画"></a>Layer 弹性动画</h3><p>这一节以钟摆举例，来解释弹性阻尼动画的相关属性。</p>
<ul>
<li><p><strong>damping</strong></p>
<p>  阻尼？不知道是不是这么翻译，主要是由空气摩擦、机械摩擦以及其它外界阻力造成的。    </p>
</li>
<li><p><strong>mass</strong></p>
<p>  惯性？物体的质量越大，振荡时间越长。</p>
</li>
<li><p><strong>stiffness</strong></p>
<p>  重力加速度（G）</p>
</li>
<li><p><strong>initial velocity</strong></p>
<p>  初始速度，开始运动前，外界的推（拉力）产生的速度<br>img.cdn.punmy.cn<br>某些情况下，UIView 的弹性阻尼动画看起来胡比较生硬，因为在指定的 <code>duration</code> 内无法停下来，而被系统强制停下来，所以看起来很生硬。就如下图：</p>
</li>
</ul>
<p><img src="http://img.cdn.punmy.cn/QQ20160826-4@2x.png" alt="QQ20160826-4@2x"></p>
<p>如果 <code>duration</code> 为0.25，此时本应该还有振荡，但是动画时间已到，只能强制停止振荡，进而使动画看起来略微生硬。所以 <code>CASpringAnimation</code> 里面有一个属性叫做 <code>settlingDuration</code>,该属性表示所有动画参数设定好之后，振荡完成是所需时间，如果将 <code>duration</code> 设置成这样，那么动画看起来就会很自然。</p>
<blockquote>
<p>友情提示：请在设置好所有弹性振荡参数之后再设置 <code>duration</code>.</p>
</blockquote>
<h2 id="Section-Ⅳ-3D-Animations"><a href="#Section-Ⅳ-3D-Animations" class="headerlink" title="Section Ⅳ 3D Animations"></a>Section Ⅳ 3D Animations</h2><p>这部分主要通过一个侧拉菜单的 Demo 讲解了 3D 动画该如何实现。关键还是在于 CATransform3D 中的 m34 以及配合改变 anchor point,要想让视图看起来具有 3D 透视效果，可以将 m34 设置为 -1.0 / [camera distance], 分母代表相机离视图的距离。</p>
<p>关于距离选值与透视效果的明显程度可参见下表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">distance</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0.1~500</td>
<td style="text-align:center">失真较严重</td>
</tr>
<tr>
<td style="text-align:center">700~2000</td>
<td style="text-align:center">效果最好，逼真</td>
</tr>
<tr>
<td style="text-align:center">&gt;2000</td>
<td style="text-align:center">几乎没有透视效果</td>
</tr>
</tbody>
</table>
<h2 id="Section-Ⅴ-Further-Types-of-Animations"><a href="#Section-Ⅴ-Further-Types-of-Animations" class="headerlink" title="Section Ⅴ Further Types of Animations"></a>Section Ⅴ Further Types of Animations</h2><p>这部分主要是讲一些其它动画的延伸，比如粒子动画、ImageView 的帧动画。<br>粒子动画主要使用 CAEmitterLayer 来做，具体细节可以参考 CAEmitterLayer 的 API。<br>帧动画主要是讲解 UIImageView 关于使用图片数组产生帧动画的效果，基本就是改变其 animationDuration 来达到控制帧率的效果。</p>
<h2 id="Section-Ⅵ-View-Controller-Transitions"><a href="#Section-Ⅵ-View-Controller-Transitions" class="headerlink" title="Section Ⅵ View Controller Transitions"></a>Section Ⅵ View Controller Transitions</h2><p>这一部分主要是将视图控制器之间过渡的转场效果动画。关于这里，不再过多记录，毕竟关于 VC 之间的转场效果 GitHub 上一抓一大把了，随便拿一个读一读源码即可，万变不离其宗。</p>
<h2 id="Section-Ⅶ-Third-Party-Animation-Libraries"><a href="#Section-Ⅶ-Third-Party-Animation-Libraries" class="headerlink" title="Section Ⅶ Third-Party Animation Libraries"></a>Section Ⅶ Third-Party Animation Libraries</h2><p>这部分主要是两个开源动画库的使用，找个时间读一读源码，另外再写一篇文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这本书主要分成七个部分，二十七个章节，涵盖了从底层的 Core Animation 到上层的 UIView 的动画封装，AutoLayout 动画以及 ViewController 之间的转场动画。最后选择了两个开源动画库（&lt;a href=&quot;https://github.com/icanzilb/EasyAnimation&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Easy Animation&lt;/a&gt;、&lt;a href=&quot;https://github.com/facebook/pop&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pop&lt;/a&gt;）进行实践。本篇文章主要是在阅读、学习过程中的一些笔记，留下记录，日后忘记可以再来翻看。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://vongloo.me/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="笔记" scheme="https://vongloo.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>WebView 与 JS 的交互</title>
    <link href="https://vongloo.me/2015/10/19/Communication-Between-WebView-and-JS/"/>
    <id>https://vongloo.me/2015/10/19/Communication-Between-WebView-and-JS/</id>
    <published>2015-10-18T16:14:41.000Z</published>
    <updated>2019-03-03T15:42:37.279Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要分析一些 iOS 中 WebView 与 JavaScript 交互的一些框架。</p>
<a id="more"></a>
<h3 id="UIWebView-调-JS-方法"><a href="#UIWebView-调-JS-方法" class="headerlink" title="UIWebView 调 JS 方法"></a>UIWebView 调 JS 方法</h3><p>通过调用如下方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span> *)stringByEvaluatingJavaScriptFromString:(<span class="built_in">NSString</span> *)script;</div></pre></td></tr></table></figure>
<p>比如获取网页 title，也可以动态注入 JS，先写一个 JS 函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">showAlert</span>(<span class="params"></span>) </span>&#123;  </div><div class="line">    alert(<span class="string">'show alert'</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后保存为js 文件，最后读取这个文件并注入</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *filePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"test"</span> ofType:<span class="string">@"js"</span>];  </div><div class="line"><span class="built_in">NSString</span> *jsString = [[<span class="built_in">NSString</span> alloc] initWithContentsOfFile:filePath];  </div><div class="line">[webView stringByEvaluatingJavaScriptFromString:jsString];</div></pre></td></tr></table></figure>
<h3 id="JS-调原生方法"><a href="#JS-调原生方法" class="headerlink" title="JS 调原生方法"></a>JS 调原生方法</h3><p>直接调用无法做到，可以间接实现。</p>
<h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p>JS 中要从现在的网页跳到另外一个网页的时候，就会去修改 <code>window.location.href</code> ，而在 <code>@protocol UIWebViewDelegate</code> 中有一个回调方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)webView:(<span class="built_in">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span> *)request navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType;</div></pre></td></tr></table></figure>
<p>可以监听到网页的跳转，所以可以在此做文章。<br>通过指定<code>window.location.href = schemename://nativemethodname:args</code>就可以去间接调用到原生函数。JS 一旦修改了<code>window.location.href</code>，<code>UIWebView</code>就会收到相应回调，也就是上面说的方法，这样我们可以通过判断<code>request</code>的<code>url</code>是否为自定义的 <code>scheme</code>来决定是否调用原生函数。</p>
<h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p>创建iframe，设置src，并插入到body节点</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">url</span>) </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">"IFRAME"</span>);</div><div class="line">  iframe.setAttribute(<span class="string">"src"</span>, url);</div><div class="line">  <span class="built_in">document</span>.documentElement.appendChild(iframe);</div><div class="line">  iframe.parentNode.removeChild(iframe);</div><div class="line">  iframe = <span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line">execute(<span class="string">"schemename://nativemethodname:args"</span>);</div></pre></td></tr></table></figure>
<p>上述的这一串<code>schemename://nativemethodname:args</code>由客户端和前端约定好即可。剩余的事就是截获这个<code>request</code>，然后解析得到相应的参数，传入要调用的原生函数即可。同时在回调方法中要<code>return NO</code>。<br>大致代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)webView:(<span class="built_in">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span> *)request navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSURL</span> *requestUrl = request.URL;</div><div class="line">    <span class="keyword">if</span> ([requestUrl.scheme isEqualToString:<span class="string">@"schemename"</span>]) &#123;</div><div class="line">            <span class="built_in">NSArray</span> *components = [requestUrl.absoluteString componentsSeparatedByString:<span class="string">@":"</span>];</div><div class="line">            <span class="built_in">NSString</span> *resultJSONString = [components[<span class="number">2</span>] stringByReplacingPercentEscapesUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line">            [<span class="keyword">self</span> customMethod:resultJsonString];</div><div class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        &#125;</div><div class="line">   <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="WebViewJavaScriptBridge"><a href="#WebViewJavaScriptBridge" class="headerlink" title="WebViewJavaScriptBridge"></a>WebViewJavaScriptBridge</h3><p><img src="http://ww3.sinaimg.cn/large/ba81ca29gw1evpc6lvjkvj21ee0vqgry.jpg" alt=""></p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>大致原理与上面说的一致。只不过<code>WebViewJavaScriptBridge</code>进行了更完善的封装，使得 <code>JS</code>与<code>Native</code>之间的通信变得更为简便。</p>
<p>一开始注入<code>WebViewJavaScriptBridge.js</code>,该文件中的<code>JS</code>方法主要做了以下几件事</p>
<ul>
<li>创建了一个用于发送消息的iFrame(通过创建一个隐藏的<code>ifrmae</code>，并设置它的URL 来发出一个请求，从而触发UIWebView的<code>shouldStartLoadWithRequest</code>回调协议)</li>
<li>创建了一个核心对象<code>WebViewJavaScriptBridge</code>，并给它定义了几个方法，这些方法大部分是公开的API方法</li>
<li>创建了一个事件：<code>WebViewJavaScriptBridgeReady</code>，并<code>dispatch</code>。##</li>
</ul>
<p><code>native</code>将方法名、参数、回调的id放到一个对象中传给<code>js</code>。<code>js</code>根据方法名字调用相应方法，之后将返回数据和<code>responseId</code>拼装，最后通过<code>src</code> 重定向到<code>UIWebview</code> 的<code>delegate</code>。<code>native</code>得到数据后根据<code>responseId</code>调用事先装入<code>_responseCallbacks</code>的<code>block</code>，动态读取调用，从而完成交互。</p>
<h4 id="流程（Native端）"><a href="#流程（Native端）" class="headerlink" title="流程（Native端）"></a>流程（Native端）</h4><h5 id="Public-Interface"><a href="#Public-Interface" class="headerlink" title="Public Interface"></a>Public Interface</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)bridgeForWebView:(WVJB_WEBVIEW_TYPE*)webView handler:(WVJBHandler)handler;</div><div class="line">+ (<span class="keyword">instancetype</span>)bridgeForWebView:(WVJB_WEBVIEW_TYPE*)webView webViewDelegate:(WVJB_WEBVIEW_DELEGATE_TYPE*)webViewDelegate handler:(WVJBHandler)handler;</div><div class="line">+ (<span class="keyword">instancetype</span>)bridgeForWebView:(WVJB_WEBVIEW_TYPE*)webView webViewDelegate:(WVJB_WEBVIEW_DELEGATE_TYPE*)webViewDelegate handler:(WVJBHandler)handler resourceBundle:(<span class="built_in">NSBundle</span>*)bundle;</div><div class="line">+ (<span class="keyword">void</span>)enableLogging;</div><div class="line">- (<span class="keyword">void</span>)send:(<span class="keyword">id</span>)message;</div><div class="line">- (<span class="keyword">void</span>)send:(<span class="keyword">id</span>)message responseCallback:(WVJBResponseCallback)responseCallback;</div><div class="line">- (<span class="keyword">void</span>)registerHandler:(<span class="built_in">NSString</span>*)handlerName handler:(WVJBHandler)handler;</div><div class="line">- (<span class="keyword">void</span>)callHandler:(<span class="built_in">NSString</span>*)handlerName;</div><div class="line">- (<span class="keyword">void</span>)callHandler:(<span class="built_in">NSString</span>*)handlerName data:(<span class="keyword">id</span>)data;</div><div class="line">- (<span class="keyword">void</span>)callHandler:(<span class="built_in">NSString</span>*)handlerName data:(<span class="keyword">id</span>)data responseCallback:(WVJBResponseCallback)responseCallback;</div></pre></td></tr></table></figure>
<h5 id="初始化一个-bridge"><a href="#初始化一个-bridge" class="headerlink" title="初始化一个 bridge"></a>初始化一个 bridge</h5><p>初始化的工作主要如下：</p>
<ul>
<li>设置默认的消息处理 block ———— messageHandler</li>
<li>初始化用来保存消息处理 block 的字典 ———— messageHandlers</li>
<li>初始化消息队列数组 ———— startupMessageQueue</li>
<li>初始化响应回调 ———— responseCallbacks</li>
<li>以及初始化全局唯一标识 ———— uniqueId</li>
</ul>
<p>当在外部调用 </p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)registerHandler:(<span class="built_in">NSString</span> *)handlerName handler:(WVJBHandler)handler;</div></pre></td></tr></table></figure>
<p>方法时，会将 handler 保存到上面初始化好的 messageHandlers 当中，key为上述方法中的 handlerName，value 为上述方法的 handler。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)sendData:(<span class="keyword">id</span>)data responseCallback:(WVJBResponseCallback)responseCallback handlerName:(<span class="built_in">NSString</span>*)handlerName;</div></pre></td></tr></table></figure>
<p>发送消息时，会将消息加入到消息队列数组，加到数组当中的object 为字典型，字典有三个 key，分别为 data，callbackId， handlerName，分别对应上述方法的三个参数。入队时，如果当前消息队列存在，则将该消息入队，否则立即分发该消息。</p>
<h5 id="网页加载过程"><a href="#网页加载过程" class="headerlink" title="网页加载过程"></a>网页加载过程</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)webView:(<span class="built_in">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span> *)request navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType;</div></pre></td></tr></table></figure>
<p>加载请求或 html 时，在 shouldStartLoadWithRequest 回调中会先判断请求是否带自定义协议。如果带有自定义协议，会调用注入的 js 中 WebViewJavaScriptBridge 的_fetchQueue 方法来获取当前消息，然后分发该消息。主要是在分发消息这一块，拿到消息 json 然后序列化，如果这个消息是队列(数组)才进行处理，消息队列中也是一系列字典型对象，这些对象可能有这么几个key：responseId，responseData，callbackId，handlerName，data。<br>然后对消息队列做一个遍历大致逻辑如下：</p>
<ul>
<li>如果 responseId 对应的 value 存在，那么就到 responseCallbacks 字典中去寻找对应的 WVJBResponseCallback 型回调 block，然后执行，block 参数为 responseData 对应的 value。然后把这个 block 从 responseCallbacks 字典中移除。</li>
<li>如果 responseId 对应的 value 不存在，再看 callbackId 对应的 value 是否存在，存在则设置回调 responseCallback，这个 responseCallback 主要是创建一个消息，然后是消息入队，这个消息字典为 <code>@{ @&quot;responseId&quot;:callbackId, @&quot;responseData&quot;:responseData }</code>；反之 responseCallback 中什么也不执行；最后判断 handlerName 对应的 value 是否存在，存在则取 messageHandlers 中对应的回调 handler，不存在就是用默认的 handler，最后执行这个 WVJBHandler 型的 handler，参数为 data 对应的 value 以及 responseCallback。</li>
</ul>
<p>文字有点多，参考下下面这个流程图：</p>
<p><img src="http://ww4.sinaimg.cn/large/ba81ca29gw1evpd3k7ax7j21iu0s0n5u.jpg" alt=""></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)webViewDidFinishLoad:(<span class="built_in">UIWebView</span> *)webView;</div></pre></td></tr></table></figure>
<p>加载结束的回调中判断 js 是否初始化了 WebViewJavaScriptBridge实例，如果不存在，就注入本地的 js。然后检测到 bridge 调用自定义 scheme 后会分发整个消息队列即 startupMessageQueue，遍历消息队列然后取出每一个消息对象(NSDictionary) 然后将其序列化成 JSON，在主线程中调用 JS 的 WebViewJavaScriptBridge._handleMessageFromObjC 方法，参数就是序列化后的 JSON 数据。分发完成后，将 startupMessageQueue 队列置为 nil。</p>
<p>至此 OC 端的整个流程完毕。</p>
<h4 id="JS-端流程"><a href="#JS-端流程" class="headerlink" title="JS 端流程"></a>JS 端流程</h4><p>JS 端流程和 OC 端流程大致是一样的</p>
<h5 id="Public-Interface-1"><a href="#Public-Interface-1" class="headerlink" title="Public Interface"></a>Public Interface</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">messageHandler</span>)</span></div><div class="line"><span class="function"><span class="title">function</span> <span class="title">send</span>(<span class="params">data, responseCallback</span>)</span></div><div class="line"><span class="function"><span class="title">function</span> <span class="title">registerHandler</span>(<span class="params">handlerName, handler</span>)</span></div><div class="line"><span class="function"><span class="title">function</span> <span class="title">callHandler</span>(<span class="params">handlerName, data, responseCallback</span>)</span></div><div class="line"><span class="function"><span class="title">function</span> <span class="title">_fetchQueue</span>(<span class="params"></span>)</span></div><div class="line"><span class="function"><span class="title">function</span> <span class="title">_handleMessageFromObjC</span>(<span class="params">messageJSON</span>)</span></div></pre></td></tr></table></figure>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>类似 OC 中的初始化</p>
<ul>
<li>注入一个默认的 messageHandler</li>
<li>初始化一个消息接收队列，然后调用内部方法 _dispatchMessageFromObjC 来分发消息,同时将消息接收队列置空</li>
</ul>
<h5 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h5><p>调用内部 <code>function _doSend(message, responseCallback)</code> 函数，该函数通过判断 responseCallback 回调是否存在，存在则将这个回调存入到 responseCallbacks 字典中，其 key 是全局唯一的，同时将这个 key 存入到 message 这个字典参数中，其 key 和 value 一致，及 message[‘key’] = key。接着把这个 message 参数入队即加到 sendMessageQueue 数组中。然后重定向 frame 的 src，这样 OC 端就可以在代理回调方法中去拦截这个 src 对应的 request。</p>
<h5 id="消息处理机制"><a href="#消息处理机制" class="headerlink" title="消息处理机制"></a>消息处理机制</h5><p>如果消息接受队列存在则将消息 JSON 入队即添加到 receiveMessageQueue 数组中。反之，调用内部消息分发方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_dispatchMessageFromObjC</span>(<span class="params">messageJSON</span>)</span></div></pre></td></tr></table></figure>
<p>分发机制类似 OC 端的那张流程图，在此不做详述。</p>
<h5 id="注册及调用-handler"><a href="#注册及调用-handler" class="headerlink" title="注册及调用 handler"></a>注册及调用 handler</h5><ul>
<li>注册：在 messageHandlers 这个字典添加对应的 key 和 value。key 为 name，value 为 handler</li>
<li>调用：类似发送消息，message 参数为 { handlerName:handlerName, data:data }</li>
</ul>
<h5 id="获取消息队列-供-OC-端调用"><a href="#获取消息队列-供-OC-端调用" class="headerlink" title="获取消息队列(供 OC 端调用)"></a>获取消息队列(供 OC 端调用)</h5><p>这里会将消息发送数组进行 JSON 转化，转换后清空消息队列，然后返回给 OC 端。</p>
<h5 id="内部注入的-JS"><a href="#内部注入的-JS" class="headerlink" title="内部注入的 JS"></a>内部注入的 JS</h5><p>上面说的所有都在内部注入的 JS(WebViewJavaScriptBridge.js.txt) 中完成,该 JS 做的事情在上述的实现原理中也有提到，这里不再展开。</p>
<h5 id="外部-html-或-js-需要处理的事"><a href="#外部-html-或-js-需要处理的事" class="headerlink" title="外部 html 或 js 需要处理的事"></a>外部 html 或 js 需要处理的事</h5><p>可参考下例的写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'WebViewJavascriptBridgeReady'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> bridge = event.bridge</div><div class="line">    <span class="comment">// Start using the bridge</span></div><div class="line">&#125;, <span class="literal">false</span>)</div></pre></td></tr></table></figure>
<p>可将上述代码封装到一个 JS 函数中，然后在函数中进行其它一系列操作，如init，send 等具体参见 <a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">Demo</a>。</p>
<h3 id="JavaScriptCore-iOS7-amp-OS-X-10-9-later"><a href="#JavaScriptCore-iOS7-amp-OS-X-10-9-later" class="headerlink" title="JavaScriptCore(iOS7 &amp; OS X 10.9 later)"></a>JavaScriptCore(iOS7 &amp; OS X 10.9 later)</h3><h4 id="主要的类"><a href="#主要的类" class="headerlink" title="主要的类:"></a>主要的类:</h4><ul>
<li>JSVirtualMachine：非常轻量，可初始化多个 VM 来支持 JS 中的多线程</li>
<li>JSContext：给 JS 提供运行上下文环境以及一系列值操作(通过下标来获取，类似 NSdictionary，即context[@”objectKey”])，一个 VM 中可有多个 context</li>
<li>JSValue：数据桥梁</li>
<li>JSManagedValue：用于解决 retain cycle</li>
</ul>
<h4 id="OC-调用-JS"><a href="#OC-调用-JS" class="headerlink" title="OC 调用 JS"></a>OC 调用 JS</h4><p>JSContext 可调用 <code>evaluateScript:</code> 方法来执行某个脚本如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[context evaluateScript:@”var square = function(x) &#123;<span class="keyword">return</span> x*x;&#125;”]; </div><div class="line">JSValue *squareFunction = context[@”square”]; <span class="built_in">NSLog</span>(@”%@”, squareFunction);  <span class="comment">// function (x) &#123;return x*x;&#125;</span></div><div class="line">JSValue *aSquared = [squareFunction callWithArguments:@[context[@”a”]]]; <span class="built_in">NSLog</span>(@”a^<span class="number">2</span>: %@”, aSquared); <span class="comment">//a^2: 25</span></div><div class="line">JSValue *nineSquared = [squareFunction callWithArguments:@[@<span class="number">9</span>]]; </div><div class="line"><span class="built_in">NSLog</span>(@”<span class="number">9</span>^<span class="number">2</span>: %@”, nineSquared); <span class="comment">//81</span></div></pre></td></tr></table></figure>
<h4 id="JS-调用-OC"><a href="#JS-调用-OC" class="headerlink" title="JS 调用 OC"></a>JS 调用 OC</h4><p>两种方式：</p>
<ul>
<li>Block</li>
<li>JSExport 协议</li>
</ul>
<h5 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">context[<span class="string">@"factorial"</span>] = ^(<span class="keyword">int</span> x) &#123;</div><div class="line">        <span class="keyword">int</span> factorial = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (; x &gt; <span class="number">1</span>; x--) &#123;</div><div class="line">            factorial *= x;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> factorial;</div><div class="line">    &#125;;</div><div class="line">[context evaluateScript:<span class="string">@"var fiveFactorial = factorial(5);"</span>];</div><div class="line">JSValue *fiveFactorial = context[<span class="string">@"fiveFactorial"</span>];</div><div class="line"><span class="comment">// 5! = 120</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"5! = %@"</span>, fiveFactorial);</div></pre></td></tr></table></figure>
<p>值得注意的是：</p>
<ul>
<li>不要在 block 中持有 JSValue，而是应该将JSValue 作为参数来传递</li>
<li>不要在 block 中持有 JSContext，可通过 <code>[JSContext currentContext]</code>来获取当前 context</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">JSContext *context = [[JSContext alloc] init];context[<span class="string">@"callback"</span>] = ^&#123;</div><div class="line">	<span class="comment">//错误示例 </span>     JSValue *object = [JSValue valueWithNewObjectInContext:context];</div><div class="line">     <span class="comment">//正确的姿势</span></div><div class="line">     JSValue *object = [JSValue valueWithNewObjectInContext:        [JSContext currentContext]];     object[<span class="string">@"x"</span>] = <span class="number">2</span>;     object[<span class="string">@"y"</span>] = <span class="number">3</span>;     <span class="keyword">return</span> object;&#125;;</div></pre></td></tr></table></figure>
<h5 id="JSExport-协议"><a href="#JSExport-协议" class="headerlink" title="JSExport 协议"></a>JSExport 协议</h5><p>如果没有这个协议，OC 端的修改会同步到 JS 端，但是 JS 端的修改对 JS 和 OC 均无影响。见下例</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//TestModel.m</span></div><div class="line">- (<span class="built_in">NSString</span> *)description</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSString</span> *str = [<span class="string">@"TestModel With testString:"</span> stringByAppendingString:<span class="keyword">self</span>.testString];</div><div class="line">    <span class="keyword">return</span> [str stringByAppendingString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@" and numberStr:%@"</span>,<span class="keyword">self</span>.numberStr]];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// viewDidLoad</span></div><div class="line">TestModel *model = [[TestModel alloc] init];</div><div class="line">model.testString = <span class="string">@"test string"</span>;</div><div class="line">model.numberStr = <span class="string">@"123"</span>;</div><div class="line">JSContext *context = [[JSContext alloc] initWithVirtualMachine:[[JSVirtualMachine alloc] init]];</div><div class="line">context[<span class="string">@"model"</span>] = model;</div><div class="line">JSValue *modelValue = context[<span class="string">@"model"</span>];</div><div class="line"><span class="comment">// model: TestModel With testString:test string and numberStr:123</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"model: %@"</span>,model);</div><div class="line"><span class="comment">// model JSValue: TestModel With testString:test string and numberStr:123</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"model JSValue: %@"</span>,modelValue);</div><div class="line">model.numberStr = <span class="string">@"456"</span>;</div><div class="line"><span class="comment">// model: TestModel With testString:test string and numberStr:456</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"model: %@"</span>,model);</div><div class="line"><span class="comment">// model JSValue: TestModel With testString:test string and numberStr:456</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"model JSValue: %@"</span>,modelValue);</div><div class="line">[context evaluateScript:<span class="string">@"model.testString = \"anotoher test\";model.numberStr = \"789\""</span>];</div><div class="line"><span class="comment">// model: TestModel With testString:test string and numberStr:456</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"model: %@"</span>,model);</div><div class="line"><span class="comment">// model JSValue: TestModel With testString:test string and numberStr:456</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"model JSValue: %@"</span>,modelValue);</div></pre></td></tr></table></figure>
<p>如果想要上述 JS 修改起作用,则需要实现 JSExport 协议。<br>通过实现该协议来暴露自定义类给 JS，这样 JS 会为这个类创建一个 wrapper object，这样看起来就像 OC 和 JS 在互相传值一样。这样，一个对象可以在 JS 和 OC 间共享，任何一端的更改都将同步到另外一端。需要注意的是，JS 只能修改暴露在协议中的属性或调用协议中的方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// .h</span></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">TestModelDelegate</span> &lt;<span class="title">JSExport</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *testString;</div><div class="line">- (<span class="keyword">void</span>)modelTest;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestModel</span> : <span class="title">NSObject</span> &lt;<span class="title">TestModelDelegate</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *testString;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *numberStr;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// .m</span></div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)description</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSString</span> *str = [<span class="string">@"TestModel With testString:"</span> stringByAppendingString:<span class="keyword">self</span>.testString];</div><div class="line">    <span class="keyword">return</span> [str stringByAppendingString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@" and numberStr:%@"</span>,<span class="keyword">self</span>.numberStr]];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)modelTest</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"modelTest!!!"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)test</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Test!!!"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// viewDidLoad</span></div><div class="line">[context evaluateScript:<span class="string">@"model.testString = \"anotoher test\";model.numberStr = \"567\""</span>];</div><div class="line"><span class="comment">// model: TestModel With testString:anotoher test and numberStr:123</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"model: %@"</span>,model);</div><div class="line"><span class="comment">// model JSValue: TestModel With testString:anotoher test and numberStr:123</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"model JSValue: %@"</span>,modelValue);</div><div class="line"><span class="comment">// modelTest!!!</span></div><div class="line">[context evaluateScript:<span class="string">@"model.modelTest()"</span>];</div><div class="line">JSValue *unknowValue = [context evaluateScript:<span class="string">@"model.test()"</span>];</div><div class="line"><span class="comment">// unknowValue :undefined</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"unknowValue :%@"</span>,unknowValue);</div></pre></td></tr></table></figure>
<p>上例中的 numberStr 之所以还是保持为 123 是因为，这个属性不在协议中，JS 对其修改不起作用，同样如果 JS 中调用 model 不在协议中的方法，也不起作用，如果用 JSValue 去接收这个值，其值为 undefined。<br>没有任何响应，如果用一个 JSValue 去接收上面代码的值，得到的是 undifine</p>
<h5 id="对象对应关系"><a href="#对象对应关系" class="headerlink" title="对象对应关系"></a>对象对应关系</h5><table>
<thead>
<tr>
<th>Objective-C type</th>
<th>JavaScript type</th>
</tr>
</thead>
<tbody>
<tr>
<td>         nil</td>
<td>undefined</td>
</tr>
<tr>
<td>        NSNull</td>
<td>null</td>
</tr>
<tr>
<td>       NSString</td>
<td>string</td>
</tr>
<tr>
<td>       NSNumber</td>
<td>number, boolean</td>
</tr>
<tr>
<td>     NSDictionary</td>
<td>Object object</td>
</tr>
<tr>
<td>       NSArray</td>
<td>Array object</td>
</tr>
<tr>
<td>        NSDate</td>
<td>Date object</td>
</tr>
<tr>
<td>       NSBlock</td>
<td>Function object </td>
</tr>
<tr>
<td>          id</td>
<td>Wrapper object </td>
</tr>
<tr>
<td>        Class</td>
<td>Constructor object</td>
</tr>
</tbody>
</table>
<h4 id="UIWebView-与-JavaScriptCore-的交互"><a href="#UIWebView-与-JavaScriptCore-的交互" class="headerlink" title="UIWebView 与 JavaScriptCore 的交互"></a>UIWebView 与 JavaScriptCore 的交互</h4><p>UIWebview 也有一个 JSContext 实例，但是没有暴露在 API 中，但是我们可以通过 KVC 或者在 NSObject 分类去拿到这个实例，然后来进行自定义的一些操作。关于 NSObject 分类实现可以参考<a href="http://stackoverflow.com/questions/18920536/why-use-javascriptcore-in-ios7-if-it-cant-access-a-uiwebviews-runtime" target="_blank" rel="external">这里</a>。但是这两种方法都有可能被拒。</p>
<p>其实WebView 与 JS 的交互和上述的 TestModel 与 JS 交互区别不大。只不过上例都是自己创建的 context，而在webView 中则是我们通过 KVC 来拿到这个 context 而不是自己创建。来看一个例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span></span></div><div class="line"><span class="undefined">            &#123;</span></div><div class="line"><span class="undefined">                objcObject.testDemo();</span></div><div class="line"><span class="undefined">                alert(objcObject);</span></div><div class="line"><span class="undefined">            &#125;</span></div><div class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>JavaScriptCore Demo<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"test()"</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>上述 html 简单创建了一个 button，然后绑定一个事件。<br>接下来看看 ViewController 里面做了什么。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// .h</span></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">TestJSDelegate</span> &lt;<span class="title">JSExport</span>&gt;</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)testDemo;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WebViewController</span> : <span class="title">UIViewController</span> &lt;<span class="title">TestJSDelegate</span>,<span class="title">UIWebViewDelegate</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// .m</span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="built_in">NSURL</span> *path = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"test"</span> withExtension:<span class="string">@"html"</span>];</div><div class="line">    <span class="built_in">NSString</span> *html = [<span class="built_in">NSString</span> stringWithContentsOfURL:path encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];</div><div class="line">    [<span class="keyword">self</span>.webView loadHTMLString:html baseURL:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)webViewDidFinishLoad:(<span class="built_in">UIWebView</span> *)webView</div><div class="line">&#123;</div><div class="line">	JSContext *context = [webView valueForKeyPath:<span class="string">@"documentView.webView.mainFrame.javaScriptContext"</span>];</div><div class="line">    context[<span class="string">@"objcObject"</span>] = <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)testDemo</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"test!!!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行效果:<br><img src="http://ww3.sinaimg.cn/large/ba81ca29gw1evw1vs00ktj20af0j5t92.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/ba81ca29gw1evw1xpangwj20bz01b74b.jpg" alt=""></p>
<p>如果协议方法中有多个参数该怎么调用呢？举个例子</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ObjC 中的某个协议方法</span></div><div class="line">- (<span class="keyword">void</span>)testWithName:(<span class="built_in">NSString</span> *)name age:(<span class="built_in">NSNumber</span> *)age</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"name:%@,age:%@"</span>,name,age);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 在上述 html 的 js 中添加一行代码</div><div class="line">objcObject.testWithNameAge("Tracy",20);</div></pre></td></tr></table></figure>
<p>那么在按钮点击后，协议方法将会被执行，然后打印出 <code>name:Tracy,age:20</code>。</p>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>OC 中是用的是 ARC，JavaScriptCore 中用的是垃圾回收机制（garbage collection）,JavaScriptCore 中所有引用都为强引用。在大部分情况下，JavaScriptCore 能做到在这两种内存管理机制之间无缝切换，但是在以下两种情况下需要特别注意：</p>
<ul>
<li>在 OC 对象中存储 JavaScript 值</li>
<li>在 OC 对象中添加 JavaScript 域</li>
</ul>
<p>如下例就会造成循环引用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ClickHandler 构造器，button 为 OC 对象，callback 是按钮点击事件回调</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClickHandler</span>(<span class="params">button, callback</span>) </span>&#123;     <span class="keyword">this</span>.button = button;     <span class="keyword">this</span>.button.onClickHandler = <span class="keyword">this</span>;     <span class="keyword">this</span>.handleEvent = callback;&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyButton</span></span>- (<span class="keyword">void</span>)setOnClickHandler:(JSValue *)handler&#123;     _onClickHandler = handler; <span class="comment">// Retain cycle</span>&#125;<span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>上例中 ClickHandler 对 button 进行了强引用，而 MyButton 中又对 _onClickHandler 这个 JSValue 进行了强引用，最终导致循环引用，如下图所示：</p>
<p><img src="http://ww3.sinaimg.cn/large/ba81ca29gw1ew0u1lmnsgj21kw0q3wj0.jpg" alt=""><br>如果将 _onClickHandler 设置为 weak，那么我们将收不到点击事件回调。</p>
<p>举个栗子，在某个方法中有一个临时的 OC 对象，然后通过 JSContext 被 JS 中的变量引用，但是该 OC 方法调用结束后，这个临时对象将被释放，因此 JS 会造成错误访问。</p>
<p>同样的，如果用 JSContext 创建了对象，然后在 OC 中用 JSValue 去接收，即使把 JSValue 变量在 OC 中被 retain，但可能因为 JS 中因为变量没有了引用而被释放内存，那么对应的JSValue也没有用了。</p>
<p>所以苹果引入了另一个类来解决这种循环引用的问题。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyButton</span></span>- (<span class="keyword">void</span>)setOnClickHandler:(JSValue *)handler&#123;</div><div class="line">	<span class="comment">//正确的姿势</span>     _onClickHandler = [JSManagedValue managedValueWithValue:handler];     [_context.virtualMachine addManagedReference:_onClickHandler                                        withOwner:<span class="keyword">self</span>]&#125; </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p><code>addManagedReference</code>做的事情主要如下：它创建了一个 garbage collected reference，这种引用既不是强引用也不是弱引用。</p>
<p><img src="http://ww3.sinaimg.cn/large/ba81ca29gw1ew0uh69rcxj21kw0s9gqr.jpg" alt=""></p>
<p>JSManagedValue 本身是一个对 JavaScript Value 的弱引用，而 JSValue 是强引用。addManagedReference 将 JSManagedValue 转换为 garbage collected reference。如果 JS 在垃圾回收过程中能够找到 managed reference 的所有者，那么这个引用将不会被释放，否则将被释放。JSManagedValue 需要调用其addManagedReference:withOwner: 方法把它添加到JSVirtualMachine 中，确保使用过程中 JSValue 不会被释放。</p>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>如前面所说，每一个 JSVirtualMachine 都可以有多个 JScontext，在每个进程中又可以有多个  JSVirtualMachine。JSValue 可以在同一个 JSVirtualMachine 中的不同  JSContext 之间传递，但是不能跨 JSVirtualMachine 来传递。因为每个 JSVirtualMachine 都有自己的内存堆以及垃圾回收器，如果  JSValue 跨 JSVirtualMachine 传递，那么垃圾回收器将不知如何处理来自不同内存堆的 JSvalue。</p>
<ul>
<li>JavaScriptCore 的 API 是线程安全的</li>
<li>同步锁粒度：JSVirtualMachine，即我们可以在 JSVirtualMachine 不同线程中调用 JS，但是如果有线程正在执行 JS，那么其它线程将不能执行 JS 操作。所以要想进行并发操作，那么需要为每个操作创建一个单独的 JSVirtualMachine 来实现并发。</li>
</ul>
<h3 id="WKWebView-iOS8-and-later"><a href="#WKWebView-iOS8-and-later" class="headerlink" title="WKWebView (iOS8 and later)"></a>WKWebView (iOS8 and later)</h3><h4 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h4><ul>
<li>在性能、稳定性、功能方面有很大提升（最直观的体现就是加载网页是占用的内存）；</li>
<li>允许JavaScript的Nitro库加载并使用（UIWebView中限制）；</li>
<li>支持了更多的HTML5特性以及 native 和 web 的高效交互；</li>
<li>高达60fps的滚动刷新率以及内置手势；</li>
<li>将UIWebViewDelegate与UIWebView重构成了14类与3个协议</li>
</ul>
<p>WebKit 为非线程安全的，所以要确保该 framework 的所有方法在主线程上调用。</p>
<p>更多内容请参考<a href="http://nshipster.cn/wkwebkit/" target="_blank" rel="external">Nshipster</a>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总得来说两种方式都可以实现二者的交互，JavaScriptBridge 相对而言复杂一些，但是安全且不需要做版本适配，APP 上架不会被拒，但是 JavaScriptCore 更加简洁，不需要写繁琐的代码，但是有被拒的风险，同时这个框架是在 iOS7 之后才有，所以如果要适配 iOS6的话还是选择 JavaScriptBridge。</p>
<p>本文 <a href="https://github.com/wang9262/WebViewJSDemo" target="_blank" rel="external">Demo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要分析一些 iOS 中 WebView 与 JavaScript 交互的一些框架。&lt;/p&gt;
    
    </summary>
    
      <category term="框架学习" scheme="https://vongloo.me/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="原创" scheme="https://vongloo.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="WebView" scheme="https://vongloo.me/tags/WebView/"/>
    
  </entry>
  
  <entry>
    <title>如何创建一个翻书动画(Part2)[译]</title>
    <link href="https://vongloo.me/2015/09/01/How-to-Create-an-iOS-Book-Open-Animation-part-two-translation/"/>
    <id>https://vongloo.me/2015/09/01/How-to-Create-an-iOS-Book-Open-Animation-part-two-translation/</id>
    <published>2015-09-01T15:11:46.000Z</published>
    <updated>2019-03-03T15:42:37.279Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎回到 iOS 翻书动画教程系列！在该系列的<a href="http://www.raywenderlich.com/94565/how-to-create-an-ios-book-open-animation-part-1" target="_blank" rel="external">第一部分</a>(<a href="http://t.cn/Ry2rWGG" target="_blank" rel="external">译文</a>)，你已经知道如何创建自定义的 layout 以及如何在 app 中使用阴影效果来创建景深和模拟现实。在这篇教程中，你将学到如何创建一个自定义的转场以及如何使用 pinch 手势来打开书本。</p>
<a id="more"></a>
<blockquote>
<p>感谢<a href="https://twitter.com/hegedus90" target="_blank" rel="external">Attila Hegedüs</a>创建了这个棒棒哒示例工程。</p>
</blockquote>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/05/BookOpening.gif" alt=""></p>
<p>原文：<a href="http://www.raywenderlich.com/?p=97690" target="_blank" rel="external">How to Create an iOS Book Open Animation: Part 2</a></p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>这篇教程基于<a href="http://t.cn/Ry2rWGG" target="_blank" rel="external">第一部分</a>。如果你不了解第一部分或者想重新开始，可以下载上一教程的<a href="http://cdn1.raywenderlich.com/wp-content/uploads/2015/05/Part-1-Paper-Completed.zip" target="_blank" rel="external">完整代码</a>。</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/03/VN2_Start.gif" alt=""></p>
<p>在 Xcode 中打开工程。现在你可以选择一本书，然后书本从右滑出(即 push)，这是 UINavigationController 的默认转场行为。但是在这片教程结束的时候，自定义转场看起来像这样：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/02/VN_BookOpening.gif" alt=""></p>
<p>自定义转场将在书本打开和合上的状态转换中进行丝滑的动画过渡，这种方式非常自然，深得我心。<br>来吧，骚年，开撸！</p>
<h2 id="创建自定义导航控制器"><a href="#创建自定义导航控制器" class="headerlink" title="创建自定义导航控制器"></a>创建自定义导航控制器</h2><p>想要实现自定义转场必须创建一个自定义的导航控制器然后实现 UINavigationControllerDelegate 协议。<br>右键 App 分组创建一个继承自 UINavigationController 名为 CustomNavigationController 的类。语言设置为 Swift。</p>
<p>打开CustomNavigationController.swift，用下面代码替换其内容：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomNavigationController</span>: <span class="title">UINavigationController</span>, <span class="title">UINavigationControllerDelegate</span> </span>&#123;</div><div class="line"> </div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">super</span>.viewDidLoad()</div><div class="line">    <span class="comment">//1</span></div><div class="line">    delegate = <span class="keyword">self</span></div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">//2</span></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">navigationController</span><span class="params">(navigationController: UINavigationController, animationControllerForOperation operation: UINavigationControllerOperation, fromViewController fromVC: UIViewController, toViewController toVC: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning</span>? &#123;</div><div class="line">    <span class="keyword">if</span> operation == .<span class="type">Push</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> operation == .<span class="type">Pop</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码主要做了两件事：</p>
<ul>
<li>1.在 viewDidLoad 方法中将代理设置为自身</li>
<li>2.navigationController(_:animationControllerForOperation:fromViewController:toViewController:) 方法是协议方法中的一个。这个方法在每次 push 或者 pop 的时候被调用，你可以在此返回对应的转场类型动画。现在这个方法返回 nil 使得其使用默认的标准转场。马上你就会用你自定义的转场类来替换它。</li>
</ul>
<p>既然导航控制器已经准备就绪，那么让我们开始来替换 storyboard 中默认的导航控制器</p>
<p>设置如下图所示：</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/03/VN_storyboard2.png" alt=""></p>
<p>运行一下，确保能正常运行，一切正常，因为你在代理方法中返回 nil，导致控制器使用默认转场行为。</p>
<h2 id="创建自定义转场"><a href="#创建自定义转场" class="headerlink" title="创建自定义转场"></a>创建自定义转场</h2><p>终于来到重头戏环节————撸一个自定义转场！<br>在自定义转场类中，必须遵循 UIViewControllerAnimatedTransitioning 协议，特别是需要实现下面几个方法：</p>
<ul>
<li>transitionDuration：必须实现。返回转场动画时间，以及同步交互转场动画</li>
<li>animateTransition：必须实现。提供转场过程中的源控制器和目的控制器。自定义转场的工作重心主要是在这个方法中完成</li>
<li>animationEnded：可选实现。在转场结束时调用。可以在该方法中还原之前的设置</li>
</ul>
<h2 id="设置你的转场"><a href="#设置你的转场" class="headerlink" title="设置你的转场"></a>设置你的转场</h2><p>右键 App 分组新建一个继承自 NSObject 名为 BookOpeningTransition 的类，设置语言为 Swift。</p>
<p>打开它，然后用下面代码来替换其所有内容：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"> </div><div class="line"><span class="comment">//1</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookOpeningTransition</span>: <span class="title">NSObject</span>, <span class="title">UIViewControllerAnimatedTransitioning</span> </span>&#123;</div><div class="line"> </div><div class="line">  <span class="comment">// MARK: Stored properties</span></div><div class="line">  <span class="keyword">var</span> transforms = [<span class="type">UICollectionViewCell</span>: <span class="type">CATransform3D</span>]() <span class="comment">//2</span></div><div class="line">  <span class="keyword">var</span> toViewBackgroundColor: <span class="type">UIColor</span>? <span class="comment">//3</span></div><div class="line">  <span class="keyword">var</span> isPush = <span class="literal">true</span> <span class="comment">//4</span></div><div class="line"> </div><div class="line">  <span class="comment">//5</span></div><div class="line">  <span class="comment">// MARK: UIViewControllerAnimatedTransitioning</span></div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">transitionDuration</span><span class="params">(transitionContext: UIViewControllerContextTransitioning)</span></span> -&gt; <span class="type">NSTimeInterval</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span></div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">animateTransition</span><span class="params">(transitionContext: UIViewControllerContextTransitioning)</span></span> &#123;</div><div class="line"> </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每个数字标号注释的解释：</p>
<ul>
<li>1.BookOpeningTransition 实现了 UIViewControllerAnimatedTransitioning 协议</li>
<li>2.字典 transforms 存储了键为 UICollectionViewCell 值为 CATransform3D类型的键值对。当书本打开时，它存储了每个 cell 的 transform</li>
<li>3.定义了目的控制器的背景色，使得渐变看起来更加清爽</li>
<li>4.isPush 决定了转场为 push 还是 pop</li>
<li>5.添加了协议中必须实现的方法避免编译器报错。紧接着就是要实现这些方法</li>
</ul>
<p>一切变量设置就绪，是时候来实现协议方法了。</p>
<p>用下面代码来替换 transitionDuration(_:) 中的内容：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> isPush &#123;</div><div class="line">  <span class="keyword">return</span> <span class="number">1</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法返回了转场动画持续的时间，这里 pop 和 push都返回1秒。这个方法可以轻松改变转场动画的持续时间。<br>接下来需要实现第二个必须是闲的方法——animateTransition，这个方法让一切变得皆有可能。你将分两部分来实现：</p>
<p>写两个工具方法来分别实现 push 和 pop 的animateTransition。</p>
<h2 id="创建-push-转场"><a href="#创建-push-转场" class="headerlink" title="创建 push 转场"></a>创建 push 转场</h2><p>回想一下实际生活中，你翻书的场景：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/03/VN_PushStage.png" alt=""></p>
<p>看起来很复杂，但是你只需要关心动画的两种状态，然后让 UIView 的 animateWithDuration 方法来实现两种状态之间的过渡：</p>
<ul>
<li>1.第一阶段：书被合上</li>
<li>2.第二阶段：书被打开</li>
</ul>
<p>在实现 animateTransition(_:) 前，首先写一个工具方法来处理两种状态。还是在 BookOpeningTransition.swift 中，在最后添加：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MARK: Helper Methods</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">makePerspectiveTransform</span><span class="params">()</span></span> -&gt; <span class="type">CATransform3D</span> &#123;</div><div class="line">  <span class="keyword">var</span> transform = <span class="type">CATransform3DIdentity</span></div><div class="line">  transform.m34 = <span class="number">1.0</span> / -<span class="number">2000</span></div><div class="line">  <span class="keyword">return</span> transform</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法返回一个 transform，以及添加一个 z 轴上的透视。后面动画过程中你将会用到它来改变 view。</p>
<h3 id="第一阶段——书本合起"><a href="#第一阶段——书本合起" class="headerlink" title="第一阶段——书本合起"></a>第一阶段——书本合起</h3><p>接着在上述方法后面添加：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">closePageCell</span><span class="params">(cell : BookPageCell)</span></span> &#123;</div><div class="line">  <span class="comment">// 1</span></div><div class="line">  <span class="keyword">var</span> transform = <span class="keyword">self</span>.makePerspectiveTransform()</div><div class="line">  <span class="comment">// 2</span></div><div class="line">  <span class="keyword">if</span> cell.layer.anchorPoint.x == <span class="number">0</span> &#123;</div><div class="line">    <span class="comment">// 3</span></div><div class="line">    transform = <span class="type">CATransform3DRotate</span>(transform, <span class="type">CGFloat</span>(<span class="number">0</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</div><div class="line">    <span class="comment">// 4</span></div><div class="line">    transform = <span class="type">CATransform3DTranslate</span>(transform, -<span class="number">0.7</span> * cell.layer.bounds.width / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>)</div><div class="line">    <span class="comment">// 5</span></div><div class="line">    transform = <span class="type">CATransform3DScale</span>(transform, <span class="number">0.7</span>, <span class="number">0.7</span>, <span class="number">1</span>)</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 6</span></div><div class="line">   <span class="keyword">else</span> &#123;</div><div class="line">     <span class="comment">// 7</span></div><div class="line">     transform = <span class="type">CATransform3DRotate</span>(transform, <span class="type">CGFloat</span>(-<span class="type">M_PI</span>), <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</div><div class="line">     <span class="comment">// 8</span></div><div class="line">     transform = <span class="type">CATransform3DTranslate</span>(transform, <span class="number">0.7</span> * cell.layer.bounds.width / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>)</div><div class="line">     <span class="comment">// 9</span></div><div class="line">     transform = <span class="type">CATransform3DScale</span>(transform, <span class="number">0.7</span>, <span class="number">0.7</span>, <span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">//10</span></div><div class="line">    cell.layer.transform = transform</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们对每一个页面做了转换使其与书脊对齐，然后翻页时围绕着个轴做旋转来达到真实的翻阅效果。首先你想要书本是合上状态。这个方法使得每个页面平铺在封面的底部。如下图所示：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/03/VN2_ClosedState.png" alt=""></p>
<p>我们来解释一下上面的代码：</p>
<ul>
<li>1.使用之前创建的工具方法初始化一个新的 transform</li>
<li>2.判断页面是否在书脊右侧</li>
<li>3.如果是右侧页面，设其角度为0，使其呈平铺状态</li>
<li>4.将页面居中并位于封面之下</li>
<li>5.使页面的x，y 均乘以0.7.如果你不知道为什么要乘以0.7，回想上一篇教程中你曾将封面缩小到0.7。</li>
<li>6.如果不是右侧页面，那就是左侧页面</li>
<li>7.设置左侧页面角度为180度。</li>
<li>8.使其位于封面之下，并居中</li>
<li>9.同5</li>
<li>10.设置 cell 的 transform</li>
</ul>
<p>现在添加如下代码到上面方法之前：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">setStartPositionForPush</span><span class="params">(fromVC: BooksViewController, toVC: BookViewController)</span></span> &#123;</div><div class="line">  <span class="comment">// 1</span></div><div class="line">  toViewBackgroundColor = fromVC.collectionView?.backgroundColor</div><div class="line">  toVC.collectionView?.backgroundColor = <span class="literal">nil</span></div><div class="line"> </div><div class="line">  <span class="comment">//2</span></div><div class="line">  fromVC.selectedCell()?.alpha = <span class="number">0</span></div><div class="line"> </div><div class="line">  <span class="comment">//3</span></div><div class="line">  <span class="keyword">for</span> cell <span class="keyword">in</span> toVC.collectionView!.visibleCells() <span class="keyword">as</span>! [<span class="type">BookPageCell</span>] &#123;</div><div class="line">    <span class="comment">//4</span></div><div class="line">    transforms[cell] = cell.layer.transform</div><div class="line">    <span class="comment">//5</span></div><div class="line">    closePageCell(cell)</div><div class="line">    cell.updateShadowLayer()</div><div class="line">    <span class="comment">//6</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> indexPath = toVC.collectionView?.indexPathForCell(cell) &#123;</div><div class="line">      <span class="keyword">if</span> indexPath.row == <span class="number">0</span> &#123;</div><div class="line">        cell.shadowLayer.opacity = <span class="number">0</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法设置了第一阶段的转场。它同时使用两个 VC 来做动画：</p>
<ul>
<li>fromVC：即书单 VC</li>
<li>toVC：书页 VC</li>
</ul>
<p>相关解释：</p>
<ul>
<li>1.存储 BooksViewController 的 collectionView 的背景色，设置 BookViewController 中 collectionView 的背景色为 nil</li>
<li>2.隐藏选中书籍的封面，toVC 将会处理封面图片的呈现</li>
<li>3.遍历书本页面</li>
<li>4.保存每个 cell 打开状态下的transform</li>
<li>5.因为书本一开始是合上的，所以需要合上所有页面然后更新阴影层</li>
<li>6.最后忽略封面的阴影</li>
</ul>
<h3 id="第二阶端——打开书籍"><a href="#第二阶端——打开书籍" class="headerlink" title="第二阶端——打开书籍"></a>第二阶端——打开书籍</h3><p>我们已经完成第一阶段的过渡转场，是时候撸一撸第二阶段的了。第二阶段是有闭合到打开的状态。</p>
<p>在 setStartPositionForPush(_:toVC:)) 方法下添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">setEndPositionForPush</span><span class="params">(fromVC: BooksViewController, toVC: BookViewController)</span></span> &#123;</div><div class="line">  <span class="comment">//1</span></div><div class="line">  <span class="keyword">for</span> cell <span class="keyword">in</span> fromVC.collectionView!.visibleCells() <span class="keyword">as</span>! [<span class="type">BookCoverCell</span>] &#123;</div><div class="line">    cell.alpha = <span class="number">0</span></div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">//2</span></div><div class="line">  <span class="keyword">for</span> cell <span class="keyword">in</span> toVC.collectionView!.visibleCells() <span class="keyword">as</span>! [<span class="type">BookPageCell</span>] &#123;</div><div class="line">    cell.layer.transform = transforms[cell]!</div><div class="line">    cell.updateShadowLayer(animated: <span class="literal">true</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析一下上面的代码：</p>
<ul>
<li>1.隐藏所有书的封面，因为我们将展示选中书籍的页面。</li>
<li>2.遍历所有页面然后加载之前保存的打开状态下的 transform</li>
</ul>
<p>当你从 BooksViewController push 到 BookViewController 之后，还原之前的一些设置。</p>
<p>加入以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">cleanupPush</span><span class="params">(fromVC: BooksViewController, toVC: BookViewController)</span></span> &#123;</div><div class="line">  <span class="comment">// Add background back to pushed view controller</span></div><div class="line">  toVC.collectionView?.backgroundColor = toViewBackgroundColor</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>push 完成后将 BookViewController 的背景色设置为你之前保存的背景色，将下面所有东西都隐藏起来。</p>
<h2 id="实现开书转场"><a href="#实现开书转场" class="headerlink" title="实现开书转场"></a>实现开书转场</h2><p>上面所有工具方法已经整装待发，接着我们来实现 push 动画。将下面代码加到 animateTransition(_:) 中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1</span></div><div class="line"><span class="keyword">let</span> container = transitionContext.containerView()</div><div class="line"><span class="comment">//2</span></div><div class="line"><span class="keyword">if</span> isPush &#123;</div><div class="line">  <span class="comment">//3</span></div><div class="line">  <span class="keyword">let</span> fromVC = transitionContext.viewControllerForKey(<span class="type">UITransitionContextFromViewControllerKey</span>) <span class="keyword">as</span>! <span class="type">BooksViewController</span></div><div class="line">  <span class="keyword">let</span> toVC = transitionContext.viewControllerForKey(<span class="type">UITransitionContextToViewControllerKey</span>) <span class="keyword">as</span>! <span class="type">BookViewController</span></div><div class="line">  <span class="comment">//4</span></div><div class="line">  container.addSubview(toVC.view)</div><div class="line"> </div><div class="line">  <span class="comment">// Perform transition</span></div><div class="line">  <span class="comment">//5</span></div><div class="line">  <span class="keyword">self</span>.setStartPositionForPush(fromVC, toVC: toVC)</div><div class="line"> </div><div class="line">  <span class="type">UIView</span>.animateWithDuration(<span class="keyword">self</span>.transitionDuration(transitionContext), delay: <span class="number">0.0</span>, usingSpringWithDamping: <span class="number">0.7</span>, initialSpringVelocity: <span class="number">0.7</span>, options: <span class="literal">nil</span>, animations: &#123;</div><div class="line">    <span class="comment">//6</span></div><div class="line">    <span class="keyword">self</span>.setEndPositionForPush(fromVC, toVC: toVC)</div><div class="line">    &#125;, completion: &#123; finished <span class="keyword">in</span></div><div class="line">      <span class="comment">//7</span></div><div class="line">      <span class="keyword">self</span>.cleanupPush(fromVC, toVC: toVC)</div><div class="line">      <span class="comment">//8</span></div><div class="line">      transitionContext.completeTransition(finished)</div><div class="line">  &#125;)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">//POP</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面解释一下上面代码做了哪些事：</p>
<ul>
<li>1.获取容器视图，它在转场过程中充当父视图角色。</li>
<li>2.判断当前是执行 push 操作</li>
<li>3.获取 fromVC 和 toVC</li>
<li>4.将 toVC 加入到当前容器视图</li>
<li>5.设置闭合状态下 toVC 和 fromVC 的起始位置</li>
<li>6.从起始位置做动画，直到终点位置</li>
<li>7.还原设置</li>
<li>8.告知系统转场已完成</li>
</ul>
<h2 id="在导航控制器中使用-push-转场"><a href="#在导航控制器中使用-push-转场" class="headerlink" title="在导航控制器中使用 push 转场"></a>在导航控制器中使用 push 转场</h2><p>上面我们已经实现了 push 转场动画，是时候来使用它了。打开 BooksViewController.swift 将下面属性添加到类声明之后：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> transition: <span class="type">BookOpeningTransition</span>?</div></pre></td></tr></table></figure>
<p>这个属性是转场类实例，它帮助你判断当前转场是 push 还是 pop。添加如下扩展：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">BooksViewController</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">animationControllerForPresentController</span><span class="params">(vc: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning</span>? &#123;</div><div class="line">  <span class="comment">// 1</span></div><div class="line">  <span class="keyword">var</span> transition = <span class="type">BookOpeningTransition</span>()</div><div class="line">  <span class="comment">// 2</span></div><div class="line">  transition.isPush = <span class="literal">true</span></div><div class="line">  <span class="comment">// 3</span></div><div class="line">  <span class="keyword">self</span>.transition = transition</div><div class="line">  <span class="comment">// 4</span></div><div class="line">  <span class="keyword">return</span> transition</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>1.创建一个 transition</li>
<li>2.设置 isPush 为 true</li>
<li>3&amp;4.保存当前 transition，返回 transition</li>
</ul>
<p>接着打开 CustomNavigationController.swift 用下面代码替换 push 的 if 判断</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> operation == .<span class="type">Push</span> &#123;</div><div class="line">  <span class="keyword">if</span> <span class="keyword">let</span> vc = fromVC <span class="keyword">as</span>? <span class="type">BooksViewController</span> &#123;</div><div class="line">    <span class="keyword">return</span> vc.animationControllerForPresentController(toVC)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这一步判断判断是否从 BooksViewController 中 push 过来的，然后用你创建的 BookOpeningTransition 来做转场展示你的 BookViewController。</p>
<p>运行，选中某本书你会看到，书本在开、合之间的动画非常顺畅。</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/03/VN_PushGlitch.gif" alt=""></p>
<p>WTF…这货看起来没有动画？！</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/03/angry-desk-flip.png" alt=""></p>
<p>它直接从闭合状态跳转到打开状态，不要慌，这是因为你还没有加载页面 cell。<br>导航控制器从 BooksViewController 过渡到 BookViewController，他们两个都是继承自 UICollectionViewController。UICollectionViewCell 没有在主线程中加载，所以没有动画过程。<br>你需要给 collectionView 足够的时间让它来加载所有的 cell。<br>打开 BooksViewController.swift 然后使用下面代码替换 openBook(_:)：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func openBook(book: Book?) &#123;</div><div class="line">  let vc = storyboard?.instantiateViewControllerWithIdentifier(<span class="string">"BookViewController"</span>) as! BookViewController</div><div class="line">  vc.book = selectedCell()?.book</div><div class="line">  <span class="comment">//1</span></div><div class="line">  vc.view.snapshotViewAfterScreenUpdates(<span class="literal">true</span>)</div><div class="line">  <span class="comment">//2</span></div><div class="line">  <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), &#123; () -&gt; Void <span class="keyword">in</span></div><div class="line">    <span class="keyword">self</span>.navigationController?.pushViewController(vc, animated: <span class="literal">true</span>)</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面说下是如何解决这个问题的：</p>
<ul>
<li>1.当转场要发生时告诉 BookViewController 去截取当前视图</li>
<li>2.确定是在主线程中 push，来给 cell 足够的时间进行加载</li>
</ul>
<p>运行程序，应该和下图类似：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/03/VN_PushGlitchAnimate.gif" alt=""></p>
<p>看起来更完美了。至此 push 的转场已经完成，继续撸 pop 的转场。</p>
<h2 id="实现-Pop-转场的工具方法"><a href="#实现-Pop-转场的工具方法" class="headerlink" title="实现 Pop 转场的工具方法"></a>实现 Pop 转场的工具方法</h2><p>pop 的过程和 push 过程刚好相反。第一阶段是书打开状态，第二阶段是书本闭合状态。</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/03/VN_PopState.png" alt=""></p>
<p>打开 BookOpeningTransition.swift 添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MARK: Pop methods</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">setStartPositionForPop</span><span class="params">(fromVC: BookViewController, toVC: BooksViewController)</span></span> &#123;</div><div class="line">  <span class="comment">// Remove background from the pushed view controller</span></div><div class="line">  toViewBackgroundColor = fromVC.collectionView?.backgroundColor</div><div class="line">  fromVC.collectionView?.backgroundColor = <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法存储了 BookViewController 的背景色然后移除了 BooksViewController 中 collectionView 的背景色。我们不需要设置任何的 transform，因为书本当前状态就是打开状态。<br>接下来添加如下代码到上述代码之后：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">setEndPositionForPop</span><span class="params">(fromVC: BookViewController, toVC: BooksViewController)</span></span> &#123;</div><div class="line">  <span class="comment">//1</span></div><div class="line">  <span class="keyword">let</span> coverCell = toVC.selectedCell()</div><div class="line">  <span class="comment">//2</span></div><div class="line">  <span class="keyword">for</span> cell <span class="keyword">in</span> toVC.collectionView!.visibleCells() <span class="keyword">as</span>! [<span class="type">BookCoverCell</span>] &#123;</div><div class="line">    <span class="keyword">if</span> cell != coverCell &#123;</div><div class="line">      cell.alpha = <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">  &#125;      </div><div class="line">  <span class="comment">//3</span></div><div class="line">  <span class="keyword">for</span> cell <span class="keyword">in</span> fromVC.collectionView!.visibleCells() <span class="keyword">as</span>! [<span class="type">BookPageCell</span>] &#123;</div><div class="line">    closePageCell(cell)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法设置 pop 转场的最终状态：</p>
<ul>
<li>1.获取当前选中书本的封面</li>
<li>2.在书本闭合状态，遍历 BooksViewController 所有书本封面，然后渐显</li>
<li>3.遍历 BookViewController 中所有的 cell，然后将它们转换成闭合态</li>
</ul>
<p>然后加入以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">cleanupPop</span><span class="params">(fromVC: BookViewController, toVC: BooksViewController)</span></span> &#123;</div><div class="line">  <span class="comment">// Add background back to pushed view controller</span></div><div class="line">  fromVC.collectionView?.backgroundColor = <span class="keyword">self</span>.toViewBackgroundColor</div><div class="line">  <span class="comment">// Unhide the original book cover</span></div><div class="line">  toVC.selectedCell()?.alpha = <span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法在 pop 转场结束后做了一些还原工作。主要是将 BooksViewController 的 collectionView 的背景色还原成之前的状态，以及展示之前的书本封面。<br>把下面代码加到代理方法 animateTransition(_:) 中的 带有 <code>//POP</code> 注释的 else 大括号内。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1</span></div><div class="line"><span class="keyword">let</span> fromVC = transitionContext.viewControllerForKey(<span class="type">UITransitionContextFromViewControllerKey</span>) <span class="keyword">as</span>! <span class="type">BookViewController</span></div><div class="line"><span class="keyword">let</span> toVC = transitionContext.viewControllerForKey(<span class="type">UITransitionContextToViewControllerKey</span>) <span class="keyword">as</span>! <span class="type">BooksViewController</span></div><div class="line"> </div><div class="line"><span class="comment">//2</span></div><div class="line">container.insertSubview(toVC.view, belowSubview: fromVC.view)</div><div class="line"> </div><div class="line"><span class="comment">//3</span></div><div class="line">setStartPositionForPop(fromVC, toVC: toVC)</div><div class="line"><span class="type">UIView</span>.animateWithDuration(<span class="keyword">self</span>.transitionDuration(transitionContext), animations: &#123;</div><div class="line">  <span class="comment">//4</span></div><div class="line">  <span class="keyword">self</span>.setEndPositionForPop(fromVC, toVC: toVC)</div><div class="line">&#125;, completion: &#123; finished <span class="keyword">in</span></div><div class="line">  <span class="comment">//5</span></div><div class="line">  <span class="keyword">self</span>.cleanupPop(fromVC, toVC: toVC)</div><div class="line">  <span class="comment">//6</span></div><div class="line">  transitionContext.completeTransition(finished)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>下面解释下 pop 转场动画的工作原理：</p>
<ul>
<li>1.获取转场过程中的控制器。fromVC 现在变成了 BookViewController，toVC 变成了 BooksViewController。</li>
<li>2.在 containerView 中把 BooksViewController 的视图放置到 BookViewController 视图下面。</li>
<li>3.setStartPositionForPop(_:toVC) 方法存储了背景色</li>
<li>4.用动画形式将书本有打开状态转换到闭合状态</li>
<li>5.动画完成则做还原设置，将背景色设置为之前保存的，然后显示书本封面</li>
<li>6.通知转场完成</li>
</ul>
<h2 id="在导航控制器中使用-pop-转场"><a href="#在导航控制器中使用-pop-转场" class="headerlink" title="在导航控制器中使用 pop 转场"></a>在导航控制器中使用 pop 转场</h2><p>现在让我们像之前添加自定义 push 动画那样将 pop 动画也加入到代理方法中去。<br>打开 BooksViewController.swift 然后在 animationControllerForPresentController(_:) 方法后添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">animationControllerForDismissController</span><span class="params">(vc: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning</span>? &#123;</div><div class="line">  <span class="keyword">var</span> transition = <span class="type">BookOpeningTransition</span>()</div><div class="line">  transition.isPush = <span class="literal">false</span></div><div class="line">  <span class="keyword">self</span>.transition = transition</div><div class="line">  <span class="keyword">return</span> transition</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法同样创建一个 BookOpeningTransition 实例，唯一不同的是其 transition 设置为 pop。<br>打开 CustomNavigationController.swift 用下面代码替换之前的 if 逻辑：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> operation == .<span class="type">Pop</span> &#123;</div><div class="line">  <span class="keyword">if</span> <span class="keyword">let</span> vc = toVC <span class="keyword">as</span>? <span class="type">BooksViewController</span> &#123;</div><div class="line">    <span class="keyword">return</span> vc.animationControllerForDismissController(vc)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它返回一个 transition，然后执行 pop 动画来把书合上。<br>运行程序，选中一本书，看下它的打开和闭合状态，应该和下图类似：</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/03/VN_OpenAndClose.gif" alt=""></p>
<h2 id="创建一个可交互的导航控制器"><a href="#创建一个可交互的导航控制器" class="headerlink" title="创建一个可交互的导航控制器"></a>创建一个可交互的导航控制器</h2><p>打开和关闭转场动画看起来非常屌，但是你可以做得更好。你可以使用 pinch 手势来控制书的开、合。<br>首先打开 BookOpeningTransition.swift 添加如下属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MARK: Interaction Controller</span></div><div class="line"><span class="keyword">var</span> interactionController: <span class="type">UIPercentDrivenInteractiveTransition</span>?</div></pre></td></tr></table></figure>
<p>接着打开 CustomNavigationController.swift 然后添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">navigationController</span><span class="params">(navigationController: UINavigationController, interactionControllerForAnimationController animationController: UIViewControllerAnimatedTransitioning)</span></span> -&gt; <span class="type">UIViewControllerInteractiveTransitioning</span>? &#123;</div><div class="line">  <span class="keyword">if</span> <span class="keyword">let</span> animationController = animationController <span class="keyword">as</span>? <span class="type">BookOpeningTransition</span> &#123;</div><div class="line">    <span class="keyword">return</span> animationController.interactionController</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述方法返回一个可交互的动画对象。它使得导航控制器控制着整个动画过程，这样用户就可以使用 pinch 手势来控制书本的开、合。<br>打开 BooksViewController.swift 在transition 变量下添加如下属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1</span></div><div class="line"><span class="keyword">var</span> interactionController: <span class="type">UIPercentDrivenInteractiveTransition</span>?</div><div class="line"><span class="comment">//2</span></div><div class="line"><span class="keyword">var</span> recognizer: <span class="type">UIGestureRecognizer</span>? &#123;</div><div class="line">  <span class="keyword">didSet</span> &#123;</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> recognizer = recognizer &#123;</div><div class="line">      collectionView?.addGestureRecognizer(recognizer)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面解释为什么要添加这几个变量：</p>
<ul>
<li>1.interactionController 是一个 UIPercentDrivenInteractiveTransition 实例，它管理 VC 转场过程中自定义动画的出现和消失。这个可交互控制器同样依赖一个 transition animator。这个 animator 实现了 UIViewControllerAnimatorTransitioning 协议，你刚才创建的 BookOpeningTransition 就是干这件事的。iteractionController 可以控制 push 和 pop 的过程，如果想要了解更多细节可以参考<a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIPercentDrivenInteractiveTransition_class/index.html#//apple_ref/occ/instm/UIPercentDrivenInteractiveTransition/cancelInteractiveTransition" target="_blank" rel="external">苹果官方文档</a>。</li>
<li>2.recognizer 是一个 UIGestureRecognizer 实例。你可以使用它来控制书本的开、合。</li>
</ul>
<p>在 BooksViewController 扩展中的 animationControllerForPresentController(_:) 方法中添加如下代码，将其放在 transition.isPush = true 这一行之后：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">transition.interactionController = interactionController</div></pre></td></tr></table></figure>
<p>这行代码让自定义导航控制器知道使用那一个交互控制器。<br>同样把上面在添加到  animationControllerForDismissController(_:) 方法中 transition.isPush = false 之后。<br>紧接着在 viewDidLoad() 中加入下面一行代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">recognizer = <span class="type">UIPinchGestureRecognizer</span>(target: <span class="keyword">self</span>, action: <span class="string">"handlePinch:"</span>)</div></pre></td></tr></table></figure>
<p>它初始化了一个 UIPinchGestureRecognizer 实例，这个 pinch 手势的 action 是 handlePinch(_:)。</p>
<p>现在我们来实现 handlePinch(_:) 这个方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MARK: Gesture recognizer action</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">handlePinch</span><span class="params">(recognizer: UIPinchGestureRecognizer)</span></span> &#123;</div><div class="line">  <span class="keyword">switch</span> recognizer.state &#123;</div><div class="line">    <span class="keyword">case</span> .<span class="type">Began</span>:</div><div class="line">      <span class="comment">//1</span></div><div class="line">      interactionController = <span class="type">UIPercentDrivenInteractiveTransition</span>()</div><div class="line">      <span class="comment">//2</span></div><div class="line">      <span class="keyword">if</span> recognizer.scale &gt;= <span class="number">1</span> &#123;</div><div class="line">        <span class="comment">//3</span></div><div class="line">        <span class="keyword">if</span> recognizer.view == collectionView &#123;</div><div class="line">          <span class="comment">//4</span></div><div class="line">          <span class="keyword">var</span> book = <span class="keyword">self</span>.selectedCell()?.book</div><div class="line">          <span class="comment">//5</span></div><div class="line">          <span class="keyword">self</span>.openBook(book)</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//6</span></div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//7</span></div><div class="line">        navigationController?.popViewControllerAnimated(<span class="literal">true</span>)</div><div class="line">      &#125;        </div><div class="line">    <span class="keyword">case</span> .<span class="type">Changed</span>:</div><div class="line">      <span class="comment">//8</span></div><div class="line">      <span class="keyword">if</span> transition!.isPush &#123;</div><div class="line">        <span class="comment">//9</span></div><div class="line">        <span class="keyword">var</span> progress = <span class="built_in">min</span>(<span class="built_in">max</span>(<span class="built_in">abs</span>((recognizer.scale - <span class="number">1</span>)) / <span class="number">5</span>, <span class="number">0</span>), <span class="number">1</span>)</div><div class="line">        <span class="comment">//10</span></div><div class="line">	interactionController?.updateInteractiveTransition(progress)</div><div class="line">	<span class="comment">//11</span></div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//12</span></div><div class="line">	<span class="keyword">var</span> progress = <span class="built_in">min</span>(<span class="built_in">max</span>(<span class="built_in">abs</span>((<span class="number">1</span> - recognizer.scale)), <span class="number">0</span>), <span class="number">1</span>)</div><div class="line">        <span class="comment">//13</span></div><div class="line">	interactionController?.updateInteractiveTransition(progress)</div><div class="line">      &#125; </div><div class="line">    <span class="keyword">case</span> .<span class="type">Ended</span>:</div><div class="line">      <span class="comment">//14</span></div><div class="line">      interactionController?.finishInteractiveTransition()</div><div class="line">      <span class="comment">//15</span></div><div class="line">      interactionController = <span class="literal">nil</span></div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="keyword">break</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于 UIPinchGestureRecognizer，我们关心三种不同的状态：began，changed，end。</p>
<p><strong>begin状态</strong></p>
<ul>
<li>1.初始化一个 UIPercentDrivenInteractiveTransition 对象</li>
<li>2.判断 scale， 也就是 pinch 手势移动的距离，看起是否大于等于1</li>
<li>3.如果是，确保手势发生在 colletionView 当中</li>
<li>4.获取当前手势所作用的书脊</li>
<li>5.执行 push 转场动画，显示书籍页面</li>
<li>6.如果小于1</li>
<li>7.执行 pop 动画来展示书本封面</li>
</ul>
<p><strong>changed 状态</strong></p>
<ul>
<li>8.判断当前转场是否为 push</li>
<li>9.如果正 push 到 BookViewController，获取用户 pinch 手势的百分比。将 pinch 手势缩小为其原始值的 1/5，这样用户更加容易控制转场过程</li>
<li>10.根据之前计算的白封闭更新 transition 完成状态的百分比。</li>
<li>11.如果当前转场不是 push，那肯定是 pop</li>
<li>12.当使用 pinch 手势控制书本关闭时，缩放比一定是从1变到0</li>
<li>13.最后更新 transition 的进度</li>
</ul>
<p><strong>end 状态</strong></p>
<ul>
<li>14.通知系统用户转场交互已完成</li>
<li>15.将交互 controller 置为 nil</li>
</ul>
<p>最后，你需要实现 pinch-to-closed 状态。因此你需要将手势传递给 BookViewController，这样他就能自发进行 pop。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> recognizer: <span class="type">UIGestureRecognizer</span>? &#123;</div><div class="line">  <span class="keyword">didSet</span> &#123;</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> recognizer = recognizer &#123;</div><div class="line">      collectionView?.addGestureRecognizer(recognizer)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当你在 BookViewController 中设置好手势时，它会马上被加到 collectionView 中区，这样我们就可以在用户合上书本的时候追踪 pinch 手势。<br>下面需要在 BooksViewController 和 BookViewController 之间进行手势的传递。<br>打开 BookOpeningTransition.swift 添加下面一行代码到 cleanUpPush(_:toVC) 方法中，并且将它放在设置背景色之后：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Pass the gesture recognizer</span></div><div class="line">toVC.recognizer = fromVC.recognizer</div></pre></td></tr></table></figure>
<p>当从 BooksViewController push 到 BookViewController后，你需要将手势回传。<br>加入下面代码到 cleanUpPop(_:toVC) 方法中，同样是放在设置背景色之后：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Pass the gesture recognizer</span></div><div class="line">toVC.recognizer = fromVC.recognizer</div></pre></td></tr></table></figure>
<p>运行程序，选中任意一本书然后使用 pinch 手势来控制书本的开、合。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/03/VN_Pinching.gif" alt=""></p>
<p>用 pinch 收拾来控制书本的开合显得非常自然，同样可以让界面更加简洁，我们不再需要导航栏上的返回按钮，是时候来清理它了。</p>
<p>如下图设置即可：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/03/Screen-Shot-2015-03-14-at-1.16.36-PM.png" alt=""></p>
<p>继续运行，可以看到导航栏不复存在画面变得更加简洁！:]</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/02/VN_BookOpening.gif" alt=""></p>
<h2 id="何去何从"><a href="#何去何从" class="headerlink" title="何去何从"></a>何去何从</h2><p>你可以在此下载<a href="http://cdn3.raywenderlich.com/wp-content/uploads/2015/05/Part-2-Paper-Completed_Final.zip" target="_blank" rel="external">完整代码</a>。在这系列教程中，你学会了如何使用自定义布局、自定义转场、使用手势来控制转场交互。<br>我希望你喜欢这篇教程并从中受益，我想在此感谢<a href="https://twitter.com/hegedus90" target="_blank" rel="external">Attila Hegedüs</a>创建了这个碉堡的项目。<br>如有任何疑问，请在下面留言指出。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;欢迎回到 iOS 翻书动画教程系列！在该系列的&lt;a href=&quot;http://www.raywenderlich.com/94565/how-to-create-an-ios-book-open-animation-part-1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;第一部分&lt;/a&gt;(&lt;a href=&quot;http://t.cn/Ry2rWGG&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;译文&lt;/a&gt;)，你已经知道如何创建自定义的 layout 以及如何在 app 中使用阴影效果来创建景深和模拟现实。在这篇教程中，你将学到如何创建一个自定义的转场以及如何使用 pinch 手势来打开书本。&lt;/p&gt;
    
    </summary>
    
      <category term="翻译" scheme="https://vongloo.me/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="UICollectionView" scheme="https://vongloo.me/tags/UICollectionView/"/>
    
      <category term="翻译" scheme="https://vongloo.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>如何创建一个翻书动画(Part 1)[译]</title>
    <link href="https://vongloo.me/2015/08/31/How-to-Create-an-iOS-Book-Open-Animation-part-one-translation/"/>
    <id>https://vongloo.me/2015/08/31/How-to-Create-an-iOS-Book-Open-Animation-part-one-translation/</id>
    <published>2015-08-31T15:21:41.000Z</published>
    <updated>2019-03-03T15:42:37.279Z</updated>
    
    <content type="html"><![CDATA[<p>在这个分两部分的教程系列中，你将开发一个漂亮的 iOS 打开及翻书动画，类似于<a href="https://www.fiftythree.com/paper" target="_blank" rel="external">Paper by FiftyThree</a>：</p>
<a id="more"></a>
<ul>
<li>第一部分，你将学习如何自定义 UICollectionViewLayout，然后使用景深和阴影来让 app 看起来更加真实。</li>
<li><a href="http://www.raywenderlich.com/?p=97690" target="_blank" rel="external">第二部分</a>(<a href="http://t.cn/Ry2rYj5" target="_blank" rel="external">译文</a>)，你将学习创建自定义的转场动画，然后集成手势来创建自然、简洁的 view 之间的转场。</li>
</ul>
<p>原文：<a href="http://www.raywenderlich.com/94565/how-to-create-an-ios-book-open-animation-part-1" target="_blank" rel="external">How to Create an iOS Book Open Animation: Part 1</a></p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/05/BookOpening.gif" alt=""></p>
<p>本教程主要针对于进阶中的开发者，讲解一些自定义转场以及自定义 collectionView Layout 相关的知识。<br>如果你之前没有用过 collectionView，那么建议你先看看其他关于 collectionView 的<a href="http://www.raywenderlich.com/tutorials" target="_blank" rel="external">教程</a>。</p>
<blockquote>
<p>感谢<a href="https://twitter.com/hegedus90" target="_blank" rel="external">Attila Hegedüs</a>创建了这个棒棒哒示例工程。</p>
</blockquote>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>下载<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2015/05/Starter-Paper1.zip" target="_blank" rel="external">模板</a>，解压，在 Xcode 中打开。使用模拟器运行程序，将得到如下画面：</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/02/VN_paperAnimation2.gif" alt=""></p>
<p>这个应用已经初具其功能，你可以滑动书库然后选中你喜欢的书来翻阅。上一次你一页一页翻看书籍是什么时候？在现有对 collectionView 了解的基础上，你可以美化页面视图。</p>
<h2 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h2><p>下面是快速对初始工程重要方面的一个简要描述：<br>Data Model 文件夹包含三个文件：</p>
<ul>
<li>Books.plist：包含样书数据。每本书都含有一个图片封面以及一系列的书页图片</li>
<li>BookStore.swift：单例，主要工作就是从 Books.plist 中加载数据然后创建 Book 对象。</li>
<li>Book.swift：存储书本相关信息的类</li>
</ul>
<p>Books 文件夹包含两个文件：</p>
<ul>
<li>BooksViewController.swift：UICollectionViewController的子类，主要负责展示书单</li>
<li>BookCoverCell.swift：展示所有书的封面，在BooksViewController使用。</li>
</ul>
<p>Book 文件夹包含下面几个文件：</p>
<ul>
<li>BookViewController.swift：也是UICollectionViewController的子类，用来展示BooksViewController中选中的某一本书的内容页面</li>
<li>BookPageCell.swift：用来展示书的所有页面，在BookViewController中使用。</li>
</ul>
<p>最后一个文件夹 Helper 中包含：</p>
<ul>
<li>UIImage+Helpers.swift：是 UIImage 的一个扩展。里面有两个工具方法，一个用来圆角化图片，另一个用来缩放图片到指定大小。</li>
</ul>
<p>以上就是整个工程的目录结构。现在让我们开始撸代码吧！</p>
<h2 id="自定义-Book-布局"><a href="#自定义-Book-布局" class="headerlink" title="自定义 Book 布局"></a>自定义 Book 布局</h2><p>首先你需要为BooksViewController的 collectionView复写默认的布局，默认布局显示3个大的书本封面，它们几乎占据整个屏幕。你需要缩小它们来让它看起来更舒服，像这样：</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/02/VN_AnimationBooksScrolling.gif" alt=""></p>
<p>在你滑动的过程中，最接近屏幕中心的封面将会变大一些来表示它当前被选中。继续滑动，封面将会变小，这意味着你将它移到一边即远离屏幕中心。<br>在 App\Books 下创建一个名为 Layout 的分组，然后右击 Layout 文件夹选择新建文件，然后创建一个继承自UICollectionViewFlowLayout的子类，取名为BooksLayout，语言为 Swift。<br>接下来你需要告诉BooksViewController的 collectionView 使用你新建的 Layout。<br>打开Main.storyboard，选中BooksViewController的Collection View然后在右侧的Attributes Inspector将 layout 设置为 Custom，Class 设置为 BooksLayout，如下图所示：</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/03/VN_BooksLayoutStoryboard.png" alt=""></p>
<p>打开BooksLayout.swift，在BooksLayout类声明上面添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">let</span> <span class="type">PageWidth</span>: <span class="type">CGFloat</span> = <span class="number">362</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">let</span> <span class="type">PageHeight</span>: <span class="type">CGFloat</span> = <span class="number">568</span></div></pre></td></tr></table></figure>
<p>这两个常量将被用来设置 cell 的 size。<br>接着添加下面初始化方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">required</span> <span class="keyword">init</span>(coder aDecoder: <span class="type">NSCoder</span>) &#123;</div><div class="line">  <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</div><div class="line"> </div><div class="line">  scrollDirection = <span class="type">UICollectionViewScrollDirection</span>.<span class="type">Horizontal</span> <span class="comment">//1</span></div><div class="line">  itemSize = <span class="type">CGSizeMake</span>(<span class="type">PageWidth</span>, <span class="type">PageHeight</span>) <span class="comment">//2</span></div><div class="line">  minimumInteritemSpacing = <span class="number">10</span> <span class="comment">//3</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是关于1，2，3的解释：</p>
<ul>
<li>1.设置滑动方向为水平</li>
<li>2.设置 cell 的页面宽度为362，高度为568</li>
<li>3.设置 cell 减最小间距为10</li>
</ul>
<p>接下来，在<code>init(coder:)</code>后面添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareLayout</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">super</span>.prepareLayout()</div><div class="line"> </div><div class="line">  <span class="comment">//The rate at which we scroll the collection view.</span></div><div class="line">  <span class="comment">//1</span></div><div class="line">  collectionView?.decelerationRate = <span class="type">UIScrollViewDecelerationRateFast</span></div><div class="line"> </div><div class="line">  <span class="comment">//2</span></div><div class="line">  collectionView?.contentInset = <span class="type">UIEdgeInsets</span>(</div><div class="line">    top: <span class="number">0</span>,</div><div class="line">    <span class="keyword">left</span>: collectionView!.bounds.width / <span class="number">2</span> - <span class="type">PageWidth</span> / <span class="number">2</span>,</div><div class="line">    bottom: <span class="number">0</span>,</div><div class="line">    <span class="keyword">right</span>: collectionView!.bounds.width / <span class="number">2</span> - <span class="type">PageWidth</span> / <span class="number">2</span></div><div class="line">  )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>prepareLayout()</code>让你有机会在获取布局信息前进行一系列运算。下面是对每个数字注释的解释：</p>
<ul>
<li>1.设置用户手指移开后collectionView 的减速速率。通过设置其值为UIScrollViewDecelerationRateFast，colletionView 将会更快速的停止滑动。也可以尝试以下Normal来查看以下对比。</li>
<li>2.设置 contentInset，让第一本书的封面一直居中。</li>
</ul>
<p>现在你需要位没一个 cell 处理布局信息。<br>在<code>prepareLayout()</code>方法下面添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutAttributesForElementsInRect</span><span class="params">(rect: CGRect)</span></span> -&gt; [<span class="type">AnyObject</span>]? &#123;</div><div class="line">  <span class="comment">//1</span></div><div class="line">  <span class="keyword">var</span> array = <span class="keyword">super</span>.layoutAttributesForElementsInRect(rect) <span class="keyword">as</span>! [<span class="type">UICollectionViewLayoutAttributes</span>]</div><div class="line"> </div><div class="line">  <span class="comment">//2</span></div><div class="line">  <span class="keyword">for</span> attributes <span class="keyword">in</span> array &#123;</div><div class="line">    <span class="comment">//3</span></div><div class="line">    <span class="keyword">var</span> frame = attributes.frame</div><div class="line">    <span class="comment">//4</span></div><div class="line">    <span class="keyword">var</span> <span class="built_in">distance</span> = <span class="built_in">abs</span>(collectionView!.contentOffset.x + collectionView!.contentInset.<span class="keyword">left</span> - frame.origin.x)</div><div class="line">    <span class="comment">//5</span></div><div class="line">    <span class="keyword">var</span> scale = <span class="number">0.7</span> * <span class="built_in">min</span>(<span class="built_in">max</span>(<span class="number">1</span> - <span class="built_in">distance</span> / (collectionView!.bounds.width), <span class="number">0.75</span>), <span class="number">1</span>)</div><div class="line">    <span class="comment">//6</span></div><div class="line">    attributes.transform = <span class="type">CGAffineTransformMakeScale</span>(scale, scale)</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> array</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>layoutAttributesForElementsInRect(_:)返回一个包含了多个UICollectionViewLayoutAttributes对象的数组，这些对象为每个 cell 提供布局属性。下面是对代码的拆分：</p>
<ul>
<li>1.调用父类的layoutAttributesForElementsInRect方法来获取每个 cell 默认的布局属性</li>
<li>2.遍历数组中的每个属性</li>
<li>3.获取当前 cell 布局属性的 frame</li>
<li>4.计算封面与屏幕中心的距离</li>
<li>5.根据4中的距离来改变封面的 scale，使其在0.75到1之间，最后在乘以一个系数0.7让它看起来更舒服</li>
<li>6.最后让封面使用设置后的 scale</li>
</ul>
<p>紧接着在<code>layoutAttributesForElementsInRect(_:)</code>之后添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">shouldInvalidateLayoutForBoundsChange</span><span class="params">(newBounds: CGRect)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>返回 true 表示在每一次 collectionView bounds 发生改变时强制让 layout 去重新计它的布局属性。collectionView 在滑动过程中 bounds 会发生改变，这使得重计算 cell 的布局属性变得很方便。</p>
<p>运行程序，将会发现中间的封面会比其他的大。</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/03/VN_NotSnappy.gif" alt=""></p>
<p>滑动来查看每个封面是如何放大和缩小的。但是如果书籍吸附在相应位置是不是更好呢？接下来我们就来实现这个。</p>
<h2 id="书本吸附"><a href="#书本吸附" class="headerlink" title="书本吸附"></a>书本吸附</h2><p><code>targetContentOffsetForProposedContentOffset(_:withScrollingVelocity:)</code>决定<code>collectionView</code>停在什么位置，然后返回一个<code>offset</code>来设置 <code>collectionView</code> 的 <code>contentOffset</code>。如果不复写这个方法，则返回默认的 offset。在<code>shouldInvalidateLayoutForBoundsChange(_:)</code>后面添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">targetContentOffsetForProposedContentOffset</span><span class="params">(proposedContentOffset: CGPoint, withScrollingVelocity velocity: CGPoint)</span></span> -&gt; <span class="type">CGPoint</span> &#123;</div><div class="line">  <span class="comment">// Snap cells to centre</span></div><div class="line">  <span class="comment">//1</span></div><div class="line">  <span class="keyword">var</span> newOffset = <span class="type">CGPoint</span>()</div><div class="line">  <span class="comment">//2</span></div><div class="line">  <span class="keyword">var</span> layout = collectionView!.collectionViewLayout <span class="keyword">as</span>! <span class="type">UICollectionViewFlowLayout</span></div><div class="line">  <span class="comment">//3</span></div><div class="line">  <span class="keyword">var</span> width = layout.itemSize.width + layout.minimumLineSpacing</div><div class="line">  <span class="comment">//4</span></div><div class="line">  <span class="keyword">var</span> offset = proposedContentOffset.x + collectionView!.contentInset.<span class="keyword">left</span></div><div class="line"> </div><div class="line">  <span class="comment">//5</span></div><div class="line">  <span class="keyword">if</span> velocity.x &gt; <span class="number">0</span> &#123;</div><div class="line">    <span class="comment">//ceil returns next biggest number</span></div><div class="line">    offset = width * ceil(offset / width)</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> velocity.x == <span class="number">0</span> &#123; <span class="comment">//6</span></div><div class="line">    <span class="comment">//rounds the argument</span></div><div class="line">    offset = width * round(offset / width)</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> velocity.x &lt; <span class="number">0</span> &#123; <span class="comment">//7</span></div><div class="line">    <span class="comment">//removes decimal part of argument</span></div><div class="line">    offset = width * floor(offset / width)</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//8</span></div><div class="line">  newOffset.x = offset - collectionView!.contentInset.<span class="keyword">left</span></div><div class="line">  newOffset.y = proposedContentOffset.y <span class="comment">//y will always be the same...</span></div><div class="line">  <span class="keyword">return</span> newOffset</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在用户手指离开屏幕时，该方法将会计算书本封面的 offset。</p>
<ul>
<li>1.创建一个名为 newOffset 的 CGPoint</li>
<li>2.获取当前 collectionView 的 layout</li>
<li>3.获取 cell 的宽度</li>
<li>4.计算当前offset</li>
<li>5.如果 velocity.x &gt; 0,用户是在向右滑。把 offset/width 理解成书本的 index，滑至对应的 index</li>
<li>6.如果 velocity.x = 0,用户滑动距离不够，保持上衣吃选中的书不变</li>
<li>7.如果 velocity.x &lt; 0,用户向左滑</li>
<li>8.更新 x 的 offset，然后返回。保证书的封面居中显示</li>
</ul>
<p>运行程序，滑动一下，你会发现滑动过程中书本，吸附效果更明显了。<br>你需要建立一种机制来使得用户只能点击居中的书本，然而现在不管书本在哪，你都可以点击。<br>打开BooksViewController.swift，将下面代码加到<code>// MARK: Helpers</code>注释下方：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectedCell</span><span class="params">()</span></span> -&gt; <span class="type">BookCoverCell</span>? &#123;</div><div class="line">  <span class="keyword">if</span> <span class="keyword">let</span> indexPath = collectionView?.indexPathForItemAtPoint(<span class="type">CGPointMake</span>(collectionView!.contentOffset.x + collectionView!.bounds.width / <span class="number">2</span>, collectionView!.bounds.height / <span class="number">2</span>)) &#123;</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> cell = collectionView?.cellForItemAtIndexPath(indexPath) <span class="keyword">as</span>? <span class="type">BookCoverCell</span> &#123;</div><div class="line">      <span class="keyword">return</span> cell</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法返回居中的 cell。<br>接下来用下面代码来替换<code>openBook(_:)</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">openBook</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">let</span> vc = storyboard?.instantiateViewControllerWithIdentifier(<span class="string">"BookViewController"</span>) <span class="keyword">as</span>! <span class="type">BookViewController</span></div><div class="line">  vc.book = selectedCell()?.book</div><div class="line">  <span class="comment">// UICollectionView loads it's cells on a background thread, so make sure it's loaded before passing it to the animation handler</span></div><div class="line">  dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></div><div class="line">    <span class="keyword">self</span>.navigationController?.pushViewController(vc, animated: <span class="literal">true</span>)</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法简单使用了上面写的<code>selectedCell</code>方法来获取当前选中的书本。<br>然后用下面代码替换<code>collectionView(_:didSelectItemAtIndexPath:)</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(collectionView: UICollectionView, didSelectItemAtIndexPath indexPath: NSIndexPath)</span></span> &#123;</div><div class="line">  openBook()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法使得你的点击打开的书本一直是居中的 cell 对应的书本，而不是之前 indexPath 对应的书本。</p>
<p>至此，我们已经完成了 BooksLayout。是时候展示真正的技术了–让屏幕上的书本看起来更自然真实，同时支持翻页。</p>
<h2 id="翻页布局"><a href="#翻页布局" class="headerlink" title="翻页布局"></a>翻页布局</h2><p>下图是我们要达成的最终效果：</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/02/VN_PageFlipping.gif" alt=""></p>
<p>使其看起来更像一本书！:]</p>
<p>在 Book 分组下新建 Layout 分组，右键新建一个继承自UICollectionViewFlowLayout名为BookLayout的子类，语言设置为 Swift。</p>
<p>和之前一样，bookCollectionView 需要设置其 Layout 为刚才新建的 Layout 类，如下图所示：</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2015/03/VN_BookLayoutStoryboard.png" alt=""></p>
<p>打开 BookLayout.swift，在 BookLayout 类声明上面加入如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">let</span> <span class="type">PageWidth</span>: <span class="type">CGFloat</span> = <span class="number">362</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">let</span> <span class="type">PageHeight</span>: <span class="type">CGFloat</span> = <span class="number">568</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">var</span> numberOfItems = <span class="number">0</span></div></pre></td></tr></table></figure>
<p>我们将使用这些常量来设置每个 cell 的大小，同样我们需要记录一本书的页数。<br>接下来在类声明中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareLayout</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">super</span>.prepareLayout()</div><div class="line">  collectionView?.decelerationRate = <span class="type">UIScrollViewDecelerationRateFast</span></div><div class="line">  numberOfItems = collectionView!.numberOfItemsInSection(<span class="number">0</span>)</div><div class="line">  collectionView?.pagingEnabled = <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和你在BooksLayout中所做的类似，不同的是：</p>
<ul>
<li>1.设置减速速率为UIScrollViewDecelerationRateFast来增加减速速率，进而使得 scrollView 快速停止</li>
<li>2.获取当前书本的页数</li>
<li>3.启用翻页；让每次滑动都是一个页面的距离</li>
</ul>
<p>继续在BookLayout.swift添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">shouldInvalidateLayoutForBoundsChange</span><span class="params">(newBounds: CGRect)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和上面一样，在 bounds 发生改变时使布局失效，进而调用 prepareLayout 来计算新的布局。<br>接下来复写collectionViewContentSize()来设置 collecyionView 的 contentSize：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">collectionViewContentSize</span><span class="params">()</span></span> -&gt; <span class="type">CGSize</span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="type">CGSizeMake</span>((<span class="type">CGFloat</span>(numberOfItems / <span class="number">2</span>)) * collectionView!.bounds.width, collectionView!.bounds.height)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法返回整个内容视图大小，高度不变，宽度随着 item 及书的页数发生改变。之所以要除以2，是因为每一页有两面，每一面上都有内容。<br>和你在BooksLayout中做的一样，需要复写layoutAttributesForElementsInRect(_:)方法，在这个方法中可以添加为每一页添加翻页效果。<br>在collectionViewContentSize()方法后面添加下面代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutAttributesForElementsInRect</span><span class="params">(rect: CGRect)</span></span> -&gt; [<span class="type">AnyObject</span>]? &#123;</div><div class="line">  <span class="comment">//1</span></div><div class="line">  <span class="keyword">var</span> array: [<span class="type">UICollectionViewLayoutAttributes</span>] = []</div><div class="line"> </div><div class="line">  <span class="comment">//2</span></div><div class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ... <span class="built_in">max</span>(<span class="number">0</span>, numberOfItems - <span class="number">1</span>) &#123;</div><div class="line">    <span class="comment">//3</span></div><div class="line">    <span class="keyword">var</span> indexPath = <span class="type">NSIndexPath</span>(forItem: i, inSection: <span class="number">0</span>)</div><div class="line">    <span class="comment">//4</span></div><div class="line">    <span class="keyword">var</span> attributes = layoutAttributesForItemAtIndexPath(indexPath)</div><div class="line">    <span class="keyword">if</span> attributes != <span class="literal">nil</span> &#123;</div><div class="line">      <span class="comment">//5</span></div><div class="line">      array += [attributes]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//6</span></div><div class="line">  <span class="keyword">return</span> array</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和 BooksLayout 不同的是，因为所有 cell 都在可见区域中，所以我们在 layoutAttributesForItemAtIndexPath(_:) 方法中来计算布局属性。<br>下面是每一行的解释：</p>
<ul>
<li>1.创建一个新的数组来持有所有 cell 的布局属性</li>
<li>2.遍历所有 item</li>
<li>3.为每个 item 创建一个 indexPath</li>
<li>4.获取 indexPath 对应的布局属性。你马上就要复写  layoutAttributesForItemAtIndexPath(_:) 方法</li>
<li>5.将布局属性添加到数组当中</li>
<li>6.返回所有 cell 的布局属性</li>
</ul>
<h2 id="页面的几何运算"><a href="#页面的几何运算" class="headerlink" title="页面的几何运算"></a>页面的几何运算</h2><p>在你实现  layoutAttributesForItemAtIndexPath(_:) 之前，花点时间来考虑布局，想想它该如何工作，我们是否能写一些工具方法来使得所有事情简单化、模块化。:]</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/02/VN_PaperRatioDiagram.png" alt=""></p>
<p>上图显示书页的翻动是以书脊作为旋转轴。上图中的比例从-1.0到1.0变化。为什么？想象一下将一本书放在桌子上，书脊表示0.0，当你从左至右翻页时，翻转比率从-1.0（最左端）变到1.0（最右端）。<br>因此，你可以用如下比率来表示你的翻页过程：</p>
<ul>
<li>0.5表示页面成90度状态，与桌面垂直</li>
<li>+/- 0.5表示与桌面成45度</li>
<li>+/- 1.0表示与桌面平行</li>
</ul>
<p>因为旋转是逆时针的，角度符号与比率符号相反。（即正负符号相反）<br>首先将下面工具方法添加在 layoutAttributesForElementsInRect(_:) 之后：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//MARK: - Attribute Logic Helpers</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFrame</span><span class="params">(collectionView: UICollectionView)</span></span> -&gt; <span class="type">CGRect</span> &#123;</div><div class="line">  <span class="keyword">var</span> frame = <span class="type">CGRect</span>()</div><div class="line"> </div><div class="line">  frame.origin.x = (collectionView.bounds.width / <span class="number">2</span>) - (<span class="type">PageWidth</span> / <span class="number">2</span>) + collectionView.contentOffset.x</div><div class="line">  frame.origin.y = (collectionViewContentSize().height - <span class="type">PageHeight</span>) / <span class="number">2</span></div><div class="line">  frame.size.width = <span class="type">PageWidth</span></div><div class="line">  frame.size.height = <span class="type">PageHeight</span></div><div class="line"> </div><div class="line">  <span class="keyword">return</span> frame</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据 collectionView 的中心为每一个页面计算其 frame。getFrame(_:) 方法会将每个页面边缘与书脊对其。改变的唯一变量是collectionView的内容在x方向偏移。<br>接下来，添加如下方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">getRatio</span><span class="params">(collectionView: UICollectionView, indexPath: NSIndexPath)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</div><div class="line">  <span class="comment">//1</span></div><div class="line">  <span class="keyword">let</span> page = <span class="type">CGFloat</span>(indexPath.item - indexPath.item % <span class="number">2</span>) * <span class="number">0.5</span></div><div class="line"> </div><div class="line">  <span class="comment">//2</span></div><div class="line">  <span class="keyword">var</span> ratio: <span class="type">CGFloat</span> = -<span class="number">0.5</span> + page - (collectionView.contentOffset.x / collectionView.bounds.width)</div><div class="line"> </div><div class="line">  <span class="comment">//3</span></div><div class="line">  <span class="keyword">if</span> ratio &gt; <span class="number">0.5</span> &#123;</div><div class="line">    ratio = <span class="number">0.5</span> + <span class="number">0.1</span> * (ratio - <span class="number">0.5</span>)</div><div class="line"> </div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ratio &lt; -<span class="number">0.5</span> &#123;</div><div class="line">    ratio = -<span class="number">0.5</span> + <span class="number">0.1</span> * (ratio + <span class="number">0.5</span>)</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> ratio</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面方法计算页面的比率。下面是对每个注释的解释：</p>
<ul>
<li>1.计算页面在书本当中的编号，记住书页是双面的。乘以0.5可以得到你当前所在的页面。</li>
<li>2.根据你翻动的权重计算比率</li>
<li>3.需要将比率范围限制在-0.5到0.5之间。乘以0.1是用来给页面之间添加一个间距使得它们看起来是被遮盖一样。</li>
</ul>
<p>在你计算好比率之后，就可以用它来计算当前翻动的角度了。在上面代码后添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">getAngle</span><span class="params">(indexPath: NSIndexPath, ratio: CGFloat)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</div><div class="line">  <span class="comment">// Set rotation</span></div><div class="line">  <span class="keyword">var</span> angle: <span class="type">CGFloat</span> = <span class="number">0</span></div><div class="line"> </div><div class="line">  <span class="comment">//1</span></div><div class="line">  <span class="keyword">if</span> indexPath.item % <span class="number">2</span> == <span class="number">0</span> &#123;</div><div class="line">    <span class="comment">// The book's spine is on the left of the page</span></div><div class="line">    angle = (<span class="number">1</span>-ratio) * <span class="type">CGFloat</span>(-<span class="type">M_PI_2</span>)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//2</span></div><div class="line">    <span class="comment">// The book's spine is on the right of the page</span></div><div class="line">    angle = (<span class="number">1</span> + ratio) * <span class="type">CGFloat</span>(<span class="type">M_PI_2</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//3</span></div><div class="line">  <span class="comment">// Make sure the odd and even page don't have the exact same angle</span></div><div class="line">  angle += <span class="type">CGFloat</span>(indexPath.row % <span class="number">2</span>) / <span class="number">1000</span></div><div class="line">  <span class="comment">//4</span></div><div class="line">  <span class="keyword">return</span> angle</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里进行了一些数学计算，但是拆开来看也不是很难：</p>
<ul>
<li>1.判断当前页面是否为双书面，即序号是否为2的倍数，也就是说它处在书脊的右边。向左翻动是逆时针，在书脊右侧的页面的角度是负的。回想一下之前定义的在-0.5到0.5变化的比率。</li>
<li>2.如果当前面是奇数，那么它就在书脊的左侧，向右翻动是顺时针，所以书脊左侧的页面角度为正。</li>
<li>3.为每个页面添加一个偏移角度</li>
<li>4.返回旋转角</li>
</ul>
<p>现在我们有了旋转角，我们需要转换每一个页面，添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">makePerspectiveTransform</span><span class="params">()</span></span> -&gt; <span class="type">CATransform3D</span> &#123;</div><div class="line">  <span class="keyword">var</span> transform = <span class="type">CATransform3DIdentity</span></div><div class="line">  transform.m34 = <span class="number">1.0</span> / -<span class="number">2000</span></div><div class="line">  <span class="keyword">return</span> transform</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修改 transform 中的<code>m34</code>来为每个页面增加透视。<br>现在是时候加上旋转效果了。加入如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">getRotation</span><span class="params">(indexPath: NSIndexPath, ratio: CGFloat)</span></span> -&gt; <span class="type">CATransform3D</span> &#123;</div><div class="line">  <span class="keyword">var</span> transform = makePerspectiveTransform()</div><div class="line">  <span class="keyword">var</span> angle = getAngle(indexPath, ratio: ratio)</div><div class="line">  transform = <span class="type">CATransform3DRotate</span>(transform, angle, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</div><div class="line">  <span class="keyword">return</span> transform</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法使用上面提到的两个工具方法来计算 transform 和 angle，然后创建了一个 CATransform3D并将其使用到页面的 y 轴上。<br>现在所有工具方法已准备就是，是时候为每个 cell撸一下布局属性了。在 layoutAttributesForElementsInRect(_:) 后面加入下面代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutAttributesForItemAtIndexPath</span><span class="params">(indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UICollectionViewLayoutAttributes</span>! &#123;</div><div class="line">  <span class="comment">//1</span></div><div class="line">  <span class="keyword">var</span> layoutAttributes = <span class="type">UICollectionViewLayoutAttributes</span>(forCellWithIndexPath: indexPath)</div><div class="line"> </div><div class="line">  <span class="comment">//2</span></div><div class="line">  <span class="keyword">var</span> frame = getFrame(collectionView!)</div><div class="line">  layoutAttributes.frame = frame</div><div class="line"> </div><div class="line">  <span class="comment">//3</span></div><div class="line">  <span class="keyword">var</span> ratio = getRatio(collectionView!, indexPath: indexPath)</div><div class="line"> </div><div class="line">  <span class="comment">//4</span></div><div class="line">  <span class="keyword">if</span> ratio &gt; <span class="number">0</span> &amp;&amp; indexPath.item % <span class="number">2</span> == <span class="number">1</span></div><div class="line">     || ratio &lt; <span class="number">0</span> &amp;&amp; indexPath.item % <span class="number">2</span> == <span class="number">0</span> &#123;</div><div class="line">    <span class="comment">// Make sure the cover is always visible</span></div><div class="line">    <span class="keyword">if</span> indexPath.row != <span class="number">0</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">  &#125;	</div><div class="line">  <span class="comment">//5</span></div><div class="line">  <span class="keyword">var</span> rotation = getRotation(indexPath, ratio: <span class="built_in">min</span>(<span class="built_in">max</span>(ratio, -<span class="number">1</span>), <span class="number">1</span>))</div><div class="line">  layoutAttributes.transform3D = rotation</div><div class="line"> </div><div class="line">  <span class="comment">//6</span></div><div class="line">  <span class="keyword">if</span> indexPath.row == <span class="number">0</span> &#123;</div><div class="line">    layoutAttributes.zIndex = <span class="type">Int</span>.<span class="built_in">max</span></div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> layoutAttributes</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每个 cell 都会调用这个方法：</p>
<ul>
<li>1.为给定的 indexPath 创建一个 UICollectionViewLayoutAttributes</li>
<li>2.使用 getFrame 方法给布局属性设置 frame，来保证它会与书脊对齐</li>
<li>3.用之前的 getRatio 方法来设置布局属性的比率</li>
<li>4.判断当前页的比率是否在限制范围内，如果不在就不展示这个 cell。为了优化，通常不显示背面，只展示正面。当然如果是书的封面则需要一直展示。</li>
<li>5.根据计算得到比率来获取 rotation 和 transform</li>
<li>6.判断 indexPath 是否为第一页，如果是第一页则设置其 zIndex 让它显示在所有页面之上，避免闪现情况发生。</li>
</ul>
<p>运行程序，打开书本，翻动以下。。。what the f**k!!</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/03/misc-jackie-chan.png" alt=""></p>
<p>页面的锚点貌似是 center 而不是边缘！</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/03/VN_Anchor1.png" alt=""></p>
<p>如图所示，每个页面锚点坐标为（0.5,0.5）。你知道怎么解决这个问题吗？</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/03/VN_CorrectRatio.png" alt=""></p>
<p>很明显，你需要改变锚点位置，使其位于边缘。如果页面在书脊的右侧，锚点应该为(0,0.5),反之锚点为(1,0.5)。</p>
<p>打开 BookPageCell.swift 添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">applyLayoutAttributes</span><span class="params">(layoutAttributes: UICollectionViewLayoutAttributes!)</span></span> &#123;</div><div class="line">  <span class="keyword">super</span>.applyLayoutAttributes(layoutAttributes)</div><div class="line">  <span class="comment">//1</span></div><div class="line">  <span class="keyword">if</span> layoutAttributes.indexPath.item % <span class="number">2</span> == <span class="number">0</span> &#123;</div><div class="line">    <span class="comment">//2</span></div><div class="line">    layer.anchorPoint = <span class="type">CGPointMake</span>(<span class="number">0</span>, <span class="number">0.5</span>)</div><div class="line">    isRightPage = <span class="literal">true</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//3</span></div><div class="line">      <span class="comment">//4</span></div><div class="line">      layer.anchorPoint = <span class="type">CGPointMake</span>(<span class="number">1</span>, <span class="number">0.5</span>)</div><div class="line">      isRightPage = <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//5</span></div><div class="line">    <span class="keyword">self</span>.updateShadowLayer()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面复写了 applyLayoutAttributes(_:) 方法，它使用了 BookLayout 中的布局属性。这看起来非常言简意赅。</p>
<ul>
<li>1.判读当前页面是否为双数，也就是当前页面在书脊右侧。</li>
<li>2.将锚点设置成左边缘，然后设置<code>isRightPage</code>为 true。这个变量可以帮你确定圆角的位置。</li>
<li>3。如果当前页面为奇数，那么它就处于书脊左侧</li>
<li>4.设置奇数页面的锚点为其右测边缘，然后设置<code>isRightPage</code>为 false</li>
<li>5.最后更新当前页的阴影 layer</li>
</ul>
<p>运行一下，翻动页面，看起来比之前好多了。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/03/VN_CompletePart1.gif" alt=""></p>
<p>到此为止，该教程的第一部分已经结束。花点时间休息一下，想想这个过程是不是很屌？！</p>
<h2 id="何去何从"><a href="#何去何从" class="headerlink" title="何去何从"></a>何去何从</h2><p>你可以<a href="http://cdn1.raywenderlich.com/wp-content/uploads/2015/05/Part-1-Paper-Completed.zip" target="_blank" rel="external">在此</a>下载第一部分的完整代码。<br>你从默认的 layout 开始，然后学习了如何自定义一个新的 layout 然后创建了一个比较屌的效果！用这个 app 的人会觉得他们像在翻实体书一样。正是这样一个细节使得一个普通的阅读类软件变得深受用户欢迎。<br>然而，一切还没有结束。在<a href="http://t.cn/Ry2rYj5" target="_blank" rel="external">第二部分</a>中你可以让这个 app 变得更好更简洁。<br>你是否也有很炫的布局想法？如果你有任何疑问、评论以及对这篇教程的其他想法，欢迎在下面讨论。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这个分两部分的教程系列中，你将开发一个漂亮的 iOS 打开及翻书动画，类似于&lt;a href=&quot;https://www.fiftythree.com/paper&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Paper by FiftyThree&lt;/a&gt;：&lt;/p&gt;
    
    </summary>
    
      <category term="翻译" scheme="https://vongloo.me/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="UICollectionView" scheme="https://vongloo.me/tags/UICollectionView/"/>
    
      <category term="翻译" scheme="https://vongloo.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>UICollectionView自定义布局之风火轮[译]</title>
    <link href="https://vongloo.me/2015/08/31/A-Spinning-Wheel-Layout/"/>
    <id>https://vongloo.me/2015/08/31/A-Spinning-Wheel-Layout/</id>
    <published>2015-08-31T12:19:46.000Z</published>
    <updated>2019-03-03T15:42:37.279Z</updated>
    
    <content type="html"><![CDATA[<p>现在有许多极具创造力的网站，几周前我碰巧浏览到一个名为<a href="http://fff.cmiscm.com/" target="_blank" rel="external">Form Follows Function</a>的网站，上面有各种交互动画。其中最吸引我的是网站上的导航转轮，转轮由各种交互体验海报组成。</p>
<a id="more"></a>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/06/Screenshot-2015-05-27-00.15.28-700x317.png" alt=""></p>
<p>原文：<a href="http://www.raywenderlich.com/107687/uicollectionview-custom-layout-tutorial-spinning-wheel" target="_blank" rel="external">UICollectionView Custom Layout Tutorial: A Spinning Wheel</a></p>
<p>本教程将讲解如何使用自定义的 <code>UICollectionViewFlowLayout</code> 来再现那个导航风火轮。在开始之前，希望你有对 2D 转换、<code>UICollectionView</code> 及其自定义布局的基本知识。如果你对这些还不是很熟悉，推荐你先看看下面几篇教程。</p>
<ul>
<li><a href="http://www.raywenderlich.com/78550/beginning-ios-collection-views-swift-part-1" target="_blank" rel="external">UICollectionView Tutorial Part 1: Getting Started</a></li>
<li><a href="http://www.raywenderlich.com/78551/beginning-ios-collection-views-swift-part-2" target="_blank" rel="external">UICollectionView Tutorial Part 2: Reusable Views and Cell Selection</a></li>
<li><a href="http://www.raywenderlich.com/video-tutorials#collectionview" target="_blank" rel="external">Video Series: Collection Views</a></li>
<li><a href="http://www.raywenderlich.com/video-tutorials#CCVL" target="_blank" rel="external">Video Series: Custom Collection View Layouts</a></li>
</ul>
<p>通过学习该教程，你将了解到：</p>
<ul>
<li>从头开始创建自定义<code>collectionView</code>的布局，而不是使用<br><code>UICollectionViewFlowLayout</code>作为你的基类。</li>
<li>view 在其 bounds 之外绕某点旋转</li>
</ul>
<p>那么现在，让我们开搞吧。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>首先下载<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2015/06/CircularCollectionView-Starter.zip" target="_blank" rel="external">模板</a>，在 Xcode 中打开，运行。你将看到一系列 cell，每个代表<a href="http://www.raywenderlich.com/store" target="_blank" rel="external">书城</a>中的一本书。</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/05/Screenshot-2015-05-27-00.48.36-700x417.png" alt=""></p>
<p>下面我们来看看工程目录结构，有一个 CollectionViewController、一个自定义 Cell，cell 中有一个 imageView。然后 VC 被这些 Cell填充。我们的任务就是创建一个UICollectionViewLayout子类来将这些 Cell 按照圆弧排列。</p>
<h2 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h2><p>下图是一个带有 cell 的风火轮。黄色区域是 iPhone 的屏幕，蓝色圆角矩形是 cell，红色虚线是你将要放置 cell 的圆弧。</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/06/Screenshot-2015-06-01-14.11.42.png" alt=""></p>
<p>你需要三个参数来创建这种排列：</p>
<ul>
<li>1.圆弧半径（radius）</li>
<li>2.每个 cell 之间的角度（anglePerItem）</li>
<li>3.每个 cell 的角位置</li>
</ul>
<p>你可能已经注意到，并非所有 cell 在屏幕当中能正常显示。</p>
<p>假设第0个 cell 的角度为 <code>x</code> 度，那么第1个 cell 的角位置为 <code>x + anglePerItem</code>,第二个为<code>x + anglePerItem * 2</code>，以此类推。第 n 个的角位置的计算公式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">angle_for_i = x + (i * anglePerItem)</div></pre></td></tr></table></figure>
<p>下图展示的是角坐标系。0度代表中心，顺时针方向为正，逆时针方向为负。所以0度角的 cell 将处在正中央，完全垂直的方向。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/06/Screenshot-2015-06-01-14.41.07.png" alt=""></p>
<p>现在你对理论知识有了一个全面的理解，让我们开始撸代码吧。</p>
<h2 id="Circular-Collection-View-Layout"><a href="#Circular-Collection-View-Layout" class="headerlink" title="Circular Collection View Layout"></a>Circular Collection View Layout</h2><p>新建一个 swift 文件，取名CircularCollectionViewLayout，继承自UICollectionViewLayout。</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/07/Dialog.png" alt=""></p>
<p>点击下一步、创建。这个UICollectionViewLayout的子类将包含所有与位置相关的代码。<br>因为CircularCollectionViewLayout继承自UICollectionViewLayout而不是UICollectionViewFlowLayout，所以你需要处理所有布局过程而不是简单调用 super 中的实现。</p>
<p>我发现 FlowLayout 非常适合网格视图而非圆形布局。<br>在CircularCollectionViewLayout中，新建两个属性<code>itemSize</code>和<code>radius</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> itemSize = <span class="type">CGSize</span>(width: <span class="number">133</span>, height: <span class="number">173</span>)</div><div class="line"> </div><div class="line"><span class="keyword">var</span> radius: <span class="type">CGFloat</span> = <span class="number">500</span> &#123;</div><div class="line">  <span class="keyword">didSet</span> &#123;</div><div class="line">    invalidateLayout()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当半径改变时你需要重新计算所有值，所以要在 <code>didSet</code> 中调用<code>invalidateLayout()</code>。在 radius 声明下面紧接着<code>anglePerItem</code>的定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> anglePerItem: <span class="type">CGFloat</span> &#123;</div><div class="line">  <span class="keyword">return</span> atan(itemSize.width / radius)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>anglePerItem</code>可以是你想要的任何值，但是公式要确保 cell 不要被分散的太开。<br>下一步，实现<code>collectionViewContentSize()</code>来声明你的 collectionView 的内容有多大：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">collectionViewContentSize</span><span class="params">()</span></span> -&gt; <span class="type">CGSize</span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="type">CGSize</span>(width: <span class="type">CGFloat</span>(collectionView!.numberOfItemsInSection(<span class="number">0</span>)) * itemSize.width,</div><div class="line">      height: <span class="type">CGRectGetHeight</span>(collectionView!.bounds))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>内容高度与 collectionView 高度一致，但是宽度是<code>itemSize.width * numberOfItems</code>。<br>现在打开<code>Main.storyboard</code>，选中视图大纲中的Collection View，如下图所示</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/07/Outline.png" alt=""></p>
<p>打开Attributes Inspector，将其 Layout 设置为自定义，将其 Class 设置为CircularCollectionViewLayout。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/07/Attributes.png" alt=""></p>
<p>运行程序，你将发现除了一个可滑动区域外，屏幕上没有任何东西。但是它就是你想要的，因为这确保你正确地将 collectionView 的 Layout 设置为你自定义的 Class 即CircularCollectionViewLayout。</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/05/Screenshot-2015-06-01-03.07.31-700x421.png" alt=""></p>
<h2 id="自定义布局属性"><a href="#自定义布局属性" class="headerlink" title="自定义布局属性"></a>自定义布局属性</h2><p>除了新建一个新的布局子类，你还要新建一个继承自UICollectionViewLayoutAttributes的类来存储角位置以及锚点（anchorPoint）。<br>把下面代码加到CircularCollectionViewLayout.swift这个文件中，将其放在CircularCollectionViewLayout类声明上面。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircularCollectionViewLayoutAttributes</span>: <span class="title">UICollectionViewLayoutAttributes</span> </span>&#123;</div><div class="line">  <span class="comment">// 1</span></div><div class="line">  <span class="keyword">var</span> anchorPoint = <span class="type">CGPoint</span>(x: <span class="number">0.5</span>, y: <span class="number">0.5</span>)</div><div class="line">  <span class="keyword">var</span> angle: <span class="type">CGFloat</span> = <span class="number">0</span> &#123;</div><div class="line">    <span class="comment">// 2 </span></div><div class="line">    <span class="keyword">didSet</span> &#123;</div><div class="line">      zIndex = <span class="type">Int</span>(angle * <span class="number">1000000</span>)</div><div class="line">      transform = <span class="type">CGAffineTransformMakeRotation</span>(angle)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 3</span></div><div class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">copyWithZone</span><span class="params">(zone: NSZone)</span></span> -&gt; <span class="type">AnyObject</span> &#123;</div><div class="line">    <span class="keyword">let</span> copiedAttributes: <span class="type">CircularCollectionViewLayoutAttributes</span> = </div><div class="line">        <span class="keyword">super</span>.copyWithZone(zone) <span class="keyword">as</span>! <span class="type">CircularCollectionViewLayoutAttributes</span></div><div class="line">    copiedAttributes.anchorPoint = <span class="keyword">self</span>.anchorPoint</div><div class="line">    copiedAttributes.angle = <span class="keyword">self</span>.angle</div><div class="line">    <span class="keyword">return</span> copiedAttributes</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>1.我们需要一个锚点，因为旋转是围绕锚点而非中心。</li>
<li>2.当设置角度（angle）的时候，在内部设置其 transform 旋转 angle 弧度。同时我们想要右边的 cell 覆盖在左边的 cell 上，这个可以通过设置 zIndex 来实现。因为角度用弧度表示，我们将其扩大 1,000,000倍来确保相邻的值不会被四舍五入成同一个 zIndex 值，zIndex 是 Int 型的。</li>
<li>3.复写copyWithZone()来遵循NSCopying协议，因为在 collectionView 布局时，内部会拷贝布局属性。复写这个方法来确保复制过程中，<code>anchorPoint</code> 和 <code>angle</code>两个属性也会被拷贝。</li>
</ul>
<p>下面我们回到CircularCollectionViewLayout中来实现 layoutAttributesClass()方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">layoutAttributesClass</span>() -&gt; <span class="title">AnyClass</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="type">CircularCollectionViewLayoutAttributes</span>.<span class="keyword">self</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这一步是为了告知 collecttionView 你将使用CircularCollectionViewLayoutAttributes而不是默认的UICollectionViewLayoutAttributes。<br>为了持有布局属性，在所有属性声明之后创建一个名为<code>attributesList</code>的数组。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> attributesList = [<span class="type">CircularCollectionViewLayoutAttributes</span>]()</div></pre></td></tr></table></figure>
<h2 id="Preparing-the-Layout"><a href="#Preparing-the-Layout" class="headerlink" title="Preparing the Layout"></a>Preparing the Layout</h2><p>当 collectionView 第一次展示在屏幕上时，Layout 的<code>prepareLayout()</code>方法将被调用。在每次布局生效时这个方法也会被调用。<br>这是布局过程中最重要的方法之一，因为这是创建和存储布局属性的入口。在CircularCollectionViewLayout添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareLayout</span><span class="params">()</span></span> &#123;</div><div class="line">  <span class="keyword">super</span>.prepareLayout()</div><div class="line"> </div><div class="line">  <span class="keyword">let</span> centerX = collectionView!.contentOffset.x + (<span class="type">CGRectGetWidth</span>(collectionView!.bounds) / <span class="number">2.0</span>)</div><div class="line">  attributesList = (<span class="number">0</span>..&lt;collectionView!.numberOfItemsInSection(<span class="number">0</span>)).<span class="built_in">map</span> &#123; (i) </div><div class="line">      -&gt; <span class="type">CircularCollectionViewLayoutAttributes</span> <span class="keyword">in</span></div><div class="line">    <span class="comment">// 1</span></div><div class="line">    <span class="keyword">let</span> attributes = <span class="type">CircularCollectionViewLayoutAttributes</span>(forCellWithIndexPath: <span class="type">NSIndexPath</span>(forItem: i,</div><div class="line">        inSection: <span class="number">0</span>))</div><div class="line">    attributes.size = <span class="keyword">self</span>.itemSize</div><div class="line">    <span class="comment">// 2</span></div><div class="line">    attributes.center = <span class="type">CGPoint</span>(x: centerX, y: <span class="type">CGRectGetMidY</span>(<span class="keyword">self</span>.collectionView!.bounds))</div><div class="line">    <span class="comment">// 3</span></div><div class="line">    attributes.angle = <span class="keyword">self</span>.anglePerItem*<span class="type">CGFloat</span>(i)</div><div class="line">    <span class="keyword">return</span> attributes</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单来说，我们便利每一个 item，然后执行闭包。下面我们一行行来解释：</p>
<ul>
<li>1.为每个 IndexPath 创建一个CircularCollectionViewLayoutAttributes实例，然后设置其大小（size）</li>
<li>2.将 item 放在屏幕中间</li>
<li>按弧度来旋转每个 item，旋转量为<code>anglePerItem * i</code></li>
</ul>
<blockquote>
<p>方法中的 map 是 Swift 标准库中的一部分，它创建了一个新的数组，数组中存储的是闭包的执行结果。你可以在<a href="http://www.raywenderlich.com/82599/swift-functional-programming-tutorial" target="_blank" rel="external">这篇文章</a>中了解更多。</p>
</blockquote>
<p>我们还需要实现下面的方法，这些方法返回在给定矩形区域中的 item 布局属性，以及给定的 indexpath 的 item 布局属性。collectionView 在布局过程中将会多次调用这些方法，在用户滑动 collectionView 也会触发这些方法。为了保证其高效性，我们在<code>prepareLayout()</code>方法中缓存了这些布局属性。把下面代码加到<code>prepareLayout()</code>下面：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutAttributesForElementsInRect</span><span class="params">(rect: CGRect)</span></span> -&gt; [<span class="type">AnyObject</span>]? &#123;</div><div class="line">  <span class="keyword">return</span> attributesList</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutAttributesForItemAtIndexPath</span><span class="params">(indexPath: NSIndexPath)</span></span> </div><div class="line">    -&gt; <span class="type">UICollectionViewLayoutAttributes</span>! &#123;</div><div class="line">  <span class="keyword">return</span> attributesList[indexPath.row]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一个方法简单返回了整个布局属性数组，第二个方法返回了指定的 indexpath 对应的布局属性。这个方法非常 OK 因为我们的 item 数目比较小，但是通常我们会遍历数组来判断布局属性的 frame 是否与给定的矩形区域相交，然后返回与给定区域相交的布局属性。这使得 collectionView 在屏幕上只绘制这些 item，或者将要出现在屏幕上的 item。</p>
<p>运行，你会看到所有 cell 出现在屏幕上，但是它们是围绕自身来旋转而非外部的某个点。虽然它不是非常急需的效果，但是如果能做到确实挺酷的，你觉得呢？</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/05/Screenshot-2015-05-27-17.56.29-700x417.png" alt=""></p>
<p>你能猜到为什么会这样吗？</p>
<h2 id="有人说是锚点吗？"><a href="#有人说是锚点吗？" class="headerlink" title="有人说是锚点吗？"></a>有人说是锚点吗？</h2><p>你还记得上面我们说的 cell 的锚点吗？你还没有设置过它，上面的旋转效果远没达到我们希望得到的效果。</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/03/oh_yes_I_knew_that.png" alt=""></p>
<p>锚点是 CALayer 的一个属性，所有的旋转和缩放都是围绕着它而发生的。锚点的默认值是 center，就像上面的运行结果那样。<br>真正的锚点的 x 值应该为0.5，y 值应该为<code>radius + (itemSize.height / 2)</code>，因为锚点是在归一化坐标系中定义的，所以你要除以<code>itemSize.height</code>。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/06/Screenshot-2015-06-01-16.22.12-192x500.png" alt=""></p>
<p>回到<code>prepareLayout()</code>，然后再 <code>centerX</code> 的定义下面定义<code>anchorPointY</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> anchorPointY = ((itemSize.height / <span class="number">2.0</span>) + radius) / itemSize.height</div></pre></td></tr></table></figure>
<p>在<code>map(_:)</code>闭包中的 return 上方添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">attributes.anchorPoint = <span class="type">CGPoint</span>(x: <span class="number">0.5</span>, y: anchorPointY)</div></pre></td></tr></table></figure>
<p>接着打开open CircularCollectionViewCell.swift，然后复写<code>applyLayoutAttributes(_:)</code> ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">applyLayoutAttributes</span><span class="params">(layoutAttributes: UICollectionViewLayoutAttributes!)</span></span> &#123;</div><div class="line">  <span class="keyword">super</span>.applyLayoutAttributes(layoutAttributes)</div><div class="line">  <span class="keyword">let</span> circularlayoutAttributes = layoutAttributes <span class="keyword">as</span>! <span class="type">CircularCollectionViewLayoutAttributes</span></div><div class="line">  <span class="keyword">self</span>.layer.anchorPoint = circularlayoutAttributes.anchorPoint</div><div class="line">  <span class="keyword">self</span>.center.y += (circularlayoutAttributes.anchorPoint.y - <span class="number">0.5</span>) * <span class="type">CGRectGetHeight</span>(<span class="keyword">self</span>.bounds)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里你用父类实现来使用默认属性如 center 和 transform 但是因为锚点（anchorPoint）是一个自定义属性，我们需要手动使用它，同样我们也更新了 center.y 来补偿圆形布局中的anchorPoint.y变化。</p>
<p>运行程序，你会看到所有的 cell 按照圆形来布局了，但是滑动的过程中…等一下，发生了什么？它们被移出了屏幕而不是旋转！？</p>
<p>这使得找到想要的书变得非常困难。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/05/scrolling-off.gif" alt=""></p>
<h2 id="改善滑动效果"><a href="#改善滑动效果" class="headerlink" title="改善滑动效果"></a>改善滑动效果</h2><p>最具挑战性的布局 item 任务已经完成了，可喜可贺！:]</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/06/ragecomic.png" alt=""></p>
<p>现在需要做的就是改变角度值来实现滑动。</p>
<p>回到CircularCollectionViewLayout，然后在底部添加下面代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">shouldInvalidateLayoutForBoundsChange</span><span class="params">(newBounds: CGRect)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法返回 true 告知 collectionView 在滑动时布局失效，然后它会调用<code>prepareLayout()</code>，进而使用更新后的角位置重新计算 cell 的布局。angle被定义为第0个 item 的角位置。你将要通过把contentOffset.x转换成一个合适的角度值来实现滑动。</p>
<p>滑动过程中，<code>contentOffset.x</code>从 0 到<code>collectionViewContentSize().width - CGRectGetWidth(collectionView!.bounds)</code>变化。将<code>contentOffset.x</code>的极值定义为<code>maxContentOffset</code>，当其为 0 时，让第 0 个item 处在中心，当其为极值时（即maxContentOffset），让最后一个 item 处在屏幕中心，这就意味着最后一个 item 的角位置会变为 0 。</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/06/combined.png" alt=""></p>
<p>想象一下右边的场景，如果你是用<code>angle_for_last_item = 0</code>来解决下面等式你会得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">angle_for_last_item = angle_for_zero_item + (totalItems - 1) * anglePerItem</div><div class="line">0 = angle_for_zero_item + (totalItems - 1) * anglePerItem</div><div class="line">angle_for_zero_item = -(totalItems - 1) * anglePerItem</div></pre></td></tr></table></figure>
<p>定义<code>-(totalItems - 1) * anglePerItem</code>为<code>angleAtExtreme</code>，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">contentOffset.x = <span class="number">0</span>, angle = <span class="number">0</span></div><div class="line">contentOffset.x = maxContentOffset, angle = angleAtExtreme</div></pre></td></tr></table></figure>
<p>由上面，使用下面的公式非常容易计算任意<code>contentOffset.x</code>对应的角度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">angle = -angleAtExtreme * contentOffset.x / maxContentOffset</div></pre></td></tr></table></figure>
<p>脑海中回想以下这些算式，把下面代码添加到 itemSize 的声明下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> angleAtExtreme: <span class="type">CGFloat</span> &#123;</div><div class="line">  <span class="keyword">return</span> collectionView!.numberOfItemsInSection(<span class="number">0</span>) &gt; <span class="number">0</span> ? </div><div class="line">    -<span class="type">CGFloat</span>(collectionView!.numberOfItemsInSection(<span class="number">0</span>) - <span class="number">1</span>) * anglePerItem : <span class="number">0</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> angle: <span class="type">CGFloat</span> &#123;</div><div class="line">  <span class="keyword">return</span> angleAtExtreme * collectionView!.contentOffset.x / (collectionViewContentSize().width - </div><div class="line">    <span class="type">CGRectGetWidth</span>(collectionView!.bounds))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来使用</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">attributes.angle = <span class="keyword">self</span>.angle + (<span class="keyword">self</span>.anglePerItem * <span class="type">CGFloat</span>(i))</div></pre></td></tr></table></figure>
<p>来替换<code>prepareLayout()</code>中的</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">attributes.angle = (<span class="keyword">self</span>.anglePerItem * <span class="type">CGFloat</span>(i))</div></pre></td></tr></table></figure>
<p>这一步添加为每个 item 添加了角度值，这样 item 的角度值不在是一个常量，而是一个与<code>contentOffset.x</code>有着函数关系的值。<br>运行程序，在屏幕上滑动，你将发现所有 item 按照你想要的方式在滑动。干得漂亮！</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/05/final-scrolling.gif" alt=""></p>
<h2 id="加分环节-优化"><a href="#加分环节-优化" class="headerlink" title="加分环节:优化"></a>加分环节:优化</h2><p>你已经成功的重现了风火轮导航，现在可以在拍拍自己肩膀说一句干得漂亮，然后架着二郎腿享受这美好时光。但是在存在优化空间的情况（滑动丝滑般流畅）下你为什么要停下来呢？<br>在<code>prepareLayout()</code>中为每个 item 创建了一个CircularCollectionViewLayoutAttributes实例，但是不是所有的 item 都会立刻展示在屏幕上。那些离屏的 item，你可以完全跳过对它们的计算，也不必创建CircularCollectionViewLayoutAttributes实例。<br>但是有一个棘手的问题是：我们需要确定哪些 item 正在屏幕上显示，哪些是离屏的。如下图所示，在 (-θ, θ)范围之外的所有 item 都是离屏的。</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/06/Screenshot-2015-06-01-17.46.48.png" alt=""></p>
<p>举个栗子，为了计算三角形 ABC 中的 θ 角，可以使用下面公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tanθ = (collectionView.width / 2) / (radius + (itemSize.height / 2) - (collectionView.height / 2))</div></pre></td></tr></table></figure>
<p>在<code>prepareLayout()</code>中的<code>anchorPointY</code>下一行加入如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1 </span></div><div class="line"><span class="keyword">let</span> theta = atan2(<span class="type">CGRectGetWidth</span>(collectionView!.bounds) / <span class="number">2.0</span>, </div><div class="line">    radius + (itemSize.height / <span class="number">2.0</span>) - (<span class="type">CGRectGetHeight</span>(collectionView!.bounds) / <span class="number">2.0</span>))</div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="keyword">var</span> startIndex = <span class="number">0</span></div><div class="line"><span class="keyword">var</span> endIndex = collectionView!.numberOfItemsInSection(<span class="number">0</span>) - <span class="number">1</span> </div><div class="line"><span class="comment">// 3</span></div><div class="line"><span class="keyword">if</span> (angle &lt; -theta) &#123;</div><div class="line">  startIndex = <span class="type">Int</span>(floor((-theta - angle) / anglePerItem))</div><div class="line">&#125;</div><div class="line"><span class="comment">// 4</span></div><div class="line">endIndex = <span class="built_in">min</span>(endIndex, <span class="type">Int</span>(ceil((theta - angle) / anglePerItem)))</div><div class="line"><span class="comment">// 5</span></div><div class="line"><span class="keyword">if</span> (endIndex &lt; startIndex) &#123;</div><div class="line">  endIndex = <span class="number">0</span></div><div class="line">  startIndex = <span class="number">0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这一步我们做了什么？</p>
<ul>
<li>1.使用反正切函数计算theta角</li>
<li>2.初始化<code>startIndex</code>及<code>endIndex</code></li>
<li>3.如果第0个 item 的角位置小于 <code>-theta</code>，那么它就是离屏的，屏上第 1 个 item 的 <code>index</code> 将为 <code>-θ</code> 与 <code>angle</code> 的差值再除以 <code>anglePerItem</code></li>
<li>4.同样的，屏幕上最后一个 item 是<code>θ</code> 与 <code>angle</code> 的差值再除以 <code>anglePerItem</code>，min 是保证<code>endIndex</code>不会越界</li>
<li>5.最后做了一个容错处理，防止在快速滑动时所有 cell 都离屏时导致 <code>endIndex</code>小于 <code>startIndex</code>的情况</li>
</ul>
<p>下图把上面的计算过程可视化：</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/06/Screenshot-2015-06-01-18.23.05.png" alt=""></p>
<p>既然我们知道了哪些正在显示，哪些是离屏的，我们需要更新用来计算布局属性的起始和结束的 index。使用</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">attributesList = (startIndex...endIndex).<span class="built_in">map</span> &#123; (i) </div><div class="line">    -&gt; <span class="type">CircularCollectionViewLayoutAttributes</span> <span class="keyword">in</span></div></pre></td></tr></table></figure>
<p>来替换<code>prepareLayout()</code>中的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">attributesList = (<span class="number">0</span>..&lt;collectionView!.numberOfItemsInSection(<span class="number">0</span>)).<span class="built_in">map</span> &#123; (i) </div><div class="line">    -&gt; <span class="type">CircularCollectionViewLayoutAttributes</span> <span class="keyword">in</span></div></pre></td></tr></table></figure>
<p>运行程序，你会发现视觉上没有明显变化，因为所有的改变仅仅影响离屏的 item。我们可以打开 Xcode <a href="http://www.raywenderlich.com/98356/view-debugging-in-xcode-6" target="_blank" rel="external">内置的视图层级查看器</a></p>
<p>因为创建了更少的变量，你应该可以看到性能的提升。</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/06/Screenshot-2015-05-27-23.33.45-619x500.png" alt=""></p>
<h2 id="何去何从"><a href="#何去何从" class="headerlink" title="何去何从"></a>何去何从</h2><p>你可以<a href="http://cdn4.raywenderlich.com/wp-content/uploads/2015/06/CircularCollectionView-Final.zip" target="_blank" rel="external">在此</a>下载完整代码。</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/05/Screenshot-2015-06-01-03.03.33-700x421.png" alt=""></p>
<p>恭喜，你已经成功使用了自定义的 Layout 来实现一个导航风火轮。在这篇教程中你应该学到不少东西，包括如何旋转 view、改变锚点、从头创建自定义的 Layout 以及如何优化让它变得更好。<br>你可以更改<code>radius</code>和<code>anglePerItem</code>来进一步了解它们是如何来改变最终的圆形布局排列的。这篇教程主要是改变2D 的 transform，你也可以使用3D transform 来创建更有趣的效果。<br>同样你也可以通过复写<code>argetContentOffsetForProposedContentOffset(_:withScrollingVelocity:)</code>方法来实现snapping行为。<br>我相信你已经开始跃跃欲试了吧？如果你遇到问题，可以参考下面的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">targetContentOffsetForProposedContentOffset</span><span class="params">(proposedContentOffset: CGPoint, withScrollingVelocity velocity: CGPoint)</span></span> -&gt; <span class="type">CGPoint</span> &#123;</div><div class="line">  <span class="keyword">var</span> finalContentOffset = proposedContentOffset</div><div class="line">  <span class="keyword">let</span> factor = -angleAtExtreme/(collectionViewContentSize().width - </div><div class="line">      <span class="type">CGRectGetWidth</span>(collectionView!.bounds))</div><div class="line">  <span class="keyword">let</span> proposedAngle = proposedContentOffset.x*factor</div><div class="line">  <span class="keyword">let</span> ratio = proposedAngle/anglePerItem</div><div class="line">  <span class="keyword">var</span> multiplier: <span class="type">CGFloat</span></div><div class="line">  <span class="keyword">if</span> (velocity.x &gt; <span class="number">0</span>) &#123;</div><div class="line">    multiplier = ceil(ratio)</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (velocity.x &lt; <span class="number">0</span>) &#123;</div><div class="line">    multiplier = floor(ratio)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    multiplier = round(ratio)</div><div class="line">  &#125;</div><div class="line">  finalContentOffset.x = multiplier*anglePerItem/factor</div><div class="line">  <span class="keyword">return</span> finalContentOffset</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你有任何疑问、评论或者炫技，请加入下面的讨论。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在有许多极具创造力的网站，几周前我碰巧浏览到一个名为&lt;a href=&quot;http://fff.cmiscm.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Form Follows Function&lt;/a&gt;的网站，上面有各种交互动画。其中最吸引我的是网站上的导航转轮，转轮由各种交互体验海报组成。&lt;/p&gt;
    
    </summary>
    
      <category term="翻译" scheme="https://vongloo.me/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="UICollectionView" scheme="https://vongloo.me/tags/UICollectionView/"/>
    
      <category term="翻译" scheme="https://vongloo.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Koloda动画第二版[译]</title>
    <link href="https://vongloo.me/2015/08/23/Koloda-Second-Version/"/>
    <id>https://vongloo.me/2015/08/23/Koloda-Second-Version/</id>
    <published>2015-08-23T09:31:04.000Z</published>
    <updated>2019-03-03T15:42:37.279Z</updated>
    
    <content type="html"><![CDATA[<p>一个月前，我们发布了<a href="https://yalantis.com/blog/how-we-built-tinder-like-koloda-in-swift/" target="_blank" rel="external">how we developed Tinder-like Koloda in Swift</a>(<a href="http://0.0.0.0:4000/2015/08/21/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BC%20Tinder%20%E7%9A%84%E4%BA%A4%E4%BA%92%E5%8A%A8%E7%94%BB/" target="_blank" rel="external">如何创建一个类似 Tinder 的交互动画[译]</a>)。在开发者与设计师社区这个动画都受到强烈的欢迎，所以我们决定继续改善它。<br><a id="more"></a></p>
<p>原文：<a href="https://yalantis.com/blog/koloda-tinder-like-animation-version-2-prototyping-in-pixate-and-development-in-swift/" target="_blank" rel="external">Koloda Tinder-Like Animation Version 2.</a></p>
<p>从我们发布第一个简单的 Koloda 动画后，我们的设计师Dmitry Goncharov坚持要实现他的下一个想法。同样，我们的 iOS 开发工程师，Koloda 动画创建者Eugene Andreyev承诺要让 frame 计算更加自定义化来让更多开发者在我们的 Koloda 动画上制作他们别具一格的组件。<br>所以这是 Koloda 故事的第二章。这一次我们将同时讨论设计和开发。同时你也可以在<a href="https://dribbble.com/shots/2189960-Koloda-Tinder-Like-component-for-IOS-Available-on-GitHub" target="_blank" rel="external">Dribble</a>以及<a href="https://github.com/Yalantis/Koloda" target="_blank" rel="external">GitHub</a>上查看该动画。</p>
<h2 id="我们如何用-Pixate-制作-Koloda-原型"><a href="#我们如何用-Pixate-制作-Koloda-原型" class="headerlink" title="我们如何用 Pixate 制作 Koloda 原型"></a>我们如何用 Pixate 制作 Koloda 原型</h2><blockquote>
<ul>
<li>by Dmitry Goncharov</li>
</ul>
</blockquote>
<p>我被 Tinder-like 这个概念所鼓舞，决定详细阐述把 Koloda 转变为不同寻常动画的最原始的想法。可喜的是，几个小时后我有了一个新的想法。我的想法是去除底部层级，从背景中来加载下一个卡片。我在 PS 中设计了一个实物模型，然后在<a href="http://www.pixate.com/" target="_blank" rel="external">Pixate</a>中制作了原型。Pixate 是一个类似 InVisio、Marver、Origami 的设计工具。尽管在 Pixate 中设计原型比在 InVisio 中花了更多时间，但是Pixate做出的原型更加像一个原生应用。这个原型重造了我想要的卡片行为。</p>
<p><img src="https://yalantis.com/media/content/ckeditor/2015/08/11/pixate.gif" alt=""></p>
<p>现在让我们来讲一下其中的过程。Pixate 工具栏中包含了layers、action kit、以及animations。在资源加载完成出现在 artboard 上后，你就可以在layer上开始工作了，然后继续创建交互。一开始我需要让卡片水平移动然后当他们跨越临界点时从屏幕当中飞出。在简单的动画帮助下，我实现了这个过程。同样我也让卡片改变它的透明度和在交互过程中进行旋转。</p>
<p>然后我要让一个新的卡片按照就像它从背景中加载一样出现，所以我需要对其进行拉伸和缩放。我设置了缩放比为3.5倍到1倍，3.5倍是卡片在背景中的大小。</p>
<p><a href="https://yalantis.com/media/content/ckeditor/2015/08/11/tips.png" target="_blank" rel="external"></a></p>
<p>为了有更好的效果，我加了一些弹性动画，然后它就大功告成了。至此，原型设计就完成了，接下来就是开发的事情了。下面我想总结一下我对 Pixate 的总体印象。<br>优点：</p>
<ul>
<li>在移动设备上预览</li>
<li>原型处理简单</li>
<li>不需要有特定的动画基础知识</li>
<li>原型看起来更像原生 App</li>
<li>工程共享更加方便（可导出到电脑，外链，二维码）</li>
</ul>
<p>缺点：</p>
<ul>
<li>一个原型没有囊括整个 App 的功能，只是展示独立的功能和交互</li>
<li>一个单独的 artboard 不能容纳原型的所有界面</li>
<li>不能将原型导出为代码</li>
<li>web 端应用有 bug</li>
<li>基础的 asset kit 非常有限</li>
<li>动画没有时间线</li>
</ul>
<p>尽管有这么些缺点，但是 Pixate 是一个强大的工具，它能够设计师设计原生可点击的原型，创建导航模式以及屏幕间的交互。最重要的是，它能够让整个团队明白工程开发的整体方向。你可以观看<a href="https://www.youtube.com/channel/UCi0aGwdVsX6O4yw5JxpNGgQ" target="_blank" rel="external">Jared Lodwick</a>的视频教程来了解更多。</p>
<p>现在你已经知道一些关于 Koloda 的原型设计过程，是时候来谈谈我们如何开发出第二版动画的。</p>
<p><img src="https://yalantis.com/media/content/ckeditor/2015/08/11/component.gif" alt=""></p>
<h2 id="我们如何开发-Koloda-v-2"><a href="#我们如何开发-Koloda-v-2" class="headerlink" title="我们如何开发 Koloda v.2"></a>我们如何开发 Koloda v.2</h2><blockquote>
<ul>
<li>by Eugene Andreyev</li>
</ul>
</blockquote>
<p>第一版和第二版动画的最主要的区别就是卡片的布局。新版动画中最前的卡片被放置在屏幕中间，下面的卡片在背景中拉伸。底部卡片不会随顶部卡片移动而做出响应，而是在顶层卡片被滑出时出现在屏幕中，出现过程中有一个弹性特效。<br>得益于 Dima 的原型，第二版更加容易开发。首先，Pixate 允许查看原型的所有交互，其次我可以通过 Pixate 来查看所有应用到的变化，以及它们的顺序。然后简单地讲它们写进代码中，不需要人为调整。<br>最后，第二版 Koloda 是一个旅行 app 的一部分，不像第一版那样全是摇滚。</p>
<p>第一版：</p>
<p><img src="https://yalantis.com/media/content/ckeditor/2015/08/11/koloda_v1.gif" alt=""></p>
<h2 id="Koloda-v-2的实现"><a href="#Koloda-v-2的实现" class="headerlink" title="Koloda v.2的实现"></a>Koloda v.2的实现</h2><p>为了实现 Dima 设计的动画，我需要用不同的方式来放置卡片，所以我将<a href="http://vonglo.me/2015/08/21/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BC%20Tinder%20%E7%9A%84%E4%BA%A4%E4%BA%92%E5%8A%A8%E7%94%BB/" target="_blank" rel="external">上一篇文章</a>(KolodaView实现那一段)中的<code>frameForCardAtIndex</code>暴露在头文件中。在 KolodaView 的子类中我复写了这个方法，然后按如下方式来放置卡片：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">frameForCardAtIndex</span><span class="params">(index: UInt)</span></span> -&gt; <span class="type">CGRect</span> &#123;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> index == <span class="number">0</span> &#123;</div><div class="line"></div><div class="line">           <span class="keyword">let</span> bottomOffset:<span class="type">CGFloat</span> = defaultBottomOffset</div><div class="line"></div><div class="line">           <span class="keyword">let</span> topOffset:<span class="type">CGFloat</span> = defaultTopOffset</div><div class="line"></div><div class="line">           <span class="keyword">let</span> xOffset:<span class="type">CGFloat</span> = defaultHorizontalOffset</div><div class="line"></div><div class="line">           <span class="keyword">let</span> width = <span class="type">CGRectGetWidth</span>(<span class="keyword">self</span>.frame ) - <span class="number">2</span> * defaultHorizontalOffset</div><div class="line"></div><div class="line">           <span class="keyword">let</span> height = width * defaultHeightRatio</div><div class="line"></div><div class="line">           <span class="keyword">let</span> yOffset:<span class="type">CGFloat</span> = topOffset</div><div class="line"></div><div class="line">           <span class="keyword">let</span> frame = <span class="type">CGRect</span>(x: xOffset, y: yOffset, width: width, height: height)</div><div class="line"></div><div class="line">           <span class="keyword">return</span> frame</div><div class="line"></div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> index == <span class="number">1</span> &#123;</div><div class="line"></div><div class="line">           <span class="keyword">let</span> horizontalMargin = -<span class="keyword">self</span>.bounds.width * backgroundCardHorizontalMarginMultiplier</div><div class="line"></div><div class="line">           <span class="keyword">let</span> width = <span class="keyword">self</span>.bounds.width * backgroundCardScalePercent</div><div class="line"></div><div class="line">           <span class="keyword">let</span> height = width * defaultHeightRatio</div><div class="line"></div><div class="line">           <span class="keyword">return</span> <span class="type">CGRect</span>(x: horizontalMargin, y: <span class="number">0</span>, width: width, height: height)</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">return</span> <span class="type">CGRectZero</span></div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>发生了什么？我将 frontCard放置在KolodaView中间，然后拉伸背景卡片为其原始大小的1.5倍。</p>
<p><img src="https://yalantis.com/media/content/ckeditor/2015/08/11/states.jpg" alt=""></p>
<h2 id="背景卡片的弹性动画"><a href="#背景卡片的弹性动画" class="headerlink" title="背景卡片的弹性动画"></a>背景卡片的弹性动画</h2><p>因为背景卡片以弹性动画的方式出现，以及在移动过程中改变透明度，我写了一个新的代理方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">KolodaView</span> - <span class="function"><span class="keyword">func</span> <span class="title">kolodaBackgroundCardAnimation</span><span class="params">(koloda: KolodaView)</span></span> -&gt; <span class="type">POPPropertyAnimation</span>?</div></pre></td></tr></table></figure>
<p>在这个方法中，POPAnimation 被创建用来传给 Koloda。然后当用户滑动卡片时， Koloda 用它来给 frame 的改变做动画。如果代理方法返回 nil，意味着 Koloda 使用默认的动画。</p>
<p>下面代码就是这个代理方法的实现</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">kolodaBackgroundCardAnimation</span><span class="params">(koloda: KolodaView)</span></span> -&gt; <span class="type">POPPropertyAnimation</span>? &#123;</div><div class="line"></div><div class="line">      <span class="keyword">let</span> animation = <span class="type">POPSpringAnimation</span>(propertyNamed: kPOPViewFrame)</div><div class="line"></div><div class="line">      animation.springBounciness = frameAnimationSpringBounciness</div><div class="line"></div><div class="line">      animation.springSpeed = frameAnimationSpringSpeed</div><div class="line"></div><div class="line">      <span class="keyword">return</span> animation</div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h2 id="怎样阻止背景卡片移动？"><a href="#怎样阻止背景卡片移动？" class="headerlink" title="怎样阻止背景卡片移动？"></a>怎样阻止背景卡片移动？</h2><p>同样我也添加了一个新的代理方法在新版的 Koloda 中</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">kolodaShouldMoveBackgroundCard</span><span class="params">(koloda: KolodaView)</span></span> -&gt; <span class="type">Bool</span></div></pre></td></tr></table></figure>
<p>如果返回 false就意味着交互动画被禁用，背景卡片不会随着顶层卡片移动而移动。</p>
<p>下面就是返回 false 时的动画效果：</p>
<p><img src="https://yalantis.com/media/content/ckeditor/2015/08/11/static_bg.gif" alt=""></p>
<p>这是返回 true 的动画效果</p>
<p><img src="https://yalantis.com/media/content/ckeditor/2015/08/11/v2.gif" alt=""></p>
<p>希望你能喜欢第二版的 Koloda，尽情使用它吧！</p>
<ul>
<li><a href="https://dribbble.com/shots/2189960-Koloda-Tinder-Like-component-for-IOS-Available-on-GitHub" target="_blank" rel="external">Dribbble</a></li>
<li><a href="https://github.com/Yalantis/Koloda" target="_blank" rel="external">GitHub</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个月前，我们发布了&lt;a href=&quot;https://yalantis.com/blog/how-we-built-tinder-like-koloda-in-swift/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;how we developed Tinder-like Koloda in Swift&lt;/a&gt;(&lt;a href=&quot;http://0.0.0.0:4000/2015/08/21/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BC%20Tinder%20%E7%9A%84%E4%BA%A4%E4%BA%92%E5%8A%A8%E7%94%BB/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;如何创建一个类似 Tinder 的交互动画[译]&lt;/a&gt;)。在开发者与设计师社区这个动画都受到强烈的欢迎，所以我们决定继续改善它。&lt;br&gt;
    
    </summary>
    
      <category term="翻译" scheme="https://vongloo.me/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://vongloo.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>如何创建一个类似 Tinder 的交互动画[译]</title>
    <link href="https://vongloo.me/2015/08/21/How-We-Built-Tinder-Like-Koloda-Animation-in-Swift-Chinese-Translation/"/>
    <id>https://vongloo.me/2015/08/21/How-We-Built-Tinder-Like-Koloda-Animation-in-Swift-Chinese-Translation/</id>
    <published>2015-08-20T16:09:54.000Z</published>
    <updated>2019-03-03T15:42:37.279Z</updated>
    
    <content type="html"><![CDATA[<p>有时候我认为 Tinder 不仅仅让人们遇见彼此，更多的是它引领了一种交互设计趋势。所以我们非常肯定地说 Tinder 已经完成了他的历史使命，可以安心等待着下一个 Tinder 出现。<br><a id="more"></a><br>原文:<a href="https://yalantis.com/blog/how-we-built-tinder-like-koloda-in-swift/" target="_blank" rel="external">How We Built Tinder-Like Koloda Animation in Swift</a></p>
<p>Tinder 的右滑喜欢，左滑忽略不仅仅在约会（pao）应用中很流行，在购物 App 中也很流行，比如<a href="https://fancy.com/about" target="_blank" rel="external">Fancy</a>，也是像 Tinder 一样是滑动喜欢的形式。他们之所以才用这种交互形式是因为这种卡片式的交互确实深得用户欢心。卡片上的内容吸引了用户的注意力促使他们去进行一系列操作，进而提高了用户参与度。<br>还有许多不同种类 App 也是用这种像 Tinder 一样的卡片式滑动交互的例子，比如<a href="https://liveuptop.com/" target="_blank" rel="external">Uptop</a>，就连谷歌浏览器 iOS 客户端也是用这种卡片形式来管理书签。</p>
<p><img src="http://img.cdn.punmy.cn/content_1__1_.gif" alt=""></p>
<p>我们把卡片式布局以及基于滑动的交互作为今年的交互设计趋势，我们的<a href="https://yalantis.com/blog/7-up-to-date-mobile-app-design-trends-2015/" target="_blank" rel="external">这篇文章</a>有相关介绍。之后我们的设计师Dmitry Goncharov创建了一个类似 Tinder 交互的动画，实际上他是故意这么做的。<br>我们把我们的这种类似 Tinder 基于卡片式的动画命名为<code>Koloda</code>，在乌克兰语中它的意思是甲板（卡片），听起来非常有趣。这个组件能够被不同 app 使用，如果加上约会（pao）地点的话，甚至在 Tinder 中也很实用。Dmitriy提出了这个概念，我们的iOS工程师实现了这个想法。详见<a href="https://github.com/Yalantis/Koloda" target="_blank" rel="external">GitHub</a>。（译者注：Objective-C 版详见<a href="https://github.com/wang9262/Koloda-ObjC" target="_blank" rel="external">这里</a>）。</p>
<h2 id="我们如何实现-Koloda-动画"><a href="#我们如何实现-Koloda-动画" class="headerlink" title="我们如何实现 Koloda 动画"></a>我们如何实现 Koloda 动画</h2><blockquote>
<ul>
<li>by Eugene Andreyev</li>
</ul>
</blockquote>
<p>Tinder的滑动喜欢界面被许多不同的 App 借鉴，也有一些现成的库来给开发者使用。首先，我看了<a href="https://github.com/modocache/MDCSwipeToChoose" target="_blank" rel="external">MDCSwipeToChoose</a>以及<a href="https://github.com/cwRichardKim/TinderSimpleSwipeCards" target="_blank" rel="external">TinderSimpleSwipeCards</a>，事实证明，它们并不能完美的实现我的需求。<br>我想要的动画要非常简单而且方便，就像UITableView 那样由数据源来驱动。因此，我创建了一个自定义组件来构建这个动画。主要分为如下三个部分：</p>
<ul>
<li><p>DraggableCardView：用来展示内容的卡片式图</p>
</li>
<li><p>OverlayView：遮罩视图，根据用户手势方向（左、右）来动态改变</p>
</li>
<li>KolodaView：用来控制加载和卡片之间的交互的视图<br><img src="http://img.cdn.punmy.cn/content_2__1_.gif" alt=""></li>
</ul>
<h2 id="DraggableCardView的实现"><a href="#DraggableCardView的实现" class="headerlink" title="DraggableCardView的实现"></a>DraggableCardView的实现</h2><p>正如我前面提到的那样，<code>DraggableCardView</code>是用来展示内容的卡片视图。网上有很多教程阐述了 Tinder 滑动动画的原理，我选择了其中一种解决方案，做了一些改动，然后利用<code>UIPanGestureRecognizer</code> 和 <code>CGAffineTransform</code>实现了 <code>DraggableCardView</code>。部分代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//译者注：原文是用 swift 写的，我索性翻译成了 OC，下同</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)panGestureRecognized:(<span class="built_in">UIPanGestureRecognizer</span> *)pan</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.xDistanceFromCenter = [pan translationInView:<span class="keyword">self</span>].x;</div><div class="line">    <span class="keyword">self</span>.yDistanceFromCenter = [pan translationInView:<span class="keyword">self</span>].y;</div><div class="line">    <span class="built_in">CGPoint</span> location = [pan locationInView:<span class="keyword">self</span>];</div><div class="line">    <span class="keyword">switch</span> (pan.state) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateBegan</span>:</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">self</span>.originalLocation = <span class="keyword">self</span>.center;</div><div class="line">            <span class="keyword">self</span>.dragBegin = <span class="literal">YES</span>;</div><div class="line">            </div><div class="line">            <span class="keyword">self</span>.animationDirection = location.y &gt;= <span class="keyword">self</span>.frame.size.height / <span class="number">2</span> ? <span class="number">-1.0</span> : <span class="number">1.0</span>;</div><div class="line">            </div><div class="line">            <span class="keyword">self</span>.layer.shouldRasterize = <span class="literal">YES</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateChanged</span>:</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">CGFloat</span> rotationStrength = MIN(<span class="keyword">self</span>.xDistanceFromCenter / <span class="keyword">self</span>.frame.size.width, kRotationMax);</div><div class="line">            <span class="built_in">CGFloat</span> rotationAngle = <span class="keyword">self</span>.animationDirection * kDefaultRotationAngle * rotationStrength;</div><div class="line">            <span class="built_in">CGFloat</span> scaleStrength = <span class="number">1</span> - ((<span class="number">1</span> - kScaleMin) * fabs(rotationStrength));</div><div class="line">            <span class="built_in">CGFloat</span> scale = MAX(scaleStrength, kScaleMin);</div><div class="line">            </div><div class="line">            <span class="keyword">self</span>.layer.rasterizationScale = scale * [<span class="built_in">UIScreen</span> mainScreen].scale;</div><div class="line">            </div><div class="line">            <span class="built_in">CGAffineTransform</span> transform = <span class="built_in">CGAffineTransformMakeRotation</span>(rotationAngle);</div><div class="line">            <span class="built_in">CGAffineTransform</span> scaleTransform = <span class="built_in">CGAffineTransformScale</span>(transform, scale, scale);</div><div class="line">            </div><div class="line">            <span class="keyword">self</span>.transform = scaleTransform;</div><div class="line">            <span class="keyword">self</span>.center = <span class="built_in">CGPointMake</span>(<span class="keyword">self</span>.originalLocation.x + <span class="keyword">self</span>.xDistanceFromCenter,</div><div class="line">                                      <span class="keyword">self</span>.originalLocation.y + <span class="keyword">self</span>.yDistanceFromCenter);</div><div class="line">            [<span class="keyword">self</span> updateOverlayWithFinishPercent:<span class="keyword">self</span>.xDistanceFromCenter / <span class="keyword">self</span>.frame.size.width];</div><div class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(cardView:draggedWithFinishPercent:)]) &#123;</div><div class="line">                [<span class="keyword">self</span>.delegate cardView:<span class="keyword">self</span> draggedWithFinishPercent:MIN(fabs(<span class="keyword">self</span>.xDistanceFromCenter * <span class="number">100</span> / <span class="keyword">self</span>.frame.size.width), <span class="number">100</span>)];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateEnded</span>:</div><div class="line">        &#123;</div><div class="line">            [<span class="keyword">self</span> swipeMadeAction];</div><div class="line">            <span class="keyword">self</span>.layer.shouldRasterize = <span class="literal">NO</span>;</div><div class="line">        &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当用户拖拽最前面的卡片视图时,它就离事件触发边缘越来越近，当达到触发边缘时，它就从屏幕中消失了。到触发边缘的距离用百分比来表示。在顶部卡片视图被拖拽的过程中，底部的卡片也会有相应的动作，要么是放大要么是缩小。换而言之，顶层和底层的动画是同步的。<br>同样遮罩也会在移动的时候实时更新，在实时更新动画过程中，它的透明度从5%（几乎不可见）到100%（清晰可见）。</p>
<p>为了防止卡片边缘变得锯齿化，我使用了<code>layer</code>的<code>shouldRasterize</code>属性。同时我也要考虑到当卡片没有被拖拽到触发点时如何重置它的状态。我使用了 <code>Facebook</code> 的 <a href="https://github.com/facebook/pop" target="_blank" rel="external">Pop</a>框架来设置其重置状态以及恢复上一步(undo)的动画。如果你有印象的话，所有<a href="https://www.facebook.com/paper" target="_blank" rel="external">Paper</a>应用中的动画和过渡转换动画都是使用这个框架来完成的。它支持动态弹性动画，也允许创建任何物理现实中的交互动画，可喜的是它仅仅只需要很少的几行代码就可以实现。</p>
<h2 id="OverlayView的实现"><a href="#OverlayView的实现" class="headerlink" title="OverlayView的实现"></a>OverlayView的实现</h2><p><code>OverlayView</code>是在顶部卡片 View 进行动画时被添加上去的，它只有一个名为<code>overlayState</code>的属性，这个属性有两个可选值：当用户拖动卡片到左边，<code>overlayState</code>就添加一个红色的遮罩到卡片视图上，反之用户拖拽到右边，这个属性被设置为另一个可选值，使得卡片的遮罩变成绿色。（译者注：我在把代码翻译成 OC 时对变量名做了些许改动，<code>overlayState</code>改成了<code>type</code>，具体参见 GitHub，下同）。<br>为了实现遮罩的自定义行为，我们可以继承<code>OverlayView</code>，然后重载<code>overlayState</code>的<code>didSet</code>方法。大致代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//.h</span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"OverlayView.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CustomOverlayView</span> : <span class="title">OverlayView</span></span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="comment">//.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">"CustomOverlayView.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CustomOverlayView</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIImageView</span> *imageView;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CustomOverlayView</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setType:(OverlayType)type</div><div class="line">&#123;</div><div class="line">    <span class="keyword">switch</span> (type) &#123;</div><div class="line">        <span class="keyword">case</span> OverlayTypeLeft:</div><div class="line"></div><div class="line">            <span class="keyword">self</span>.imageView.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"noOverlayImage"</span>];</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> OverlayTypeRight:</div><div class="line">            <span class="keyword">self</span>.imageView.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"yesOverlayImage"</span>];</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> OverlayTypeNone:</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">self</span>.imageView.image = <span class="literal">nil</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h2 id="KolodaView的实现"><a href="#KolodaView的实现" class="headerlink" title="KolodaView的实现"></a>KolodaView的实现</h2><p><code>KolodaView</code>类负责卡片的加载以及管理工作。你可以通过代码或者<code>Interface Builder</code>来实现。然后你就可以为其指定<code>dataSource</code>以及<code>delegate</code>(可选)。最后你应该实现<code>dataSource</code>中的如下方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SwipeViewDataSource</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@required</span></div><div class="line">- (<span class="built_in">NSUInteger</span>)swipeViewNumberOfCards:(SwipeView *)swipeView;</div><div class="line">- (<span class="built_in">UIView</span> *)swipeView:(SwipeView *)swipeView</div><div class="line">          cardAtIndex:(<span class="built_in">NSUInteger</span>)index;</div><div class="line">- (OverlayView *)swipeView:(SwipeView *)swipeView</div><div class="line">        cardOverlayAtIndex:(<span class="built_in">NSUInteger</span>)index;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>我们使用了代理方法而不是回调(block)的方式来获取相关数据。</p>
<h2 id="几何解释"><a href="#几何解释" class="headerlink" title="几何解释"></a>几何解释</h2><p>还记得我们关于开发安卓<code>Guillotine</code>菜单动画的<a href="https://yalantis.com/blog/how-we-developed-the-guillotine-menu-animation-for-android/" target="_blank" rel="external">故事</a>吗？在那个故事中我们的安卓工程师Dmytro Denysenko采用高中数学知识来计算一个自定义的差值。几何知识在我的 iOS 开发生涯中也发挥了很大的作用！</p>
<p>动画过程中最有趣的一件事就是当用户在拖拽顶部卡片时，下面的卡片也会跟着移动。我想让<code>Koloda</code>动画更加灵活，所以我简单地指定了想要在屏幕上展示的卡片数，然后我就拿出纸就开始计算。</p>
<p><img src="https://yalantis.com/media/content/ckeditor/2015/07/02/img_2556_HD6OoTz.jpg" alt=""></p>
<p><code>KolodaView</code>需要展示位于顶层卡片之下的卡片正确的数量，然后让它们在动画开始的时候占据正确的位置。为了实现它，我需要计算所有卡片的<code>frame</code>，这个是通过给其中每个元素添加对应的序号来实现的。举个例子，第一个卡片视图的序号是[i]，那么第二个就是[i+1],第三个就是[i+2],以此类推。<br>如下图所示，你可以清晰的看到第一张卡片的<code>frame</code>和<code>size</code>的计算过程。</p>
<p><img src="https://yalantis.com/media/content/ckeditor/2015/07/02/cards_blueprint.jpg" alt=""></p>
<p>代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGRect</span>)frameForCardAtIndex:(<span class="built_in">NSUInteger</span>)index</div><div class="line">&#123;</div><div class="line">    <span class="built_in">CGFloat</span> bottomOffset = <span class="number">0</span>;</div><div class="line">    <span class="built_in">CGFloat</span> topOffset = kBackgroundCardsTopMargin * (<span class="keyword">self</span>.visibleCardsCount - <span class="number">1</span>);</div><div class="line">    <span class="built_in">CGFloat</span> xOffset = kBackgroundCardsLeftMargin * index;</div><div class="line">    <span class="built_in">CGFloat</span> scalePercent = kBackgroundCardsScalePercent;</div><div class="line">    <span class="built_in">CGFloat</span> width = <span class="built_in">CGRectGetWidth</span>(<span class="keyword">self</span>.frame) * pow(scalePercent, index);</div><div class="line">    <span class="built_in">CGFloat</span> height = (<span class="built_in">CGRectGetHeight</span>(<span class="keyword">self</span>.frame) - bottomOffset - topOffset) * pow(scalePercent, index);</div><div class="line">    <span class="built_in">CGFloat</span> multiplier = index &gt; <span class="number">0</span> ? <span class="number">1.0</span> : <span class="number">0.0</span>;</div><div class="line">    <span class="built_in">CGRect</span> previousCardFrame = index &gt; <span class="number">0</span> ? [<span class="keyword">self</span> frameForCardAtIndex:MAX(index - <span class="number">1</span>, <span class="number">0</span>)] : <span class="built_in">CGRectZero</span>;</div><div class="line">    <span class="built_in">CGFloat</span> yOffset = (<span class="built_in">CGRectGetHeight</span>(previousCardFrame) - height + previousCardFrame.origin.y</div><div class="line">                       + kBackgroundCardsTopMargin) * multiplier;</div><div class="line">    <span class="built_in">CGRect</span> frame = <span class="built_in">CGRectMake</span>(xOffset, yOffset, width, height);</div><div class="line">    <span class="keyword">return</span> frame;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们知道了序号、卡片<code>frame</code>以及动画结束的百分比，我们就可以很轻松的计算出当上一个卡片被滑出屏幕时下一个卡片应该出现的位置。之后，我们也可以实现一个百分比驱动动画（PercentDrivenAnimation）。<br>最后我给这个简单易用的组件取了个有趣的名字–Koloda。任何开发者都可以自定义它，通过设置其内容视图以及遮罩视图。过些时候，我想实现自定义动画以及<code>frame</code>的计算方式，这样开发者们就可以使用他们自己别具一格的组件。<br>KolodaView 的代码详见<a href="https://github.com/Yalantis/Koloda" target="_blank" rel="external">GitHub</a>。</p>
<blockquote>
<ul>
<li>译者注：ObjC 版本可以参见<a href="https://github.com/wang9262/Koloda-ObjC" target="_blank" rel="external">Koloda-ObjC</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候我认为 Tinder 不仅仅让人们遇见彼此，更多的是它引领了一种交互设计趋势。所以我们非常肯定地说 Tinder 已经完成了他的历史使命，可以安心等待着下一个 Tinder 出现。&lt;br&gt;
    
    </summary>
    
      <category term="翻译" scheme="https://vongloo.me/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://vongloo.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>AVFoundation和 GPUImage初探</title>
    <link href="https://vongloo.me/2014/08/24/AVFoundation-And-GPUImage/"/>
    <id>https://vongloo.me/2014/08/24/AVFoundation-And-GPUImage/</id>
    <published>2014-08-23T16:41:08.000Z</published>
    <updated>2019-03-03T15:42:37.279Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做视频相关的东西，然后熟悉了一下AVFoundation框架，以及强大的开源库GPUImage。在这里记录这个过程中遇到的一些问题，以及解决的方法。</p>
<a id="more"></a>
<h3 id="AVFoundation的一些基本概念"><a href="#AVFoundation的一些基本概念" class="headerlink" title="AVFoundation的一些基本概念"></a>AVFoundation的一些基本概念</h3><p>根据苹果的官方文档，AVFoundation是用来播放和创建实时的视听媒体数据的框架，同时提供Objective-C接口来操作这些视听数据，比如编辑，旋转，重编码。本文着重讲的是视频的录制和编辑和GPUImage的一些简单使用，其他的都是一笔带过。来看下苹果文档的一个框架图。</p>
<p><img src="http://ww2.sinaimg.cn/large/ba81ca29gw1evcbinsawmj20qj0go0tt.jpg" alt=""></p>
<h4 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h4><ul>
<li><code>AVAsset</code></li>
<li><code>AVAssetTrack</code></li>
<li><code>AVComposition</code></li>
<li><code>AVVideoComposition</code></li>
<li><code>AVAudioMix</code></li>
<li><code>AVMutableAudioMixInputParameter</code></li>
<li><code>AVMutableVideoCompositionInstrution</code> </li>
<li><code>AVMutableVideoCompositionLayerInstrution</code></li>
</ul>
<p>简单的播放可以使用MPMoviePlayerController或者MPMovieViewController就行,简单的录<br>制可以直接使用UIImagePickerController。同样简单的声音播放直接使用AVAudioPlayer，简单的录制直接使用AVAduioRecorder。如果你想要有更多的操作，可使用各种复杂的方式来控制播放，比如在同一时刻为同一个asset的不同片段使用不同的分辨率渲染，playitem来管理asset的呈现状态和方式,playitemtrack管理asset中的轨道（track）状态。</p>
<p>在AVFoudation框架中最核心的类就是AVAsset，他是由一系列的媒体数据组成的，包括但不限于:时间、大小(size)、标题、字幕等。其中每一个单独的媒体数据称为轨道(track)。同样剪辑操作中，AVMutableComposition是一个核心类。</p>
<p><img src="http://ww3.sinaimg.cn/large/ba81ca29gw1evcbjm927vj20jm0hsmzv.jpg" alt=""></p>
<p>这里又一个重要的东西就是CMTime,它是一个结构体，定义如下:</p>
<p>typedef struct<br>{<br>    CMTimeValue    value;<br>    CMTimeScale    timescale;<br>    CMTimeFlags    flags;<br>    CMTimeEpoch    epoch;<br>} CMTime;<br>通常时间是等于value/timescale的，所以两个有相同时间的CMTime它们的timescale并不一定相同。关于更多CMTime的内容可以看<a href="https://developer.apple.com/library/ios/documentation/CoreMedia/Reference/CMTime/Reference/reference.html#//apple_ref/doc/uid/TP40009748" target="_blank" rel="external">这里</a>。</p>
<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><h4 id="视频的录制"><a href="#视频的录制" class="headerlink" title="视频的录制"></a>视频的录制</h4><p>这里用的是系统原生录制,关于录制通常用到的几个类就是AVCaptureDevice、<br>AVCaptureSession、AVCaptureDeviceInput、AVCaptureOutput,同样，来看一张图。</p>
<p><img src="http://ww3.sinaimg.cn/large/ba81ca29gw1evcbk17v07j20kw0hxach.jpg" alt=""></p>
<p>一般来说，如果你想修改视频的相关信息，如拍摄地点等，可以拿到output的metadata来修改。大致代码如下:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableArray</span> *array = [output.metadta mutableCopy];</div><div class="line"><span class="built_in">AVMutableMetadataItem</span> *item = [[<span class="built_in">AVMutableMetadataItem</span> alloc] init];</div><div class="line">item.keyspace = ...;</div><div class="line">item.key = ...;</div><div class="line">item.value = ...;</div><div class="line">[array addObject:item];</div><div class="line">output.metadata = array;</div></pre></td></tr></table></figure>
<p>如果录制时候想要得到指定的视频size必须先指定分辨率，像这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if ([session canSetSessionPreset:AVCaptureSessionPreset640x480])&#123; </div><div class="line"></div><div class="line">    session.sessionPreset = AVCaptureSessionPreset640x480;</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">    //设置失败</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>切换摄像头或其他输入源必须在beginConfiguration和commitConfiguration之间来处理，大致是这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[session beginConfiguration];</div><div class="line">//移除某个输入源</div><div class="line">//再添加某个输入源</div><div class="line">//再为新添加的输入源进行必要的相关设置</div><div class="line">//...其他操作</div><div class="line">[session commitConfiguration];</div></pre></td></tr></table></figure>
<p>如果想对实时视频帧进行相关的渲染操作,通过 setSampleBufferDelegate:queue:方法来为output设置代理，同时必须指定queue，代理方法将会在这些queue上面被调用。可以在自己的类里面实现AVCaptureVideoDataOutput的协议方法,通过实现<br>captureOutput:didOutputSampleBuffer:fromConnection:来拿到视频的每一帧，默认情况下这些视频帧会被用最有效的格式来输出到output,当然也可以在拍摄之前就为output进行相关设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">AVCaptureVideoDataOutput *videoDataOutput = [AVCaptureVideoDataOutput new];</div><div class="line">NSDictionary *newSettings =@&#123; (NSString *)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA) &#125;;</div><div class="line">videoDataOutput.videoSettings = newSettings;</div></pre></td></tr></table></figure>
<p>说了这么多，感觉很虚，还是直接上代码，将以上部分衔接起来</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//自定义方法，小演示只添加了视频，没有添加声音，添加声音类似</span></div><div class="line">- (<span class="keyword">void</span>)yourCustomMethodName&#123;</div><div class="line">    <span class="built_in">AVCaptureSession</span> *session = [[<span class="built_in">AVCaptureSession</span> alloc] init];</div><div class="line">    <span class="keyword">if</span> ([session canSetSessionPreset:<span class="built_in">AVCaptureSessionPreset640x480</span>])&#123; </div><div class="line"></div><div class="line">            session.sessionPreset = <span class="built_in">AVCaptureSessionPreset640x480</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//设置失败</span></div><div class="line">        &#125;</div><div class="line">    <span class="built_in">AVCaptureDevice</span> *device =</div><div class="line">            [<span class="built_in">AVCaptureDevice</span> defaultDeviceWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</div><div class="line"></div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">AVCaptureDeviceInput</span> *input =</div><div class="line">            [<span class="built_in">AVCaptureDeviceInput</span> deviceInputWithDevice:device error:&amp;error];</div><div class="line">    <span class="keyword">if</span> (!input) &#123;</div><div class="line">        <span class="comment">// Handle the error appropriately.</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(session canAddInput:input)&#123;</div><div class="line">        [session addInput:input];</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">AVCaptureVideoDataOutput</span> *output = [[<span class="built_in">AVCaptureVideoDataOutput</span> alloc] init];</div><div class="line">    <span class="keyword">if</span>(session canAddOutput:output)&#123;</div><div class="line">        [session addOutput:output];</div><div class="line">    &#125;</div><div class="line">    output.videoSettings =@&#123; (<span class="built_in">NSString</span> *)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA) &#125;;</div><div class="line">    <span class="comment">//设置帧率(FPS),每秒15帧</span></div><div class="line">    output.minFrameDuration = <span class="built_in">CMTimeMake</span>(<span class="number">1</span>, <span class="number">15</span>);</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"CustomQueue"</span>, <span class="literal">NULL</span>);</div><div class="line">    [output setSampleBufferDelegate:<span class="keyword">self</span> queue:queue];</div><div class="line">    dispatch_release(queue)</div><div class="line">    <span class="built_in">NSString</span> *mediaType = <span class="built_in">AVMediaTypeVideo</span>;</div><div class="line"></div><div class="line"> <span class="comment">//用来显示录制的实时画面</span></div><div class="line">    <span class="built_in">AVCaptureVideoPreviewLayer</span> *captureVideoPreviewLayer = [[<span class="built_in">AVCaptureVideoPreviewLayer</span> alloc] initWithSession:session];</div><div class="line">    [<span class="keyword">self</span>.view.layer addSublayer:captureVideoPreviewLayer];</div><div class="line"></div><div class="line">    <span class="comment">//用户是否允许启用摄像头</span></div><div class="line">    [<span class="built_in">AVCaptureDevice</span> requestAccessForMediaType:mediaType completionHandler:^(<span class="built_in">BOOL</span> granted) &#123;</div><div class="line">        <span class="keyword">if</span> (granted)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//Granted access to mediaType</span></div><div class="line">            [<span class="keyword">self</span> setDeviceAuthorized:<span class="literal">YES</span>];</div><div class="line">            [session startRunning];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="comment">//Not granted access to mediaType</span></div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [[[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@"AVCam!"</span></div><div class="line">                                        message:<span class="string">@"AVCam doesn't have permission to use Camera, please change privacy settings"</span></div><div class="line">                                       delegate:<span class="keyword">self</span></div><div class="line">                              cancelButtonTitle:<span class="string">@"OK"</span></div><div class="line">                              otherButtonTitles:<span class="literal">nil</span>] show];</div><div class="line">                    [<span class="keyword">self</span> setDeviceAuthorized:<span class="literal">NO</span>];</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//协议方法,获取每一帧，将每一帧转换成图片，你也可以进行其他的渲染操作</span></div><div class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureOutput</span> *)captureOutput</div><div class="line">         didOutputSampleBuffer:(<span class="built_in">CMSampleBufferRef</span>)sampleBuffer</div><div class="line">         fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection &#123;</div><div class="line"></div><div class="line">    <span class="built_in">UIImage</span> *image = imageFromSampleBuffer(sampleBuffer);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面演示了如何取得每一帧实时画面,如果想要直接存成视频可使用AVCaptureMovieFileOutput,如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AVCaptureMovieFileOutput *movieFileOutput = [[AVCaptureMovieFileOutput alloc] init];</div><div class="line">NSURL *fileURL = ...;    //存放位置</div><div class="line">//指定代理</div><div class="line">[aMovieFileOutput startRecordingToOutputFileURL:fileURL recordingDelegate:delete];</div><div class="line">//也可以为其指定outputSettings</div><div class="line">同样代理必须实现协议方法captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error:,</div></pre></td></tr></table></figure>
<p>当然还有其他各种具体的设置，如对焦、曝光、闪光灯以及白平衡等等均可以通过KVO来设置，每次设置前都加一个判断，是否支持指定模式,在这里不做详细叙述了,这里你可以看到<a href="https://developer.apple.com/library/ios/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/04_MediaCapture.html#//apple_ref/doc/uid/TP40010188-CH5-SW14" target="_blank" rel="external">更多</a>。</p>
<h4 id="视频的剪辑"><a href="#视频的剪辑" class="headerlink" title="视频的剪辑"></a>视频的剪辑</h4><p>视频的剪辑包括但不限于:裁剪、旋转(改变transform)、添加水印、添加字幕、合并等。关于剪辑，无非就是取出视频中的轨道(视频和音频),然后对轨道进行一系列的操作变可以得到各种想要的效果。首先我们先来看下面一张图</p>
<p><img src="http://ww3.sinaimg.cn/large/ba81ca29gw1evcblhcl2ej20p50eyjvj.jpg" alt=""></p>
<p>AVMutableComposition是整个视频剪辑过程中的一个核心，下面着重讲解这个类。AVMutableComposition和AVAsset一样含有多个视/音频轨道，但是更重要的是，它可以将多个AVAssetTrack合并到一起，比如在视频合并时，可以直接将多段视频拼接到一个轨道(AVMutableCompositonTrcak)，音频也一样。通过借助AVMutableVideoComposition和AVMutableAudioMix来设置每一段的视/音频的属性，从而达到想要的视听效果，比如视频切换处的淡入淡出，声音的渐变，字幕等等。<br>关于上图的解释:首先通过将asset里面的轨道加载到composition的各轨道，然后通过audioMix和videoComposition对某个轨道进行对应操作,设置其相关属性。其中要用到的具体方法可以参见<a href="https://developer.apple.com/library/ios/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/03_Editing.html#//apple_ref/doc/uid/TP40010188-CH8-SW1" target="_blank" rel="external">这里</a>。</p>
<p>其中图中1，2，3用到的方法为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[1]</div><div class="line">[mutableComposition addMutableTrackWithMediaType:AVMediaTypeVideo preferredTrackID:kCMPersistentTrackID_Invalid]</div><div class="line">[2]</div><div class="line">[AVMutableAudioMixInputParameters audioMixInputParametersWithTrack:mutableCompositionAudioTrack];`</div><div class="line">[3]</div><div class="line">[AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:mutableCompositionVideoTrack]</div></pre></td></tr></table></figure>
<p>关于视频的剪辑的代码可以参见苹果给出的官方<a href="https://developer.apple.com/library/ios/samplecode/AVSimpleEditoriOS/Introduction/Intro.html#//apple_ref/doc/uid/DTS40012797" target="_blank" rel="external">Demo</a>以及Raywendrich上的两篇文章<a href="http://www.raywenderlich.com/13418/how-to-play-record-edit-videos-in-ios" target="_blank" rel="external">1</a>,<a href="http://www.raywenderlich.com/30200/avfoundation-tutorial-adding-overlays-and-animations-to-videos" target="_blank" rel="external">2</a>。</p>
<h3 id="GPUImage"><a href="#GPUImage" class="headerlink" title="GPUImage"></a>GPUImage</h3><p>什么?!你没听说过GPUImage?!那你赶紧去看看它的<a href="https://github.com/BradLarson/GPUImage/blob/master/README.md#overview" target="_blank" rel="external">相关介绍</a>。GPUImage是一个基于OpenGL ES的一个强大的图像/视频处理库,封装好了各种滤镜同时也可以编写自定义的滤镜。至于他到底是如何强大,用了就知道。在这篇文章不是为了介绍它，而是列出一些我在使用过程中遇到的问题和解决方法。</p>
<h4 id="分段录制"><a href="#分段录制" class="headerlink" title="分段录制"></a>分段录制</h4><p>在使用GPUImageVideoCamera来录制的时候,可能需要分段录制,在GPUImage给出的视频录制Demo中直接只是录制一次，然而有时候需求可能是要录制多次，如果此时按照Demo的方法每次录制都要创建一个movieWriter,这样子的话每次都会在重新创建movieWriter并将它设置为videoCamera的audioEncodingTarget时候，界面都会卡顿一下，这是什么原因呢？因为videoCamera默认是不录制声音的，而每次创建movieWriter的时候都用到了movieWriter.hasAudioTrack = YES;,吊用这个之后videoCamera会自动去添加声音输入源,准备一些数据，所以这个过程会导致界面卡顿一下？这该怎么办呢？如果你有进到videoCamera的头文件去看的话你会发现这么一个方法和它的注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//Add audio capture to the session. Adding inputs and outputs freezes </div><div class="line">//the capture session momentarily, so you can use this method to add </div><div class="line">//the audio inputs and outputs early, if you’re going to set the </div><div class="line">//audioEncodingTarget later. Returns YES is the audio inputs and </div><div class="line">//outputs were added, or NO if they had already been added.</div><div class="line"></div><div class="line">-(BOOL)addAudioInputsAndOutputs;</div></pre></td></tr></table></figure>
<p>注释的大意是:录制的时候添加声音,添加输入源和输出源会暂时会使录制暂时卡住,所以在要使用声音的情况下要先调用该方法来防止录制被卡住。这不刚好就解决了上面的这个问题吗？所以问题就迎刃而解了,因为没看到这个,走了不少弯路,浪费了好长时间。</p>
<p>关于分段录制,可能有这么一个需求就是所有片段都是存于一个文件中而不是录制完成后将各段合并到一个视频文件中。这两个东西或许会帮到你<a href="http://blog.csdn.net/whf727/article/details/18702643" target="_blank" rel="external">分段录制的实现</a>,<a href="https://github.com/leanlyne/GPUImageExtend" target="_blank" rel="external">GPUImageExtend</a>。前者是基于系统的分段录制的实现,后者是GPUImageMoiveWriter的一个子类。</p>
<h4 id="所见即所得"><a href="#所见即所得" class="headerlink" title="所见即所得"></a>所见即所得</h4><p>在录制的时候,使用GPUImageView来显示,因为给GPUImageView设置的大小是320*320的,如果不设置它的填充模式(fillMode)它是默认使用kGPUImageFillModePreserveAspectRatio即保持长宽比,其余空白处使用背景色填充,如果要设置成方形就得使用kGPUImageFillModePreserveAspectRatioAndFill,但是这个时候问题又来了假设你是用的录制分辨率是960x540,显示的画面则只会显示中间的540x540的画面,这个时候如果movieWriter的size设置为540x540,则最后保存的视频是失真的因为960被压到了540，整个画面变扁了。这个时候有两种解决方案</p>
<ul>
<li>1.使用GPUImageCropFilter,通过设置其cropRegion来裁出中间540x540部分。关于cropRegion要注意它是一个CGRect,它对坐标系做了一个归一化处理,所以让所有的取值都在0.0~1.0范围内,比如960x540裁剪至中间540x540部分则cropRegion为(0,((960-540)/2)/960,1,540/960)</li>
<li>2.改变videoComposition的perferTransfom使其只显示中间的540x540。<br>这样就完成了所见即所得。</li>
</ul>
<p>关于GPUImage的实时滤镜添加或给已存在的视频添加滤镜,Demo都给出了详细过程,依葫芦画瓢即可。有一点要注意的是,在一些操作完成的时候注意removeTarget,还有就是在使用movieFile来播放已存在视频并添加滤镜的时候是没有声音的,这是这个库的一个缺陷,Github上有人提了这个<a href="https://github.com/BradLarson/GPUImage/issues/458" target="_blank" rel="external">issue</a>和<a href="https://gist.github.com/pgodino/3819907" target="_blank" rel="external">一些解决办法</a>。同时在用movieFile处理视频的时候在切换滤镜的时候最好先cancelProcessing不然会有黑屏或卡顿现象出现。同样如果你是用老版本的GPUImage的时候,可能会遇到第一帧是红色的现象,有人提出这个issue后,作者修复了这个bug,切换到最新版的时候就不会有这种情况发生。发生这种情况的原因是视频掉帧,导致音频和视频不同步。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>AVFoundation还是有很多东西去做深层次的挖掘,GPUImage也是一样,有了这个强大的库,解决一些事情节省了大量时间。这次仅仅是一个小小的尝试,对于很多东西都是浅尝则止,文中难免会有错误,欢迎在评论中指正。如果你在使用GPUImage和AVFoundation有什么好的心得或者对一些问题有相应的解决方案,不妨在评论中分享一下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做视频相关的东西，然后熟悉了一下AVFoundation框架，以及强大的开源库GPUImage。在这里记录这个过程中遇到的一些问题，以及解决的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="框架学习" scheme="https://vongloo.me/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="原创" scheme="https://vongloo.me/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="AVFoundation" scheme="https://vongloo.me/tags/AVFoundation/"/>
    
      <category term="GPUImage" scheme="https://vongloo.me/tags/GPUImage/"/>
    
  </entry>
  
  <entry>
    <title>高效利用你的Xcode[译]</title>
    <link href="https://vongloo.me/2014/07/23/Using-Xcode-Efficiently/"/>
    <id>https://vongloo.me/2014/07/23/Using-Xcode-Efficiently/</id>
    <published>2014-07-23T15:37:48.000Z</published>
    <updated>2019-03-03T15:42:37.279Z</updated>
    
    <content type="html"><![CDATA[<p>好莱坞电影里经常看到黑客们手指在键盘上飞速跳跃,同时终端上的代码也随着飞舞。如果你也想像电影里那样,那么你来对地方了。这篇教程将会教你在Xcode编程中更像程序员,你可以称之为魔法、疯狂的技术、好运当头或者黑客。毫无疑问,在学习完本教程之后,不管你怎么认为,都会感觉很酷,同时能更高效地运用Xcode,甚至可以通过这些新发现使你的代码免于毁灭。</p>
<a id="more"></a>
<p><a href="http://www.raywenderlich.com/72021/supercharging-xcode-efficiency" target="_blank" rel="external">原文地址</a></p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>要看起来很酷,所以有一些必不可少的因素.下面列出来的是其中一部分</p>
<ul>
<li>快速执行任务</li>
<li>精准</li>
<li>简洁美观的代码</li>
</ul>
<p>要表现地更酷,你可以试着不用鼠标或者触摸板来完成教程中的每一个任务.学习之旅将从学习一些实用的Xcode功能开始,然后通过修复一些在CardTilt中的一些bug来训练。最后你将整理一下你的代码,使整个界面看起来更整洁。在学习该教程时,要记住:它不是教你做一个app,而是教你比以前更有效地利用Xcode来开发app。这篇教程建立在你对Xcode有一个基本的了解的基础上,然后着重于提高你的工作效率。每个人都有自己的编程习惯,本教程并非强制你形成某种风格。自始至终,本教程中你会看到某些命令的替代品,随着本教程的学习,请集中精力在提炼和形成你自己的编程风格,不要让微小的错误影响你。</p>
<p>如果你对于Xcode不是很熟悉,建议先学习下面两篇教程。(<a href="http://www.raywenderlich.com/38557/learn-to-code-ios-apps-1-welcome-to-programming" target="_blank" rel="external">教程1</a>和<a href="http://www.raywenderlich.com/1797/ios-tutorial-how-to-create-a-simple-iphone-app-part-1" target="_blank" rel="external">教程2</a>)</p>
<p>下载 <a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/05/CardTilt-starter.zip" target="_blank" rel="external">CardTilt-starter</a>,然后就可以愉快地写代码了。</p>
<h3 id="日常Xcode任务"><a href="#日常Xcode任务" class="headerlink" title="日常Xcode任务"></a>日常Xcode任务</h3><p>有一些在Xcode中你经常使用的技巧,这一部分让你更近距离的接触这些技巧,然后讲解一些潇洒应对它们的一些妙招。在这个过程中,你会在这些妙招的基础上发现使用它们的新方法。这些技巧将成为你编程工具腰带上的忍者之星。在Xcode中打开之前下载好的工程CardTilt,先不要急着去看代码,先将你Xcode的窗口和下图来一一对应。</p>
<p><img src="http://ww1.sinaimg.cn/large/ba81ca29gw1evcbnfyp6vj20jg0cydi3.jpg" alt=""></p>
<p>是不是发现你的窗口和图中并不对应,先别着急。在下面介绍的快捷键部分,你将会学到如何轻松地显示以及隐藏这些对应的窗口。</p>
<p>下面是组成窗口的每一个独立区域的快速浏览:</p>
<ul>
<li>The Toolbar(工具栏): 你选择视图,运行app,在不同布局界面切换的地方</li>
<li>The Navigation Area(导航区): 导航你整个工程,警告,报错等的地方</li>
<li>The Editing Area(编辑区): 所有奇迹诞生的地方,包括它上方的Jump bar</li>
<li>The Utility Area(工具区): 包含检测器和一些库</li>
<li>The Debugging Area(调试区): 包括调试窗口和变量检测器</li>
</ul>
<p>上面列出的所有视图区域都是Xcode的必要组成部分,它们也是在你开发过程中可能需要用到的,开发过程中通常不需要将他们一次性同时显示出来,下面将介绍一些快捷键,将会教你快速显示/隐藏这些视图区域。</p>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>在这一部分,你将首先学到怎么掌握这些快捷键,得益于一些模式,最有效的快捷键非常容易记。</p>
<p>第一个需要知道的是Xcode的各区域与修饰键的关系,下面是一个快速浏览</p>
<ul>
<li>Command (⌘):用来导航,控制导航区域</li>
<li>Alt (⎇): 控制右边的一些东西,比如Assistant Editor,utility editor</li>
<li>Control: 编辑区域上的Jump bar的一些交互</li>
</ul>
<p>第二个需要知道的时数字键和标签栏的关系,将数字键和上面提到的修饰键组合可以在标签页之间来回切换。通常数字键对应标签页的索引位置(从1开始),0通常用来显示/隐藏区域。它还能再直观一点吗?</p>
<p>下面是最常用的组合键:</p>
<ul>
<li>Command 1~ 8: 跳转到导航区的不同位置</li>
<li>Command 0 :显示/隐藏导航区</li>
<li>Command Alt 1~ 6:在不同检测器之间跳转</li>
<li>Command Alt 0: 显示/关闭工具区.</li>
<li>Control Command Alt 1~4: 在不同库之间跳转</li>
<li>Control 1~ 6: 在Jump bar的不同标签页的跳转。</li>
</ul>
<p><img src="http://ww2.sinaimg.cn/large/ba81ca29gw1evcbo88ow9j20jg0cywfq.jpg" alt=""></p>
<p>最后也是最简单的就是回车键,当它和Command组合使用时,可以是你在Xcode中不同编辑器来回切换.</p>
<ul>
<li>Command + Enter: 显示标准单窗口编辑器</li>
<li>Command Alt Enter:你可以猜下它的作用,它的功能是打开Assistant editor</li>
<li>Command Alt Shift Enter: 打开版本控制编辑器</li>
</ul>
<p>同样重要的是显示/隐藏调试区的快捷键是 Command + Shift + Y,要记住这个你可以通过这句话来记忆“Y is my code not working?”(译者注:Y谐音Why)。如果你忘记了一些快捷键,你可以在Xcode的菜单栏Navigate一项中找到大部分快捷键。在即将完成这一部分的学习之时,你会惊奇的发现你仅仅只是用了键盘就让Xcode发生这各种变换。</p>
<p><img src="http://ww4.sinaimg.cn/large/ba81ca29gw1evcbox6qvog20jg0cdtjr.gif" alt=""></p>
<h3 id="Xcode的行为"><a href="#Xcode的行为" class="headerlink" title="Xcode的行为"></a>Xcode的行为</h3><p>使用快捷键来管理Xcode的界面却是挺棒,有没有想过更棒的事情?比如让Xcode自动转换到你想看到的界面。接下来我们将学到更酷的东西。</p>
<p>幸运的是,Xcode提供的Behaviors(行为)可以让你轻易地实现上面的事情。它们是一组定义好的有指定事件触发的动作,比如build一个工程。这里的动作的范围从改变界面到运行一个自定义脚本文件。来看一个例子,快速修改下载好的工程的CTAppDelegate.m文件,使其运行时会生成调试窗口输出,用下面的方法替代didFinishLaunchingWithOptions方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</div><div class="line">&#123;</div><div class="line">    [[UIApplication sharedApplication] setStatusBarHidden:YES];</div><div class="line">    // Override point for customization after application launch.</div><div class="line">    NSLog(@&quot;Show me some output!&quot;);</div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行程序,然后仔细观察调试区,你会发现调试区随着app运行而出现,如下所示</p>
<p><img src="http://ww3.sinaimg.cn/large/ba81ca29gw1evcbphsi0bg20ko0cge81.gif" alt=""></p>
<p>来看看是什么定义了上面的事件,在Xcode-&gt;Behaviors-&gt;Edit Behaviors打开Behavior偏好设置,在左侧你将看到所有事件集合,在右边是该事件可以触发的一些列动作。点击Running栏下的Generates output,然后发现它被设置成用来显示调试区。</p>
<p><img src="http://ww4.sinaimg.cn/large/ba81ca29gw1evccgo1totj20ix0dw41j.jpg" alt=""></p>
<h4 id="一些推荐的行为"><a href="#一些推荐的行为" class="headerlink" title="一些推荐的行为"></a>一些推荐的行为</h4><p>根据你的开发环境,我推荐的两种不同的Generates output事件触发动作集。如果你有多个屏幕,试着使用第一种,如果是单显示器,试着调到第二种方法。</p>
<h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><p>如果你在两个或者多个屏幕上开发,把调试区放到第二屏幕是不是更加方便,你可以向下面这样设置</p>
<p><img src="http://ww3.sinaimg.cn/large/ba81ca29gw1evccho04c6j20ix0dw779.jpg" alt=""></p>
<p>现在,运行程序,然后你会看到一个分离的窗口出现,将它放到你的第二屏幕上,是不是效率高了不少?</p>
<h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>如果是单屏,通过隐藏工具板以及设置输出窗口占据整个调试区使输出窗口的有效区域最大化,设置如下</p>
<p><img src="http://ww2.sinaimg.cn/large/ba81ca29gw1evcbqrikydj20ix0dw779.jpg" alt=""></p>
<p>然后运行程序,然后观察Xcode,看它是不是按照你的命令在执行。</p>
<p><img src="http://ww1.sinaimg.cn/large/ba81ca29gw1evcbregci2g20ko0cgb29.gif" alt=""></p>
<p>当程序暂停的时候,你可能也想改变Xcode的行为,到Running栏下的Pauses事件,然后改变其设置,向下面这样:</p>
<p><img src="http://ww2.sinaimg.cn/large/ba81ca29gw1evcbrx8dbgj20i20dwacl.jpg" alt=""></p>
<p>现在无论何时你设置了断点,你将会得到一个新的名为fix的展示变量和输出窗口的标签页,然后自动导航到第一个issue。</p>
<p>你将要创建的最后一个行为是我个人最喜欢的一个,它是一个自定义行为—设置一个快捷键。当被触发的时候,它使Xcode转变到我指定的为下一次开发而优化的布局,名为Dev Mode。我们可以通过点击Behavior偏好设置的左下角的+,然后将其取名为Dev Mode,双击Dev Mode右边的Command (⌘)符号然后输入Command .来定义一个快捷键</p>
<p><img src="http://ww2.sinaimg.cn/large/ba81ca29gw1evcbsaehung206n01pt8s.gif" alt=""></p>
<p>接下来为该事件设置相应动作:</p>
<p><img src="http://ww3.sinaimg.cn/large/ba81ca29gw1evcbsoiwkdj20i20dwaci.jpg" alt=""></p>
<p>现在,只要你按下command .就会触发上面设置的动作,即出现一个相同的整洁的开发界面。</p>
<p>下面将介绍Xcode tab name,和行为配合起来使用堪称完美。</p>
<p>Xcode Tab Names(Xcode标签名):可以通过双击标签页的标题来修改标签页的名称,对于它本身来说是一个无用的功能,但是当它和行为结合起来使用时就变得非常强大了。<br>在上面的第二个例子中,当改变Pauses行为时,命名了一个叫fix的标签页,这就意味着当行为被触发时,Xcode将会使用fix标签页(如果存在),如果不存在,它会新建一个名为fix的标签页。<br>另一个例子就是多屏Starts行为,如果一个名为Debug的标签页在之前运行时被打开,它将会复用这个标签页而不是重新创建一个。<br>用这种方式,你可以创建非常有趣的行为。</p>
<p>到现在为止,我们可以花点时间来回顾一下刚才的行为,不要着急,本教程会等着你。</p>
<h3 id="小测验"><a href="#小测验" class="headerlink" title="小测验"></a>小测验</h3><p>在接下来的部分,你将在测验中用到上面所学到的技巧,然后在CardTilt项目中学到一些新的技巧。</p>
<p>运行CardTilt项目中，你看到如下画面</p>
<p><img src="http://ww3.sinaimg.cn/large/ba81ca29gw1evcbt784ipj20c20jkjtx.jpg" alt=""></p>
<p>它不是你期待看到的画面？是时候消灭这些bug了！</p>
<h4 id="锁定bug"><a href="#锁定bug" class="headerlink" title="锁定bug"></a>锁定bug</h4><p>app似乎在加载数据时出现了问题，你的任务就是消灭它们。打开CTMainViewController.m文件然后进入开发模式Dev Mode，快捷键为之前设置的command。注意viewDidload方法中的前几行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">self.dataSource = [[CTTableViewDataSource alloc] init];</div><div class="line">self.view.dataSource = self.dataSource;</div><div class="line">self.view.delegate = self;</div></pre></td></tr></table></figure>
<p>看起来CTTableViewDataSource实现了UITableViewDataSource协议，为tableview提供了数据。是时候展现你Xcode的技术了，按住command键，同时点击CTTableViewDataSource在编辑器中来打开CTTableViewDataSource.h。CTTableViewDataSource.m应该已经在你的Assistant Editor，如果不是这样的话，打开顶部的Jump Bar，像下图一一样切换到Assistant Editor的counterparts模式。</p>
<p><img src="http://ww2.sinaimg.cn/large/ba81ca29gw1evcbtr4c4aj20cd0cn76b.jpg" alt=""></p>
<p>翻看代码，你会发现数组members装载数据，loadData方法从bundle中加载数据至数组members。在assistant editor右边任意位置鼠标右击，选择Open in Primary Editor，就会在Primary Editor中打开CTTableViewDataSource.m文件，下面动画是该步骤的展示：</p>
<p><img src="http://ww2.sinaimg.cn/large/ba81ca29gw1evcbtr4c4aj20cd0cn76b.jpg" alt=""></p>
<p>为了看起来更酷炫，你可以在不用鼠标的情况下完成上面的所有事情，步骤如下：</p>
<ul>
<li>1.同时按住Command + Shift + O，在输入框中输入CTMainViewController.m，然后回车来打开该文件。</li>
<li>2.Command + . 进入Enter Dev模式 。</li>
<li>3.将鼠标放在 CTTableViewDataSource 上，然后按住Command + Control + J，跳转至CTTableViewDataSource定义处。</li>
<li>4.按住 Command + J, -&gt; 然后按下回车，来转换 assistant editor 的焦点</li>
<li>5.按住 ctrl +4 来下拉 Jump Bar，然后使用方向键和回车键来选择 counterparts</li>
<li>6.按住 Command + Alt，在 primary editor 中打开 CTTableViewDataSource.m 文件</li>
<li>7.上面的结果步骤看起来不呢么高效，但是它让你看起来很酷。</li>
</ul>
<h4 id="修复bug"><a href="#修复bug" class="headerlink" title="修复bug"></a>修复bug</h4><p>在self.members = json[@”Team”];打上断点来确定数据是否都被装载到数组members当中，然后运行程序。</p>
<p>如果对于基本的设置断点和调试不太熟悉，可以先看看<a href="http://www.raywenderlich.com/video-tutorials" target="_blank" rel="external">这篇教程</a>。</p>
<p>就像你之前在Xcode行为看到的一样，Generates output将首先被触发，紧接着Pause行为被触发。因为你之前在Pause有过自定义设置，所以Xcode会新建一个名为fix的标签页，它专为调试而设。</p>
<p>将目光切换到变量检测器variable inspector，你会发现数组members是nil，在loadData方法数组members被填充，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSDictionary *json = [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:&amp;error];</div><div class="line">self.members = json[@&quot;Team&quot;];</div></pre></td></tr></table></figure>
<p>在变量检测器中查看json，看其是否被正确加载，你会发现数据中的第一个值是@”RWTeam”而不是@”Team”，当加载数组members时，这个值是错的，找到了一个bug。</p>
<p>让我们按下面步骤来修复这个bug：</p>
<ul>
<li>使用command + .来进入开发模式</li>
<li>按住Command + Option + J跳至filter bar然后输入teammember</li>
<li>然后按住Alt同时点击TeamMembers.json在assistant editor来打开它</li>
<li>最后，使用”Team”来替换”RWTeam”</li>
</ul>
<p>下图是上面四步的一个动画</p>
<p><img src="http://ww2.sinaimg.cn/large/ba81ca29gw1evcbuh3yqrg20jg0bcu0y.gif" alt=""></p>
<p>现在移除断点，然后运行程序，它看起来应该像这个样子。</p>
<p><img src="http://ww4.sinaimg.cn/large/ba81ca29gw1evcbv2p9w1j20c20jkq5c.jpg" alt=""></p>
<p>是不是看起来比之前要好一点了，但是还是有一些bug，比如Ray和Brian的标题描述栏不见了。接下来我们通过修复这些bug来学到更多酷炫的技巧。</p>
<h3 id="加速"><a href="#加速" class="headerlink" title="加速"></a>加速</h3><p>你应该已经知道<code>UITableViewCells在tableView:cellForRowAtIndexPath:</code>方法中被加载，所以用Open Quickly来导航到该方法，然后按照下面步骤：</p>
<ul>
<li>按下Command + Shift + O来呼出Open Quickly</li>
<li>输入cellForRow</li>
<li>按下回车来打开它</li>
</ul>
<p>按住command然后点击setupWithDictionary来跳转至其定义处，然后你会发现一些用来加载描述的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSString *aboutText = dictionary[@&quot;about&quot;]; // Should this be aboot?</div><div class="line"> self.aboutLabel.text = [aboutText stringByReplacingOccurrencesOfString:@&quot;\\n&quot; withString:@&quot;\n&quot;];</div></pre></td></tr></table></figure>
<p>它使用dictionary[@”about”]中的数据来加载label。</p>
<p>接下来呼出Open Quickly，然后打开TeamMembers.json，使用alt + command在Assistant Editor中打开。检查about的值，然后你会发现有人将about拼写成了aboot，我们可以使用全局的Find and Replace来修复这个bug。当然你可以在文件中直接做这件事，但是使用find navigate看起来更酷。打开find navigate，然后通过顶部的jump bar切换到替换(replace)模式，输入aboot,然后回车。</p>
<p><img src="http://ww4.sinaimg.cn/large/ba81ca29gw1evcbvqwkkyj20c20jkq5c.jpg" alt=""></p>
<p>在TeamMembers.json文件之外还有一个地方使用到了aboot，别担心，选中CTCardCell.m的搜索结果，然后按下Delete，将鼠标移至replace filed，然后输入about，点击Replace All，一切完成。整个过程看起来是这个样子的：</p>
<p><img src="http://ww1.sinaimg.cn/large/ba81ca29gw1evcbxo000lg20jg0bc1l2.gif" alt=""></p>
<p>进阶技巧:使用 Command + Shift + Option + F 来打开 Find navigator 的替换模式，如果你嫌麻烦，也可以使用 Command + Shift + F 来打开 Find navigator 的查找模式，如果你还嫌麻烦，使用 command + 3 来打开 Find navigator，然后开启查找或者替换模式，选择一种最适合自己的方式就好。</p>
<p>运行程序，看起来是这样的</p>
<p><img src="http://ww4.sinaimg.cn/large/ba81ca29gw1evcbymqx48j20ah0hs76r.jpg" alt=""></p>
<h3 id="让设计师高兴"><a href="#让设计师高兴" class="headerlink" title="让设计师高兴"></a>让设计师高兴</h3><p>今天的调试任务到此就结束了，给自己一点掌声，然后开始运行程序。在你将它展示给别人之前，需要先确定app的界面是完美的。尤其当这个人是非常认真的设计师的时候，这一部分教你一些关于interface builder的技巧，让你变得更酷。</p>
<p>打开Mainstoryboard.storyboard，通常你想在打开interface builder的同时打开standard editor和工具区(utilities area)，所以我们可以自定义一个新的叫做IB Mode的行为，当你在看下面的自定义发放之前，试着自己创建一个然后自定义，不必要完全一致。</p>
<p><img src="http://ww4.sinaimg.cn/large/ba81ca29gw1evcbz07ee7j20gj0cewgq.jpg" alt=""></p>
<p>我将这个模式的快捷键设置为Command Option .，现在你将看到一个舒服的Interface Builder界面，看看CTCardCell。首先你想让mainView处于ContentView的正中央。有两种技巧可以完成这个需求：</p>
<ul>
<li>按住Control + Shift，然后在mainView的任意位置鼠标左击，你将看到一个弹出视图让你选择在光标下的所有视图，如下图所示：</li>
</ul>
<p><img src="http://ww2.sinaimg.cn/large/ba81ca29gw1evcbzzrf1dj205i0980t5.jpg" alt=""></p>
<p>这个方法让你轻松的就能选中mainView，尽管cardbg遮住了它。选中mainView之后，按住Alt然后在ContentView的边缘移动鼠标，来看它们之间的间隔。下面是这个过程的一个动画：</p>
<p><img src="http://ww4.sinaimg.cn/large/ba81ca29gw1evcc0nbf2vg20jg0avtcl.gif" alt=""></p>
<p>原来对其并不是那么优雅，看起来也不是很酷。为了解决这个，我们可以调整视图的大小。点击Editor-&gt;Canvas-&gt;Live Autoresizing来使子视图在父视图尺寸改变的时候强制调整大小。按住Alt同时拖拽mainView的一角，直到每边的距离为15.</p>
<p>拖拽是像素点级别的技巧，你可以尝试不同的调整的处理方法，就像下面动画一样。在很多情况下，更倾向于使用Size Inspector来调整复杂的布局，而非用鼠标来拖拽。</p>
<p><img src="/images/blogimg/Xcode/SC4-IB21.gif" alt=""></p>
<p>试着使用相同的技巧来对齐titleLabel、locationLabel、aboutLabel,让他们竖直方向上的间隔为0。按住Alt来查看鼠标移动时，三个label之间的间隔。有发现三个label的左边缘并没有对齐吗？设计师肯定想让nameLabel和webLabel靠左对齐。使用Vertical Guide可以昂我们轻松完成这个任务。选中cardbg，然后点击菜单栏的Editor-&gt;Add Vertical Guide，这个步骤的快捷键是Command |，horizontal guide的快捷键是Command -，这两个快捷键是最可视化的。当视图上有了vertical guide之后，将其从cardbg的左边缘拖10个点。然后所有视图将会紧贴vertical guide，对的非常整齐，继续为其他的label进行对其操作。</p>
<p>Xcode并不那么完美，有时候可能在你创建guideline的时候出现一些问题，可以打开其他文件然后再切回到storyboard页面，然后storyboard会被重新加载，这个时候问题一般会自动解决。<br>让你更酷的建议：所有的视图能紧贴在guideline上才是最好的，guideline没有必要在同一个层级。</p>
<p>下图是上面对齐过程的一个回放：</p>
<p><img src="http://ww4.sinaimg.cn/large/ba81ca29gw1evcc0nbf2vg20jg0avtcl.gif" alt=""></p>
<p>我敢打赌你现在迫不及待的想把你做的展示给你的设计师看！</p>
<h3 id="提升和超越"><a href="#提升和超越" class="headerlink" title="提升和超越"></a>提升和超越</h3><p>上面的步骤让你得到了一个实用的app，同时让你的设计师也感到很满意，那么接下来我们要做的就是让代码变得更为简洁。</p>
<p>快速打开(Command + Shift + O)CTCardCell.m，记得进入Dev Mode(Command .)，你应该不会忘了这些快捷键吧。</p>
<p>看下CTCardCell.m顶部凌乱的属性列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@property (weak, nonatomic) IBOutlet UILabel *locationLabel;</div><div class="line">@property (strong, nonatomic) NSString *website;</div><div class="line">@property (weak, nonatomic) IBOutlet UIButton *fbButton;</div><div class="line">@property (weak, nonatomic) IBOutlet UIImageView *fbImage;</div><div class="line">@property (strong, nonatomic) NSString *twitter;</div><div class="line">@property (weak, nonatomic) IBOutlet UIButton *twButton;</div><div class="line">@property (weak, nonatomic) IBOutlet UILabel *webLabel;</div><div class="line">@property (weak, nonatomic) IBOutlet UIImageView *profilePhoto;</div><div class="line">@property (strong, nonatomic) NSString *facebook;</div><div class="line">@property (weak, nonatomic) IBOutlet UIImageView *twImage;</div><div class="line">@property (weak, nonatomic) IBOutlet UILabel *aboutLabel;</div><div class="line">@property (weak, nonatomic) IBOutlet UIButton *webButton;</div><div class="line">@property (weak, nonatomic) IBOutlet UILabel *nameLabel;</div><div class="line">@property (weak, nonatomic) IBOutlet UILabel *titleLabel;</div></pre></td></tr></table></figure>
<p>在这部分，你将创建一个自定义服务以执行脚本命令来实现属性的快速整齐地排列。</p>
<p>如果对于这些脚本命令还不熟悉，它们是相当好理解的。排序(sort)是按照字母顺序来的，uniq是会删除所有重复的行数。uniq在这里可能派不上用场，但是用它来管理#import，那是极好的。</p>
<p>Mac OS X允许你创建整个操作系统全局通用的服务，你将用它来创建一个用在Xcode中的脚本服务，按如下步骤来设置</p>
<p>使用Spotlight来搜索Automator，并打开它<br>然后点击File-&gt;New，并选择服务(service)一项<br>在Actions筛选栏，输入shell，然后双击运行shell脚本Run Shell Script<br>在新添加的服务的菜单栏上,检查Output replaces selected text<br>将脚本内容切换至sort | uniq<br>同时按下command s，将服务保存为 Sort &amp; Uniq<br>最终的窗口看起来是这个样子：</p>
<p><img src="http://ww2.sinaimg.cn/large/ba81ca29gw1evcc32vbs0j20o70icjv5.jpg" alt=""></p>
<p>切回到Xcode，然后选中CTCardCell.m中的那片混乱的属性区域，右击，选择Services -&gt; Sort &amp; Uniq，然后观察执行之后代码是多么的整洁。你可以看下面的一个示意图：</p>
<p><img src="http://ww2.sinaimg.cn/large/ba81ca29gw1evccbende3g20jg0avgrn.gif" alt=""></p>
<h3 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h3><p>进行到这里，意味着那些基本的可以让你看起来酷酷的调试任务已经告一段落了，接下来我希望你觉得更酷。你可定想学更多技巧，幸运的是，这是最后分享的一个技巧。</p>
<p>你之前可能已经使用过Xcode的代码片段(Code Snippets)功能了，一些常见的是for in片段和dispatch_after片段。在这一部分，你将学会如何创建自定义的代码片段，当你重用这些代码片段时，看起来非常棒。你将创建的是获取单例的代码片段。</p>
<p>如果你不熟悉单例模式，可以看看这个教程。</p>
<p>下面可能是你使用单例模式的常用代码模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)sharedObject &#123;</div><div class="line">  static id _sharedInstance = nil;</div><div class="line">  static dispatch_once_t oncePredicate;</div><div class="line">  dispatch_once(&amp;oncePredicate, ^&#123;</div><div class="line">    _sharedInstance = [[self alloc] init];</div><div class="line">  &#125;);</div><div class="line">  return _sharedInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>非常酷的是这份片段也包含了dispatch_oncep片段。</p>
<p>在工程CardTilt创建一个名为继承自NSObject名为SingletonObject的新类，你不需要为它做任何事，除了作为拖拽代码片段的一个地方。</p>
<p>按下面步骤：</p>
<ul>
<li>在@implementation 的下一行粘贴上面的代码到SingletonObject.m</li>
<li>用快捷键Command Option Control 2来打开代码片段库，在代码片段库中你会看到默认的包含在Xcode中的代码片段库。</li>
<li>选中整个+sharedObject方法，将其拖拽到代码片段库中。<br>看起来是这样的：</li>
</ul>
<p><img src="http://ww4.sinaimg.cn/large/ba81ca29gw1evcc9d8yleg20q60fm7b5.gif" alt=""></p>
<p>新创建的代码片段将会在代码片段库的最底部，你可以将其拖拽到任何你想拖拽的文件当中去，让我们来尝试一下。</p>
<p>双击刚刚新建的代码片段，然后点击edit.弹出的视图非常使用，实际上它们都很重要，所以做个简短的解释。</p>
<ul>
<li>Title and Summary：代码片段库中该代码片段的名字和简述</li>
<li>Platform and Language:代码片段匹配的平台和编程语言</li>
<li>Completion Shortcut:在Xcode中输入的快捷键</li>
<li>Completion Scopes:代码片段作用的范围，这对于保持代码片段库整洁来说十极好的。<br>向下面一样填充里面的属性：</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/ba81ca29gw1evcc9ud0gbj20bn07z75y.jpg" alt=""></p>
<h4 id="令牌"><a href="#令牌" class="headerlink" title="令牌"></a>令牌</h4><p>当你加入令牌时，代码片段将会变得非常强大，因为它允许你在片段中标记代码，而不需要硬编码。通过使用Tab键使得他们非常容易修改，就像自动补全一样。</p>
<p>在片段中仅仅只要输入&lt;#TokenName#&gt;就可以添加一个令牌，创建一个令牌使用shared&lt;#ObjectName#&gt;替代sharedObject，看起来像这样：</p>
<p><img src="http://ww2.sinaimg.cn/large/ba81ca29gw1evccacwhcvj20bm080t9s.jpg" alt=""></p>
<p>点击Done来保存该片段，然后来用用它。</p>
<p>在SingletonObject.m文件中输入singleton accessor，然后当它出现的时候使用自动补全</p>
<p><img src="http://ww4.sinaimg.cn/large/ba81ca29gw1evccaulztkg20b108ydh0.gif" alt=""></p>
<p>对于经常使用的代码来说，创建一个代码片段是非常实用的。</p>
<h3 id="何去何从"><a href="#何去何从" class="headerlink" title="何去何从"></a>何去何从</h3><p>总结一下在这个教程中你所学到的东西：</p>
<ul>
<li>使用快捷键来改变Xcode的布局</li>
<li>使用自定义的行为来改变Xcode的布局</li>
<li>使用assistant editor</li>
<li>在Xcode中快速打开某文件</li>
<li>在Find navigator删除搜索到的结果</li>
<li>在Interface Builder使用快捷键和guideline来对齐视图</li>
<li>创建一个在Xcode中使用的服务</li>
<li>创建并使用自定义的代码片段</li>
<li>最重要的是你知道怎么去成为一名Xcode大师</li>
</ul>
<p>上面列出来的内容都很简单对吧？在你的朋友面前展示这些炫酷的技巧，你的朋友一定会惊呆也会理解你的兴奋。还有很多方法可以提高你的Xcode的效率，比如：</p>
<p><a href="http://www.raywenderlich.com/66395/documenting-in-xcode-with-headerdoc-tutorial" target="_blank" rel="external">使用Doxygen风格的注释</a></p>
<p><a href="http://nshipster.com/xcode-plugins/" target="_blank" rel="external">使用Xcode插件</a></p>
<p>下一步就是去寻找新的酷炫的技巧，我希望你能享受整个教程的学习过程，如果你有任何问题、评论、或者想分享你所知道的炫酷技巧，请在下面评论中指出。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好莱坞电影里经常看到黑客们手指在键盘上飞速跳跃,同时终端上的代码也随着飞舞。如果你也想像电影里那样,那么你来对地方了。这篇教程将会教你在Xcode编程中更像程序员,你可以称之为魔法、疯狂的技术、好运当头或者黑客。毫无疑问,在学习完本教程之后,不管你怎么认为,都会感觉很酷,同时能更高效地运用Xcode,甚至可以通过这些新发现使你的代码免于毁灭。&lt;/p&gt;
    
    </summary>
    
      <category term="翻译" scheme="https://vongloo.me/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://vongloo.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Xcode" scheme="https://vongloo.me/tags/Xcode/"/>
    
  </entry>
  
</feed>
