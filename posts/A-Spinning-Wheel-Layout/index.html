<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Vong"/><link rel="canonical" href="https://wang9262.github.io/posts/A-Spinning-Wheel-Layout"/><meta name="twitter:url" content="https://wang9262.github.io/posts/A-Spinning-Wheel-Layout"/><meta name="og:url" content="https://wang9262.github.io/posts/A-Spinning-Wheel-Layout"/><title>UICollectionView自定义布局之风火轮[译] | Vong</title><meta name="twitter:title" content="UICollectionView自定义布局之风火轮[译] | Vong"/><meta name="og:title" content="UICollectionView自定义布局之风火轮[译] | Vong"/><meta name="description" content="Vong,iOS,Performance,性能,Swift,SwiftUI,Objective-C"/><meta name="twitter:description" content="Vong,iOS,Performance,性能,Swift,SwiftUI,Objective-C"/><meta name="og:description" content="Vong,iOS,Performance,性能,Swift,SwiftUI,Objective-C"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@Vong_HUST"/><meta name="twitter:creator" content="@Vong_HUST"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Vong"/><meta name="twitter:image" content="https://wang9262.github.io/media"/><meta name="og:image" content="https://wang9262.github.io/media"/><script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script></head><body class="item-page"><header><div class="wrapper"><div class="logo"><a href="/"><h2>Vong</h2></a></div><div><div class="headerIcons"><a class="icon headIconWeixin"><script src="/Script/weixincode_hover.js"></script></a><a class="icon headIconTwitter" href="https://www.twitter.com/Vong_HUST" target="_blank" rel="noreferrer"></a><a class="icon headIconEmail" href="mailto:Vong9262@gmail.com" target="_blank" rel="noreferrer"></a><a class="icon headIconGithub" href="https://github.com/wang9262/" target="_blank" rel="noreferrer"></a><a class="icon headIconRss" href="/feed.rss" target="_blank" rel="noreferrer"></a></div></div><nav><ul><li><a href="/">首页</a></li><li><a class="selected" href="/posts">所有文章</a></li><li><a href="/about">关于</a></li><li><a href="/tags">搜索</a></li></ul><div class="weixinHeadQcode"></div></nav></div></header><div class="container"><div class="wrapper"><div class="viewContainer"><div class="side-nav"><div class="sidebar"></div></div><div class="leftContent"><div class="post-actions"><div class="actionButton"><div class="actionButton twitter" onclick="window.open('https://twitter.com/intent/tweet?text=UICollectionView自定义布局之风火轮[译]&url=https://wang9262.github.io/posts/A-Spinning-Wheel-Layout&via=Vong_HUST','target','');"></div></div><div class="actionButton"><div class="actionButton comment" onclick="$('html,body').animate({scrollTop: $('#gitalk-container').offset().top }, {duration: 500,easing:'swing'})"></div></div><div class="actionButton"><div class="actionButton top" onclick="$('html,body').animate({scrollTop: 0 }, {duration: 500,easing:'swing'})"></div></div></div><article><div><h1>UICollectionView自定义布局之风火轮[译]</h1></div><div><ul class="tag-list"><li class="tag variant-2"><a href="/tags/uicollectionview">UICollectionView</a></li><li class="tag variant-7"><a href="/tags/翻译">翻译</a></li><li class="tag tagdate">发布于2015年08月31日</li></ul><div class="content"><p>现在有许多极具创造力的网站，几周前我碰巧浏览到一个名为<a href="http://fff.cmiscm.com/" target="_blank">Form Follows Function</a>的网站，上面有各种交互动画。其中最吸引我的是网站上的导航转轮，转轮由各种交互体验海报组成。</p><img src="/oldimages/2019-11-21-15742622027530.jpg"/><p>原文：<a href="http://www.raywenderlich.com/107687/uicollectionview-custom-layout-tutorial-spinning-wheel" target="_blank">UICollectionView Custom Layout Tutorial: A Spinning Wheel</a></p><p>本教程将讲解如何使用自定义的 <code>UICollectionViewFlowLayout</code> 来再现那个导航风火轮。在开始之前，希望你有对 2D 转换、<code>UICollectionView</code> 及其自定义布局的基本知识。如果你对这些还不是很熟悉，推荐你先看看下面几篇教程。</p><ul><li><a href="http://www.raywenderlich.com/78550/beginning-ios-collection-views-swift-part-1" target="_blank">UICollectionView Tutorial Part 1: Getting Started</a></li><li><a href="http://www.raywenderlich.com/78551/beginning-ios-collection-views-swift-part-2" target="_blank">UICollectionView Tutorial Part 2: Reusable Views and Cell Selection</a></li><li><a href="http://www.raywenderlich.com/video-tutorials#collectionview" target="_blank">Video Series: Collection Views</a></li><li><a href="http://www.raywenderlich.com/video-tutorials#CCVL" target="_blank">Video Series: Custom Collection View Layouts</a></li></ul><p>通过学习该教程，你将了解到：</p><ul><li>从头开始创建自定义<code>collectionView</code>的布局，而不是使用 <code>UICollectionViewFlowLayout</code>作为你的基类。</li><li>view 在其 bounds 之外绕某点旋转</li></ul><p>那么现在，让我们开搞吧。</p><h2>开始</h2><p>首先下载<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2015/06/CircularCollectionView-Starter.zip" target="_blank">模板</a>，在 Xcode 中打开，运行。你将看到一系列 cell，每个代表<a href="http://www.raywenderlich.com/store" target="_blank">书城</a>中的一本书。</p><img src="/oldimages/2019-11-21-15742622193056.jpg"/><p>下面我们来看看工程目录结构，有一个 CollectionViewController、一个自定义 Cell，cell 中有一个 imageView。然后 VC 被这些 Cell填充。我们的任务就是创建一个UICollectionViewLayout子类来将这些 Cell 按照圆弧排列。</p><h2>理论知识</h2><p>下图是一个带有 cell 的风火轮。黄色区域是 iPhone 的屏幕，蓝色圆角矩形是 cell，红色虚线是你将要放置 cell 的圆弧。</p><img src="/oldimages/2019-11-21-15742622298263.jpg"/><p>你需要三个参数来创建这种排列：</p><ul><li>1.圆弧半径（radius）</li><li>2.每个 cell 之间的角度（anglePerItem）</li><li>3.每个 cell 的角位置</li></ul><p>你可能已经注意到，并非所有 cell 在屏幕当中能正常显示。</p><p>假设第0个 cell 的角度为 <code>x</code> 度，那么第1个 cell 的角位置为 <code>x + anglePerItem</code>,第二个为<code>x + anglePerItem * 2</code>，以此类推。第 n 个的角位置的计算公式如下：</p><pre data-language="undefined" class="hljs"><code>
angle_for_i = x + (i * anglePerItem)
</code></pre><p>下图展示的是角坐标系。0度代表中心，顺时针方向为正，逆时针方向为负。所以0度角的 cell 将处在正中央，完全垂直的方向。</p><img src="/oldimages/2019-11-21-15742622407382.jpg"/><p>现在你对理论知识有了一个全面的理解，让我们开始撸代码吧。</p><h2>Circular Collection View Layout</h2><p>新建一个 swift 文件，取名CircularCollectionViewLayout，继承自UICollectionViewLayout。</p><img src="/oldimages/2019-11-21-15742622925513.jpg"/><p>点击下一步、创建。这个UICollectionViewLayout的子类将包含所有与位置相关的代码。 因为CircularCollectionViewLayout继承自UICollectionViewLayout而不是UICollectionViewFlowLayout，所以你需要处理所有布局过程而不是简单调用 super 中的实现。</p><p>我发现 FlowLayout 非常适合网格视图而非圆形布局。 在CircularCollectionViewLayout中，新建两个属性<code>itemSize</code>和<code>radius</code>。</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">let</span> itemSize = <span class="hljs-type">CGSize</span>(width: <span class="hljs-number">133</span>, height: <span class="hljs-number">173</span>)
 
<span class="hljs-keyword">var</span> radius: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">500</span> {
  <span class="hljs-keyword">didSet</span> {
    invalidateLayout()
  }
}
</code></pre><p>当半径改变时你需要重新计算所有值，所以要在 <code>didSet</code> 中调用<code>invalidateLayout()</code>。在 radius 声明下面紧接着<code>anglePerItem</code>的定义：</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">var</span> anglePerItem: <span class="hljs-type">CGFloat</span> {
  <span class="hljs-keyword">return</span> atan(itemSize.width / radius)
}
</code></pre><p><code>anglePerItem</code>可以是你想要的任何值，但是公式要确保 cell 不要被分散的太开。 下一步，实现<code>collectionViewContentSize()</code>来声明你的 collectionView 的内容有多大：</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">collectionViewContentSize</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">CGSize</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-type">CGSize</span>(width: <span class="hljs-type">CGFloat</span>(collectionView!.numberOfItemsInSection(<span class="hljs-number">0</span>)) * itemSize.width,
      height: <span class="hljs-type">CGRectGetHeight</span>(collectionView!.bounds))
}
</code></pre><p>内容高度与 collectionView 高度一致，但是宽度是<code>itemSize.width * numberOfItems</code>。 现在打开<code> Main.storyboard</code>，选中视图大纲中的Collection View，如下图所示</p><img src="/oldimages/2019-11-21-15742625946308.jpg"/><p>打开Attributes Inspector，将其 Layout 设置为自定义，将其 Class 设置为CircularCollectionViewLayout。</p><img src="/oldimages/2019-11-21-15742626021736.jpg"/><p>运行程序，你将发现除了一个可滑动区域外，屏幕上没有任何东西。但是它就是你想要的，因为这确保你正确地将 collectionView 的 Layout 设置为你自定义的 Class 即 CircularCollectionViewLayout。</p><img src="/oldimages/2019-11-21-15742626135318.jpg"/><h2>自定义布局属性</h2><p>除了新建一个新的布局子类，你还要新建一个继承自UICollectionViewLayoutAttributes的类来存储角位置以及锚点（anchorPoint）。 把下面代码加到CircularCollectionViewLayout.swift这个文件中，将其放在CircularCollectionViewLayout类声明上面。</p><pre data-language="swift" class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircularCollectionViewLayoutAttributes</span>: <span class="hljs-title">UICollectionViewLayoutAttributes</span> </span>{
  <span class="hljs-comment">// 1</span>
  <span class="hljs-keyword">var</span> anchorPoint = <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0.5</span>, y: <span class="hljs-number">0.5</span>)
  <span class="hljs-keyword">var</span> angle: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">0</span> {
    <span class="hljs-comment">// 2 </span>
    <span class="hljs-keyword">didSet</span> {
      zIndex = <span class="hljs-type">Int</span>(angle * <span class="hljs-number">1000000</span>)
      transform = <span class="hljs-type">CGAffineTransformMakeRotation</span>(angle)
    }
  }
  <span class="hljs-comment">// 3</span>
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">copyWithZone</span><span class="hljs-params">(zone: NSZone)</span></span> -&gt; <span class="hljs-type">AnyObject</span> {
    <span class="hljs-keyword">let</span> copiedAttributes: <span class="hljs-type">CircularCollectionViewLayoutAttributes</span> = 
        <span class="hljs-keyword">super</span>.copyWithZone(zone) <span class="hljs-keyword">as</span>! <span class="hljs-type">CircularCollectionViewLayoutAttributes</span>
    copiedAttributes.anchorPoint = <span class="hljs-keyword">self</span>.anchorPoint
    copiedAttributes.angle = <span class="hljs-keyword">self</span>.angle
    <span class="hljs-keyword">return</span> copiedAttributes
  }
}
</code></pre><ul><li>1.我们需要一个锚点，因为旋转是围绕锚点而非中心。</li><li>2.当设置角度（angle）的时候，在内部设置其 transform 旋转 angle 弧度。同时我们想要右边的 cell 覆盖在左边的 cell 上，这个可以通过设置 zIndex 来实现。因为角度用弧度表示，我们将其扩大 1,000,000倍来确保相邻的值不会被四舍五入成同一个 zIndex 值，zIndex 是 Int 型的。</li><li>3.复写copyWithZone()来遵循NSCopying协议，因为在 collectionView 布局时，内部会拷贝布局属性。复写这个方法来确保复制过程中，<code>anchorPoint</code> 和 <code>angle</code>两个属性也会被拷贝。</li></ul><p>下面我们回到CircularCollectionViewLayout中来实现 layoutAttributesClass()方法。</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">override</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">func</span> <span class="hljs-title">layoutAttributesClass</span>() -&gt; <span class="hljs-title">AnyClass</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-type">CircularCollectionViewLayoutAttributes</span>.<span class="hljs-keyword">self</span>
}
</code></pre><p>这一步是为了告知 collecttionView 你将使用CircularCollectionViewLayoutAttributes而不是默认的UICollectionViewLayoutAttributes。 为了持有布局属性，在所有属性声明之后创建一个名为<code>attributesList</code>的数组。</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">var</span> attributesList = [<span class="hljs-type">CircularCollectionViewLayoutAttributes</span>]()
</code></pre><h2>Preparing the Layout</h2><p>当 collectionView 第一次展示在屏幕上时，Layout 的<code> prepareLayout()</code>方法将被调用。在每次布局生效时这个方法也会被调用。 这是布局过程中最重要的方法之一，因为这是创建和存储布局属性的入口。在CircularCollectionViewLayout添加如下代码：</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">prepareLayout</span><span class="hljs-params">()</span></span> {
  <span class="hljs-keyword">super</span>.prepareLayout()
 
  <span class="hljs-keyword">let</span> centerX = collectionView!.contentOffset.x + (<span class="hljs-type">CGRectGetWidth</span>(collectionView!.bounds) / <span class="hljs-number">2.0</span>)
  attributesList = (<span class="hljs-number">0</span>..&lt;collectionView!.numberOfItemsInSection(<span class="hljs-number">0</span>)).<span class="hljs-built_in">map</span> { (i) 
      -&gt; <span class="hljs-type">CircularCollectionViewLayoutAttributes</span> <span class="hljs-keyword">in</span>
    <span class="hljs-comment">// 1</span>
    <span class="hljs-keyword">let</span> attributes = <span class="hljs-type">CircularCollectionViewLayoutAttributes</span>(forCellWithIndexPath: <span class="hljs-type">NSIndexPath</span>(forItem: i,
        inSection: <span class="hljs-number">0</span>))
    attributes.size = <span class="hljs-keyword">self</span>.itemSize
    <span class="hljs-comment">// 2</span>
    attributes.center = <span class="hljs-type">CGPoint</span>(x: centerX, y: <span class="hljs-type">CGRectGetMidY</span>(<span class="hljs-keyword">self</span>.collectionView!.bounds))
    <span class="hljs-comment">// 3</span>
    attributes.angle = <span class="hljs-keyword">self</span>.anglePerItem*<span class="hljs-type">CGFloat</span>(i)
    <span class="hljs-keyword">return</span> attributes
  }
}
</code></pre><p>简单来说，我们便利每一个 item，然后执行闭包。下面我们一行行来解释：</p><ul><li>1.为每个 IndexPath 创建一个CircularCollectionViewLayoutAttributes实例，然后设置其大小（size）</li><li>2.将 item 放在屏幕中间</li><li>按弧度来旋转每个 item，旋转量为<code>anglePerItem * i</code></li></ul><p>&gt;方法中的 map 是 Swift 标准库中的一部分，它创建了一个新的数组，数组中存储的是闭包的执行结果。你可以在<a href="http://www.raywenderlich.com/82599/swift-functional-programming-tutorial" target="_blank">这篇文章</a>中了解更多。</p><p>我们还需要实现下面的方法，这些方法返回在给定矩形区域中的 item 布局属性，以及给定的 indexpath 的 item 布局属性。collectionView 在布局过程中将会多次调用这些方法，在用户滑动 collectionView 也会触发这些方法。为了保证其高效性，我们在<code>prepareLayout()</code>方法中缓存了这些布局属性。把下面代码加到<code>prepareLayout()</code>下面：</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">layoutAttributesForElementsInRect</span><span class="hljs-params">(rect: CGRect)</span></span> -&gt; [<span class="hljs-type">AnyObject</span>]? {
  <span class="hljs-keyword">return</span> attributesList
}
 
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">layoutAttributesForItemAtIndexPath</span><span class="hljs-params">(indexPath: NSIndexPath)</span></span> 
    -&gt; <span class="hljs-type">UICollectionViewLayoutAttributes!</span> {
  <span class="hljs-keyword">return</span> attributesList[indexPath.row]
}
</code></pre><p>第一个方法简单返回了整个布局属性数组，第二个方法返回了指定的 indexpath 对应的布局属性。这个方法非常 OK 因为我们的 item 数目比较小，但是通常我们会遍历数组来判断布局属性的 frame 是否与给定的矩形区域相交，然后返回与给定区域相交的布局属性。这使得 collectionView 在屏幕上只绘制这些 item，或者将要出现在屏幕上的 item。</p><p>运行，你会看到所有 cell 出现在屏幕上，但是它们是围绕自身来旋转而非外部的某个点。虽然它不是非常急需的效果，但是如果能做到确实挺酷的，你觉得呢？</p><img src="/oldimages/2019-11-21-15742626594604.jpg"/><p>你能猜到为什么会这样吗？</p><h2>有人说是锚点吗？</h2><p>你还记得上面我们说的 cell 的锚点吗？你还没有设置过它，上面的旋转效果远没达到我们希望得到的效果。</p><img src="/oldimages/2019-11-21-15742626864285.jpg"/><p>锚点是 CALayer 的一个属性，所有的旋转和缩放都是围绕着它而发生的。锚点的默认值是 center，就像上面的运行结果那样。 真正的锚点的 x 值应该为0.5，y 值应该为<code>radius + (itemSize.height / 2)</code>，因为锚点是在归一化坐标系中定义的，所以你要除以<code>itemSize.height</code>。</p><img src="/oldimages/2019-11-21-15742626990183.jpg"/><p>回到<code>prepareLayout()</code>，然后再 <code>centerX</code> 的定义下面定义<code>anchorPointY</code>：</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">let</span> anchorPointY = ((itemSize.height / <span class="hljs-number">2.0</span>) + radius) / itemSize.height
</code></pre><p>在<code>map(_:)</code>闭包中的 return 上方添加如下代码：</p><pre data-language="swift" class="hljs"><code>attributes.anchorPoint = <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0.5</span>, y: anchorPointY)
</code></pre><p>接着打开open CircularCollectionViewCell.swift，然后复写<code>applyLayoutAttributes(_:)</code> ：</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">applyLayoutAttributes</span><span class="hljs-params">(layoutAttributes: UICollectionViewLayoutAttributes!)</span></span> {
  <span class="hljs-keyword">super</span>.applyLayoutAttributes(layoutAttributes)
  <span class="hljs-keyword">let</span> circularlayoutAttributes = layoutAttributes <span class="hljs-keyword">as</span>! <span class="hljs-type">CircularCollectionViewLayoutAttributes</span>
  <span class="hljs-keyword">self</span>.layer.anchorPoint = circularlayoutAttributes.anchorPoint
  <span class="hljs-keyword">self</span>.center.y += (circularlayoutAttributes.anchorPoint.y - <span class="hljs-number">0.5</span>) * <span class="hljs-type">CGRectGetHeight</span>(<span class="hljs-keyword">self</span>.bounds)
}
</code></pre><p>这里你用父类实现来使用默认属性如 center 和 transform 但是因为锚点（anchorPoint）是一个自定义属性，我们需要手动使用它，同样我们也更新了 center.y 来补偿圆形布局中的anchorPoint.y变化。</p><p>运行程序，你会看到所有的 cell 按照圆形来布局了，但是滑动的过程中...等一下，发生了什么？它们被移出了屏幕而不是旋转！？</p><p>这使得找到想要的书变得非常困难。</p><img src="/oldimages/2019-11-21-15742627247360.gif"/><h2>改善滑动效果</h2><p>最具挑战性的布局 item 任务已经完成了，可喜可贺！:]</p><img src="/oldimages/2019-11-21-15742627484536.jpg"/><p>现在需要做的就是改变角度值来实现滑动。</p><p>回到CircularCollectionViewLayout，然后在底部添加下面代码：</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shouldInvalidateLayoutForBoundsChange</span><span class="hljs-params">(newBounds: CGRect)</span></span> -&gt; <span class="hljs-type">Bool</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
}
</code></pre><p>该方法返回 true 告知 collectionView 在滑动时布局失效，然后它会调用<code>prepareLayout()</code>，进而使用更新后的角位置重新计算 cell 的布局。angle被定义为第0个 item 的角位置。你将要通过把contentOffset.x转换成一个合适的角度值来实现滑动。</p><p>滑动过程中，<code>contentOffset.x</code>从 0 到<code>collectionViewContentSize().width - CGRectGetWidth(collectionView!.bounds)</code>变化。将<code>contentOffset.x</code>的极值定义为<code>maxContentOffset</code>，当其为 0 时，让第 0 个item 处在中心，当其为极值时（即maxContentOffset），让最后一个 item 处在屏幕中心，这就意味着最后一个 item 的角位置会变为 0 。</p><img src="/oldimages/2019-11-21-15742627839952.jpg"/><p>想象一下右边的场景，如果你是用<code>angle_for_last_item = 0</code>来解决下面等式你会得到：</p><pre data-language="undefined" class="hljs"><code>
angle_for_last_item = angle_for_zero_item + (totalItems - 1) * anglePerItem
0 = angle_for_zero_item + (totalItems - 1) * anglePerItem
angle_for_zero_item = -(totalItems - 1) * anglePerItem
</code></pre><p>定义<code>-(totalItems - 1) * anglePerItem</code>为<code>angleAtExtreme</code>，如下所示：</p><pre data-language="swift" class="hljs"><code>contentOffset.x = <span class="hljs-number">0</span>, angle = <span class="hljs-number">0</span>
contentOffset.x = maxContentOffset, angle = angleAtExtreme
</code></pre><p>由上面，使用下面的公式非常容易计算任意<code>contentOffset.x</code>对应的角度：</p><pre data-language="undefined" class="hljs"><code>
angle = -angleAtExtreme * contentOffset.x / maxContentOffset
</code></pre><p>脑海中回想以下这些算式，把下面代码添加到 itemSize 的声明下：</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">var</span> angleAtExtreme: <span class="hljs-type">CGFloat</span> {
  <span class="hljs-keyword">return</span> collectionView!.numberOfItemsInSection(<span class="hljs-number">0</span>) &gt; <span class="hljs-number">0</span> ? 
    -<span class="hljs-type">CGFloat</span>(collectionView!.numberOfItemsInSection(<span class="hljs-number">0</span>) - <span class="hljs-number">1</span>) * anglePerItem : <span class="hljs-number">0</span>
}
<span class="hljs-keyword">var</span> angle: <span class="hljs-type">CGFloat</span> {
  <span class="hljs-keyword">return</span> angleAtExtreme * collectionView!.contentOffset.x / (collectionViewContentSize().width - 
    <span class="hljs-type">CGRectGetWidth</span>(collectionView!.bounds))
}
</code></pre><p>接下来使用</p><pre data-language="swift" class="hljs"><code>attributes.angle = <span class="hljs-keyword">self</span>.angle + (<span class="hljs-keyword">self</span>.anglePerItem * <span class="hljs-type">CGFloat</span>(i))
</code></pre><p>来替换<code>prepareLayout()</code>中的</p><pre data-language="swift" class="hljs"><code>attributes.angle = (<span class="hljs-keyword">self</span>.anglePerItem * <span class="hljs-type">CGFloat</span>(i))
</code></pre><p>这一步添加为每个 item 添加了角度值，这样 item 的角度值不在是一个常量，而是一个与<code>contentOffset.x</code>有着函数关系的值。 运行程序，在屏幕上滑动，你将发现所有 item 按照你想要的方式在滑动。干得漂亮！</p><img src="/oldimages/2019-11-21-15742628030765.gif"/><h2>加分环节:优化</h2><p>你已经成功的重现了风火轮导航，现在可以在拍拍自己肩膀说一句干得漂亮，然后架着二郎腿享受这美好时光。但是在存在优化空间的情况（滑动丝滑般流畅）下你为什么要停下来呢？ 在<code>prepareLayout()</code>中为每个 item 创建了一个CircularCollectionViewLayoutAttributes实例，但是不是所有的 item 都会立刻展示在屏幕上。那些离屏的 item，你可以完全跳过对它们的计算，也不必创建CircularCollectionViewLayoutAttributes实例。 但是有一个棘手的问题是：我们需要确定哪些 item 正在屏幕上显示，哪些是离屏的。如下图所示，在 (-θ, θ)范围之外的所有 item 都是离屏的。</p><img src="/oldimages/2019-11-21-15742628334079.jpg"/><p>举个栗子，为了计算三角形 ABC 中的 θ 角，可以使用下面公式：</p><pre data-language="undefined" class="hljs"><code>
tanθ = (collectionView.width / 2) / (radius + (itemSize.height / 2) - (collectionView.height / 2))
</code></pre><p>在<code>prepareLayout()</code>中的<code>anchorPointY</code>下一行加入如下代码：</p><pre data-language="swift" class="hljs"><code><span class="hljs-comment">// 1 </span>
<span class="hljs-keyword">let</span> theta = atan2(<span class="hljs-type">CGRectGetWidth</span>(collectionView!.bounds) / <span class="hljs-number">2.0</span>, 
    radius + (itemSize.height / <span class="hljs-number">2.0</span>) - (<span class="hljs-type">CGRectGetHeight</span>(collectionView!.bounds) / <span class="hljs-number">2.0</span>))
<span class="hljs-comment">// 2</span>
<span class="hljs-keyword">var</span> startIndex = <span class="hljs-number">0</span>
<span class="hljs-keyword">var</span> endIndex = collectionView!.numberOfItemsInSection(<span class="hljs-number">0</span>) - <span class="hljs-number">1</span> 
<span class="hljs-comment">// 3</span>
<span class="hljs-keyword">if</span> (angle &lt; -theta) {
  startIndex = <span class="hljs-type">Int</span>(floor((-theta - angle) / anglePerItem))
}
<span class="hljs-comment">// 4</span>
endIndex = <span class="hljs-built_in">min</span>(endIndex, <span class="hljs-type">Int</span>(ceil((theta - angle) / anglePerItem)))
<span class="hljs-comment">// 5</span>
<span class="hljs-keyword">if</span> (endIndex &lt; startIndex) {
  endIndex = <span class="hljs-number">0</span>
  startIndex = <span class="hljs-number">0</span>
}
</code></pre><p>这一步我们做了什么？</p><ul><li>1.使用反正切函数计算theta角</li><li>2.初始化<code>startIndex</code>及<code>endIndex</code></li><li>3.如果第0个 item 的角位置小于 <code>-theta</code>，那么它就是离屏的，屏上第 1 个 item 的 <code>index</code> 将为 <code>-θ</code> 与 <code>angle</code> 的差值再除以 <code>anglePerItem</code></li><li>4.同样的，屏幕上最后一个 item 是<code>θ</code> 与 <code>angle</code> 的差值再除以 <code>anglePerItem</code>，min 是保证<code>endIndex</code>不会越界</li><li>5.最后做了一个容错处理，防止在快速滑动时所有 cell 都离屏时导致 <code>endIndex</code>小于 <code>startIndex</code>的情况</li></ul><p>下图把上面的计算过程可视化：</p><img src="/oldimages/2019-11-21-15742628443820.jpg"/><p>既然我们知道了哪些正在显示，哪些是离屏的，我们需要更新用来计算布局属性的起始和结束的 index。使用</p><pre data-language="swift" class="hljs"><code>attributesList = (startIndex...endIndex).<span class="hljs-built_in">map</span> { (i) 
    -&gt; <span class="hljs-type">CircularCollectionViewLayoutAttributes</span> <span class="hljs-keyword">in</span>
</code></pre><p>来替换<code>prepareLayout()</code>中的：</p><pre data-language="swift" class="hljs"><code>attributesList = (<span class="hljs-number">0</span>..&lt;collectionView!.numberOfItemsInSection(<span class="hljs-number">0</span>)).<span class="hljs-built_in">map</span> { (i) 
    -&gt; <span class="hljs-type">CircularCollectionViewLayoutAttributes</span> <span class="hljs-keyword">in</span>
</code></pre><p>运行程序，你会发现视觉上没有明显变化，因为所有的改变仅仅影响离屏的 item。我们可以打开 Xcode <a href="http://www.raywenderlich.com/98356/view-debugging-in-xcode-6" target="_blank">内置的视图层级查看器</a></p><p>因为创建了更少的变量，你应该可以看到性能的提升。</p><img src="/oldimages/2019-11-21-15742628535614.jpg"/><h2>何去何从</h2><p>你可以<a href="https://koenig-media.raywenderlich.com/uploads/2015/06/CircularCollectionView-Final.zip" target="_blank">在此</a>下载完整代码。</p><img src="/oldimages/2019-11-21-15742628626003.jpg"/><p>恭喜，你已经成功使用了自定义的 Layout 来实现一个导航风火轮。在这篇教程中你应该学到不少东西，包括如何旋转 view、改变锚点、从头创建自定义的 Layout 以及如何优化让它变得更好。 你可以更改<code>radius</code>和<code>anglePerItem</code>来进一步了解它们是如何来改变最终的圆形布局排列的。这篇教程主要是改变2D 的 transform，你也可以使用3D transform 来创建更有趣的效果。 同样你也可以通过复写<code>argetContentOffsetForProposedContentOffset(_:withScrollingVelocity:)</code>方法来实现snapping行为。 我相信你已经开始跃跃欲试了吧？如果你遇到问题，可以参考下面的代码：</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">targetContentOffsetForProposedContentOffset</span><span class="hljs-params">(proposedContentOffset: CGPoint, withScrollingVelocity velocity: CGPoint)</span></span> -&gt; <span class="hljs-type">CGPoint</span> {
  <span class="hljs-keyword">var</span> finalContentOffset = proposedContentOffset
  <span class="hljs-keyword">let</span> factor = -angleAtExtreme/(collectionViewContentSize().width - 
      <span class="hljs-type">CGRectGetWidth</span>(collectionView!.bounds))
  <span class="hljs-keyword">let</span> proposedAngle = proposedContentOffset.x*factor
  <span class="hljs-keyword">let</span> ratio = proposedAngle/anglePerItem
  <span class="hljs-keyword">var</span> multiplier: <span class="hljs-type">CGFloat</span>
  <span class="hljs-keyword">if</span> (velocity.x &gt; <span class="hljs-number">0</span>) {
    multiplier = ceil(ratio)
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (velocity.x &lt; <span class="hljs-number">0</span>) {
    multiplier = floor(ratio)
  } <span class="hljs-keyword">else</span> {
    multiplier = round(ratio)
  }
  finalContentOffset.x = multiplier*anglePerItem/factor
  <span class="hljs-keyword">return</span> finalContentOffset
}
</code></pre><p>如果你有任何疑问、评论或者炫技，请加入下面的讨论。</p></div><div class="license">本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC 4.0许可协议</a>。转载请注明出处和作者。</div></div></article><div class="supporter"><p>关注微信公共号<a href="/about/">Vong</a>或在微博上关注<a href="https://weibo.com/VongLo">@Vong_HUST</a>，永远不会错过新内容！ 您的<a href="/about/">支持和鼓励</a>将为我的博客写作增添更多的动力!</p><img src="/images/weixincode.png"/><div class="label">动态更新</div></div><div class="item-navigator"><table><tr><td class="previous-item"><a href="/posts/How-to-Create-an-iOS-Book-Open-Animation-part-one-translation">如何创建一个翻书动画(Part 1)[译]</a></td><td class="next-item"><a href="/posts/Koloda-Second-Version">Koloda动画第二版[译]</a></td></tr></table></div><div id="gitalk-container"></div>    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><script src="/Script/gitalk.js"></script></div><script src="/Script/toc.js"></script></div></div><footer><p>Copyright &copy; Vong 2022 </p><p>Generated using <a href="https://github.com/johnsundell/publish" target="_blank">Publish</a></p><ul class="icon"><li><a href="https://twitter.com/Vong_HUST" target="_blank"><img class="twitter" src="/images/twitter.svg"/></a></li><li><a href="https://github.com/wang9262/" target="_blank"><img src="/images/github.svg"/></a></li><li><a href="/feed.rss"><img src="/images/rss.svg"/></a></li></ul><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZHSZ71NFYK"></script><script src="/Script/google_analyse.js"></script><script src="/Script/baidu_analyse.js"></script></footer></div></body></html>