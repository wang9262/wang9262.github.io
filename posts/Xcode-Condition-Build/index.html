<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Vong"/><link rel="canonical" href="https://wang9262.github.io/posts/Xcode-Condition-Build"/><meta name="twitter:url" content="https://wang9262.github.io/posts/Xcode-Condition-Build"/><meta name="og:url" content="https://wang9262.github.io/posts/Xcode-Condition-Build"/><title>iOS 中资源的条件编译 | Vong</title><meta name="twitter:title" content="iOS 中资源的条件编译 | Vong"/><meta name="og:title" content="iOS 中资源的条件编译 | Vong"/><meta name="description" content="Vong,iOS,Performance,性能,Swift,SwiftUI,Objective-C"/><meta name="twitter:description" content="Vong,iOS,Performance,性能,Swift,SwiftUI,Objective-C"/><meta name="og:description" content="Vong,iOS,Performance,性能,Swift,SwiftUI,Objective-C"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Vong"/><meta name="twitter:image" content="https://wang9262.github.io/media"/><meta name="og:image" content="https://wang9262.github.io/media"/></head><body class="item-page"><header><div class="wrapper"><a href="/" class="site-name">Vong</a><nav><ul><li><a href="/index">Index</a></li><li><a href="/posts" class="selected">My posts</a></li><li><a href="/tags">Tags</a></li><li><a href="/about">About</a></li></ul></nav></div></header><div class="wrapper"><article><div class="content"><h1>iOS 中资源的条件编译</h1><p>日常开发中常常遇到某些类及其引用的资源文件仅在 <code>Debug</code> 或内测版本中生效，而不希望带到线上版本。因为一来会增加包体积，二来会把一些内部功能的相关接口暴露，导致可能的一些动态调试。那么有没有避免的方案呢？</p><h2>Pod</h2><p>答案肯定是有的，通常的做法是把对应功能抽成单独的 <code>pod</code> 库，然后仅 <code>Debug</code> 模式才集成到主工程，发出去的版本不集成。通常方式如下，以 <code>FLEX</code> 为例：</p><pre data-language="ruby"><code>pod <span class="hljs-string">'FLEX'</span>, <span class="hljs-string">'~&gt; 2.0'</span>, <span class="hljs-symbol">:configurations</span> =&gt; [<span class="hljs-string">'Debug'</span>]
</code></pre><p>但是如果某些强耦合主工程无法拆成独立 <code>pod</code> 的功能，这种方式可能就不再适用了。</p><h2>条件编译</h2><p><code>pod</code> 这条路走不通，有没有其他方式呢？答案也是肯定的，也是大家经常采用的方式，使用条件编译。也就是将对应类文件及引用到的地方使用类似下面的方式：</p><pre data-language="undefined"><code>
#if DEBUG
// 放入仅Debug模式下生效的代码
#endif
</code></pre><p>以上两种方式将大部分场景 <code>cover</code> 住了，但是假设对应的类文件还引用到了图片、<code>Storyboard</code>、<code>Xib</code> 等资源时，该如何让这些资源仅在 <code>Debug</code> 下才参与编译，而其他场景不参与编译呢？</p><h2>Xcode Build Options</h2><p>既然都写了这篇文章了，那答案也是肯定的，就是使用 <code>Xcode</code> 提供的一个编译选项 <code>Excluded Source File Names</code> 来将不需要的资源排除。</p><img src="/media/2020-03-30/15855806858197.jpg"/><blockquote><p>确切来说这个编译选项是 <code>Xcode 9</code> 才引入的，之前版本需要自行定义，可以参考这个<a href="https://stackoverflow.com/a/41495430">回答</a>。 摘录一段来自<a href="https://xcodebuildsettings.com/#excluded_source_file_names">Xcode Build Settings</a>的解释 <img src="/media/2020-03-30/15855826179239.jpg" alt="-w849"/></p></blockquote><p>假设有下面目录结构的工程</p><pre data-language="undefined"><code>
# 使用 tree 命令行得到下面结构
├── ConditionBuildDemo
│   ├── A
│   │   ├── Debug
│   │   │   ├── DebugA.swift
│   │   │   ├── icon_test@2x.png
│   │   │   ├── Sub
│   │   │   │   ├── DeepSub
│   │   │   │   │   └── DeepSubA.swift
│   │   │   │   ├── SubDebugA.swift
│   │   │   │   └── icon.png
│   │   │   └── SubA.xcassets
│   │   │       ├── Contents.json
│   │   │       └── logo.imageset
│   │   │           ├── Contents.json
│   │   │           └── logo@2x.png
│   │   └── ModelA.swift
│   ├── B
│   │   ├── Debug
│   │   │   └── DebugB.swift
│   │   └── ModelB.swift
</code></pre><pre data-language="Swift"><code><span class="hljs-comment">//测试代码</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">super</span>.viewDidLoad()
    <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = <span class="hljs-type">ModelA</span>()
    <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = <span class="hljs-type">ModelB</span>()
    <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = <span class="hljs-type">DebugA</span>()
    <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = <span class="hljs-type">DebugB</span>()
    <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = <span class="hljs-type">SubDebugA</span>()
    <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = <span class="hljs-type">DeepSubA</span>()
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = <span class="hljs-type">UIImage</span>.<span class="hljs-keyword">init</span>(named: <span class="hljs-string">"logo"</span>) {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"has logo"</span>)
    }
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = <span class="hljs-type">UIImage</span>.<span class="hljs-keyword">init</span>(named: <span class="hljs-string">"icon"</span>) {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"has icon"</span>)
    }
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = <span class="hljs-type">UIImage</span>.<span class="hljs-keyword">init</span>(named: <span class="hljs-string">"icon_test"</span>) {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"has icon_test"</span>)
    }
}
</code></pre><blockquote><p>这里为了方便验证，直接设置 <code>Debug Configuration</code> 下的 <code>Excluded Source File Names</code>。如图 <img src="/media/2020-04-04/15859854120322.jpg" alt="-w984"/> 实际用到项目中可根据自己项目自行对不同 <code>Configuratio</code> 进行配置。</p></blockquote><p>下面我们来探索下这个路径的配置规则。</p><p>如果我们想要排除 <code>A</code> 和 <code>B</code> 目录下的 <code>Debug</code> 文件夹的所有内容，按照常规思路，理所当然直接写上 <code>Debug/*</code>，然后编译发现上面的测试代码编译报错，找不到类 <code>DebugA</code>,<code>DebugB</code>。</p><pre data-language="undefined"><code>
ViewController.swift:18:22: Use of unresolved identifier 'DebugA'
ViewController.swift:19:22: Use of unresolved identifier 'DebugB'
</code></pre><p>屏蔽掉这两处代码运行，发现 <code>has logo</code> 和 <code>has icon</code> 都输出了。</p><p>所以 <code>Debug/*</code> 只能屏蔽 <code>Debug</code> 根目录下的文件，子文件夹无法屏蔽（因为 <code>.xcasset</code> 实质上也是一个文件夹，所以无法被屏蔽）。</p><p>如果确实想要屏蔽 <code>Debug</code> 下所有内容，要怎么处理呢？目前我还没找到比较好的方式😂，只能一个个目录排除了。拿上面的的结构来说，如果要排除文件夹 <code>A</code> <code>B</code> 目录下的 <code>Debug</code>，可能就得这样配置 <code>Debug/*</code> <code>Debug/*/*</code> <code>Debug/*/*/*</code>，如图</p><img src="/media/2020-04-04/15859945623293.jpg" alt="-w589"/><p>所以这里支持的匹配模式主要有以下两种：</p><ul><li>文件名完全匹配，比如 <code>ModelA.Swift</code></li><li>通配符，如 <code>Debug/*.Swift</code> <code>Debug/*.*</code> <code>*/Debug/*</code> <code>Debug/*/*/*.png</code></li></ul><h2>Development Assets</h2><img src="/media/2020-04-04/15859936373369.jpg" alt="-w1219"/><blockquote><p>关于这个配置项可以查看 <a href="https://developer.apple.com/videos/play/wwdc2019/233/">WWDC 2019 Session 233 Mastering Xcode Previews</a></p></blockquote><p><code>Xcode 11</code> 新增了一个 <code>Development Assets</code> 的配置项，简单尝试了下，但是似乎没有生效。我把上面目录结构中的 <code>SubA.xcassets</code> 加到里面，然后用<code>release</code> 模式跑起来还是能读到对应的图片，不知道是不是姿势不对。</p><p>其实重点还是 <code>Excluded Source File Names</code> 这个编译配置，有时候会有事半功倍的效果。</p></div><span>Tagged with: </span><ul class="tag-list"></ul></article></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>