<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Vong</title><description>记录iOS开发点滴～</description><link>https://vonglo.cn</link><language>zh</language><lastBuildDate>Tue, 29 Oct 2024 09:09:51 +0800</lastBuildDate><pubDate>Tue, 29 Oct 2024 09:09:51 +0800</pubDate><ttl>250</ttl><atom:link href="https://vonglo.cn/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://vonglo.cn/posts/iOS16-Live-Activity</guid><title>iOS16 Live Activity 初体验</title><description></description><link>https://vonglo.cn/posts/iOS16-Live-Activity</link><pubDate>Sun, 31 Jul 2022 00:13:00 +0800</pubDate><content:encoded><![CDATA[<p>WWDC 2022 Keynote 中苹果给我们介绍了 iOS 16 中一个比较亮眼的更新：Live Activity（实时活动），开发者可以在锁屏页面上放置一个可以“实时”更新的 Widget，比如外卖或者打车应用，在开启实时活动之后我们可以在锁屏页上实时看到外卖小哥/司机与我们的距离及预计到达时间。但是这一 API 及对应功能并没有第一时间放出，而是随着 iOS 16 Beta4 一起放出：<a href="https://developer.apple.com/cn/news/?id=hi37aek8 "【实时活动现已推出 Beta 版本】"" target="_blank">【实时活动现已推出 Beta 版本】</a>。</p><p>这篇文章主要是对官方 API 做一个简单提炼，并梳理下一些需要注意的点。</p><h2>写在前面</h2><ul><li>Live Activity 功能及正式 API 不会随 iOS 16 的首个正式版本释出，而是在今年晚些时候释出，具体时间没有给；</li><li>只有在 Live Activity 正式释出后，才可提交带对应<a href=https://vonglo.cn/posts/iOS16-Live-Activity>...></a></li></ul><br><br><h3><a href=https://vonglo.cn/posts/iOS16-Live-Activity>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://vonglo.cn/posts/Xcode-Condition-Build</guid><title>iOS 中资源的条件编译</title><description></description><link>https://vonglo.cn/posts/Xcode-Condition-Build</link><pubDate>Sat, 21 Nov 2020 00:13:00 +0800</pubDate><content:encoded><![CDATA[<p>日常开发中常常遇到某些类及其引用的资源文件仅在 <code>Debug</code> 或内测版本中生效，而不希望带到线上版本。因为一来会增加包体积，二来会把一些内部功能的相关接口暴露，导致可能的一些动态调试。那么有没有避免的方案呢？</p><h2>Pod</h2><p>答案肯定是有的，通常的做法是把对应功能抽成单独的 <code>pod</code> 库，然后仅 <code>Debug</code> 模式才集成到主工程，发出去的版本不集成。通常方式如下，以 <code>FLEX</code> 为例：</p><pre data-language="ruby" class="hljs"><code>pod <span class="hljs-string">'FLEX'</span>, <span class="hljs-string">'~&gt; 2.0'</span>, <span class="hljs-symbol">:configurations</span> =&gt; [<span class="hljs-string">'Debug'</span>]
</code></pre><p>但是如果某些强耦合主工程无法拆成独立 <code>pod</code> 的功能，这种方式可能就不再适用了。</p><h2>条件编译</h2><p><code>pod</code> 这条路走不通，有没有其他方式呢？答案也是肯定的，也是大家经常采用的方式，使用条件编译。也就是将对应类文件及引用到的地方使用类似下面的方式：</p><pre data-language="undefined" class="hljs"><code>
#if DEBUG
// 放入仅Debug模式下生效的代码
#endif
</code></pre><p>以上两种方式将大部分场景 <code>cover</code> 住了，但是假设对应的类文件还引用到了图片、<code>Storyboard</code>、<code>Xib</code><a href=https://vonglo.cn/posts/Xcode-Condition-Build>...></a></p><br><br><h3><a href=https://vonglo.cn/posts/Xcode-Condition-Build>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://vonglo.cn/posts/An-Abnormal-Swift-Crash</guid><title>聊聊最近遇到的一个Crash</title><description></description><link>https://vonglo.cn/posts/An-Abnormal-Swift-Crash</link><pubDate>Sun, 20 Sep 2020 00:13:00 +0800</pubDate><content:encoded><![CDATA[<h2>卖个关子</h2><pre data-language="swift" class="hljs"><code><span class="hljs-comment">// 代码段1</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span>: <span class="hljs-title">NSObject</span> </span>{
    <span class="hljs-keyword">deinit</span> {
         <span class="hljs-built_in">print</span>(<span class="hljs-string">"deinit "</span> + <span class="hljs-type">String</span>(format: <span class="hljs-string">"%p"</span>, <span class="hljs-keyword">self</span>))
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">UIViewController</span> </span>{
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">super</span>.viewDidLoad()
        <span class="hljs-keyword">var</span> x: <span class="hljs-type">Manager?</span> = <span class="hljs-type">Manager</span>()
        x = <span class="hljs-literal">nil</span>
    }
}
</code></pre><pre data-language="objectivec" class="hljs"><code><span class="hljs-comment">// 代码段2</span>
<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Manager</span> : <span class="hljs-title">NSObject</span></span>

<span class="hljs-keyword">@end</span>

<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Manager</span></span>

- (<span class="hljs-keyword">void</span>)dealloc {
    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"dealloc: %@"</span>, [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@"%p"</span>, <span class="hljs-keyword">self</span>]);
}

<span class="hljs-keyword">@end</span>

<span class="hljs-class"><span class="hljs-keyword">@interf<a href=https://vonglo.cn/posts/An-Abnormal-Swift-Crash>...></a></span></span></code></pre><br><br><h3><a href=https://vonglo.cn/posts/An-Abnormal-Swift-Crash>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://vonglo.cn/posts/Eliminate-animation-hitches-with-XCTest</guid><title>WWDC20 10077 - 使用 XCTest 消除动画卡顿</title><description></description><link>https://vonglo.cn/posts/Eliminate-animation-hitches-with-XCTest</link><pubDate>Sat, 20 Jun 2020 00:13:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>本文基于 <a href="https://developer.apple.com/videos/play/wwdc2020/10077/" target="_blank">Session 10077 - Eliminate animation hitches with XCTest</a></p></blockquote><h2>概述</h2><p>iOS中动画无处不在，应用中优雅流畅的动画可以显著提升用户体验，同理卡顿也会影响用户体验。通过这个 WWDC Session，我们将学会如何通过 XCTest 来检测滑动和动画过程中的掉帧，进而在开发阶段就能解决问题，避免糟糕的用户体验。</p><h2>如何定义卡顿（Hitches）</h2><p>当用户在页面上操作时，比如上下滑或者点击导航栏上的返回按钮时，主要焦点集中在手势的交互上。良好的交互体验是提供“众享丝滑”的响应速度，反之用户将会感知到明显的卡顿。我们将这些用户可感知的“抖动”称之为卡顿（Hitches），卡顿是指某一帧画面的显示比预期要晚。卡顿会影响用户体验，甚至让用户失去对应用的兴趣（即卸载🐶）。</p><p>如图所示，我们可以逐帧来看动画过程，当我们缓慢移动时，前2帧按预期显示在屏幕上，滑动很流畅且是“跟手”的，但是第3帧停留在屏幕上的时间超出预期，滑动不再“跟手”，第4帧出现时，列表出现了<a href=https://vonglo.cn/posts/Eliminate-animation-hitches-with-XCTest>...></a></p><br><br><h3><a href=https://vonglo.cn/posts/Eliminate-animation-hitches-with-XCTest>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://vonglo.cn/posts/Attention-to-Category</guid><title>一个不规范的 Category 写法导致的“血案”</title><description></description><link>https://vonglo.cn/posts/Attention-to-Category</link><pubDate>Mon, 20 Apr 2020 00:13:00 +0800</pubDate><content:encoded><![CDATA[<p>名字取得有点标题党，不然没人愿意点进来😂😂😂</p><h3>1.背景</h3><p>项目前后两个版本，线上监控显示整体启动时间缩短了近 <strong>300ms</strong>，而且包体积也变小了 <strong>5M</strong>（提交到 App Store 的ipa包）。但是新版本没有大的需求插入，只是 <code>bugfix</code> 版本，启动阶段的代码也没有相关改动。为何会引起包体积和启动时间的变化呢？</p><p>使用 <code>Instrument</code> 多次跑耗时分析，发现两个版本启动阶段的 <code>getMethodNoSuper_nolock()</code> 函数的耗时的差异非常明显。关键是这个还是系统函数，看起来是消息发送阶段的耗时增加了。</p><img class="lazyload" data-src="https://vonglo.cn/media/2020-03-11/15839137733724.jpg" alt="Instrument 启动阶段耗时对比"/><h3>2.继续分析</h3><p>上面 <code>Instrument</code> 的方法耗时在设置隐藏系统库之后，对比发现没有明显的变化，说明不是启动阶段（<code>didFinishLaunching</code> 到 <code>RootVC viewDidAppear</code>）有大的改动导致的，这样一下子也没法定位到问题。所以只能比对版本间的代码，这里使用的是 <code>Kaleidoscope</code>。</p><blockquote><p><code>Kaleidoscope</code> 具体配置可以参考 nico 之前的文章<a href="https://punmy.cn/2019/02/28/%E6%95%88%E7%8E%87%E7%A5%9E%E5%99%A8%20Kaleidoscope.html" target="_blank">代码比对神器<a href=https://vonglo.cn/posts/Attention-to-Category>...></a></a></p></blockquote><br><br><h3><a href=https://vonglo.cn/posts/Attention-to-Category>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://vonglo.cn/posts/BackgroundTask</guid><title>全新后台任务框架及最佳实践</title><description></description><link>https://vonglo.cn/posts/BackgroundTask</link><pubDate>Sun, 20 Oct 2019 00:53:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p><a href="https://xiaozhuanlan.com/topic/8362954017" target="_blank">WWDC 19 专栏文章目录</a> WWDC 2019 Session 707: <a href="https://developer.apple.com/videos/play/wwdc2019/707/" target="_blank">Advances in App Background Execution</a></p></blockquote><p>2010年 iOS4 时代，iOS 的多任务系统面世，至今已经9个年头，期间后台模式及场景也逐渐增多，这为开发者和用户带来了很多可能性。随着 iOS 版本的迭代，慢慢的越来越多的后台运行场景被苹果所支持。与此同时为了改善用户体验以及延长电池寿命，苹果对于应用后台任务有着比较严苛的限制及审核规则，只有特定使用场景，应用才可能在后台持续运行，比如导航、音乐播放，VoIP 等。如果我们的应用恰好符合后台模式的场景，那么应该怎样利用好这一点来给用户好的体验呢？相信通过这一集 Session，你心中应该会有一个比较明确的答案~</p><h2>概览</h2><p>目前苹果支持9种后台模式，具体类型可使用 Xcode 的 Capabilities 来查看，如下图所示</p><img class="lazyload" data-src="https://vonglo.cn/oldimages/15603558945067.jpg" alt="-w1018"/><p>通过上图对比可以看到 Xcode11 将 <code>Newsstand downloads</code> 这种后台模式移除，并新增了一个 <code>Backg<a href=https://vonglo.cn/posts/BackgroundTask>...></a></code></p><br><br><h3><a href=https://vonglo.cn/posts/BackgroundTask>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://vonglo.cn/posts/WWDC-2018-Signpost</guid><title>WWDC 2018：使用日志框架测量性能</title><description></description><link>https://vonglo.cn/posts/WWDC-2018-Signpost</link><pubDate>Fri, 22 Feb 2019 22:17:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>本文是 WWDC 2018 Session 405 的观后感，原视频和 pdf 可以在<a href="https://developer.apple.com/videos/play/wwdc2018/405/" target="_blank">这里</a>看到。 首发于<a href="https://xiaozhuanlan.com/topic/3789465012" target="_blank">小专栏</a>。</p></blockquote><p>众所周知，应用交互的流畅度决定了用户对这款用户的喜爱度，所以对于每个 iOS 工程师而言，应用的流畅程度是非常重要的。而这里所说的流畅度在工程师层面来理解就是应用的性能是否处于一个比较优的状态。那我们在发现页面卡顿时，如何去检测卡顿是哪一段代码引起的呢？目前业界的卡顿检测已经非常多了，比如 Instrument 的 Time Profile，各种基于 <code>runloop</code> 的卡顿率检测开源库。但是今天主要来说一说 iOS12 苹果为我们带来的一个新的检测方案，也就是基于 <code>OSLog</code> 的一套新 API。</p><p>好了，题外话讲完，我们正式进入正题。该 Seesion 主要有下面几部分组成：</p><ul><li>集成 signposts<ul><li>异步并行操作</li><li>添加原数据</li><li>控制 signposts 的启用和禁用</li><li>使用 Instruments 分析</li></ul></li></ul><p>首先先简单回顾一下 <code>OSLog</code>，苹果在2016年推出这个现代化的日志记录框架，用来获取系统调<a href=https://vonglo.cn/posts/WWDC-2018-Signpost>...></a></p><br><br><h3><a href=https://vonglo.cn/posts/WWDC-2018-Signpost>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://vonglo.cn/posts/Understanding-Crash</guid><title>WWDC 2018：理解崩溃以及崩溃日志</title><description></description><link>https://vonglo.cn/posts/Understanding-Crash</link><pubDate>Fri, 22 Feb 2019 22:13:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>本文首发于<a href="https://juejin.im/post/5b1e833ce51d450686186557" target="_blank">掘金</a>。</p></blockquote><p>人非圣贤，孰能无过。每个人在写代码的时候，或多或少都会犯错，那么如何调试、找出问题所在呢？让我们跟随苹果工程师一起了解一下崩溃是如何产生以及如何解决它们的吧。</p><h2>1. 基础知识</h2><p>崩溃是什么？崩溃是当应用想要做某件事的时候，被意外终止。</p><h3>1.1 崩溃为什么会发生</h3><p>主要是以下几方面原因</p><ul><li>CPU 无法执行的代码。</li><li>被操作系统“强杀”，系统为了用户体验，会强制终止掉那些卡顿时间过长或者内存消耗过高的应用。</li><li>编程语言为了防止错误发生而触发的崩溃，如 <code>NSArray</code> 或者 <code>Swift.Array</code> 越界</li><li>开发者为了防止错误发生而触发的崩溃，比如一些非空判断的断言</li></ul><h3>1.2 崩溃长什么样子</h3><h4>1.2.1 调试器里</h4><p>当我们连接着 <code>Xcode</code> 进行调试的时候，遇到崩溃，大概长这个样子。 </p><p>当连着调试器的时候，我们能够拿到崩溃现场的一些调用栈以及对应的方法，当没有连着调试器的时候，系统会将崩溃日志存储到磁盘当中。</p><h4>1.2.2 崩溃日志里</h4><p>通常情况下，<code>release</code> 模式的应用的崩溃日志是没有符号化的，日志内记录的都是地址。我们<a href=https://vonglo.cn/posts/Understanding-Crash>...></a></p><br><br><h3><a href=https://vonglo.cn/posts/Understanding-Crash>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://vonglo.cn/posts/2018-Summary</guid><title>时光的河如海流</title><description></description><link>https://vonglo.cn/posts/2018-Summary</link><pubDate>Sun, 3 Feb 2019 22:13:00 +0800</pubDate><content:encoded><![CDATA[<p>老规矩，这次又是2018年的最后一天，是时候更新一下年终总结了，水一下，纯当一个记录~</p><h3>工作</h3><p>今年工作上的变动还是蛮大的，从年初的直播 SDK 拆分完成之后的交付，到4月份的时候去到美拍北京分部，再到12月底的离职，结束了在美图将近5年的时光，感谢在美图待的这几年，自己从一个无从下手的菜鸟慢慢变成一个得心应手的老菜鸟。由于自身原因（老婆在广州，后面生活部分也有提到），在年底的时候裸辞，然后去到广州，开启一段找工作之旅，希望年后有好消息😃。</p><p>这一年来主要是在北京，自己的角色也发生了一些变化，稍微了解了一点点的“管理”的皮毛，也感谢这个机会，让自己在非技术层面上也有一定的收获。 到北京后主要是负责美拍 iOS 社区的相关开发，其中大部分都是日常迭代，乏善可陈。比较有成就感的两件事：</p><ul><li>总算实现了一套基于 YYModel 和 IGListKit 的方案来替代现有美拍基于 ResetKit(CoreData) 的方案，最终在新 App (<a href="https://itunes.apple.com/cn/app/vcus-%E7%94%A8%E9%9F%B3%E4%B9%90%E6%8B%8Dvlog/id1445969821?mt=8" target="_blank">VCUS</a>)中实践上线，不知道最终会不会在美拍中上线。后面也会更新一<a href=https://vonglo.cn/posts/2018-Summary>...></a></li></ul><br><br><h3><a href=https://vonglo.cn/posts/2018-Summary>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://vonglo.cn/posts/Some-thoughts-On-GMTC-2018</guid><title>GMTC 之旅</title><description></description><link>https://vonglo.cn/posts/Some-thoughts-On-GMTC-2018</link><pubDate>Sun, 28 Oct 2018 13:27:00 +0800</pubDate><content:encoded><![CDATA[<p>上周凑巧有机会拿到 GMTC 的票，然后去现场体验了一下。这里主要记录第一次参加这种线下大会的一些感受。</p><p>大会在 6.21~6.22 进行，由于时间问题，我只去了两个自己感兴趣的专题：性能优化专场以及 iOS 新技术专场。 性能优化专场在21号下午进行，当天早上 <code>Flutter Release Preview 1</code> 放出，更多关于 Flutter 的文章，可以在我们公众号<code>知识小集</code>上获取。</p><h3>性能优化专场</h3><p>当天下午提前一小时从公司出发，1：30 到现场时，会场已经满座，只能坐地下，第二场一些人走了之后才空出一些座位。</p><p>第一场是 <code>LinkedIn</code> iOS 工程师带来的《LinkedIn 移动应用的性能优化实践》，分享了领英的一些性能优化实践。 随着应用体量（功能）变得越来越庞大，最初的应用架构会变得越来越撑不住，所以需要适时调整合理的应用架构。领英使用组件化和标准化来提高代码复用率以及项目复杂度，进而减少了线上的崩溃率和性能问题。建立完善的性能监控体系对线上用户的性能数据进行分析，发现问题并解决问题，同<a href=https://vonglo.cn/posts/Some-thoughts-On-GMTC-2018>...></a></p><br><br><h3><a href=https://vonglo.cn/posts/Some-thoughts-On-GMTC-2018>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://vonglo.cn/posts/Replace-System-Volume-View</guid><title>替换系统音量提示的实现和遇到的坑</title><description></description><link>https://vonglo.cn/posts/Replace-System-Volume-View</link><pubDate>Sun, 3 Jun 2018 17:47:00 +0800</pubDate><content:encoded><![CDATA[<p>相信平时大家在用 iPhone 看视频调节音量时，总会被系统的音量提示所打扰，因为它会遮住一部分内容。所以很多视频应用都使用自定义音量视图的方式来替代系统的音量提示。</p><p>比如下面三张截图，分别来自 Instagram、哔哩哔哩、即刻</p><h3>原理</h3><p>这里主要记录一下在项目中如何替换系统音量提示视图的过程。通过 <code>Google</code> 和 <code>stackoverflow</code>，可以查到，如果要自定义音量提示，需要做到以下几步：</p><ol><li>激活 <code>AudioSession</code></li><li>创建一个 <code>MPVolumeView</code>，并将其添加到当前可见的视图层级当中，同时将其 frame 设置到不可见区域</li><li>监听音量按钮触发事件，改变音量提示</li></ol><h3>实现</h3><p>然后为了调用统一且音量视图层级永远在最上方（即不被 <code>Alert</code> 等挡住），首先想到使用一个 <code>UIWindow</code>，然后自定义视图和系统的视图加到这个视图层级上，初始化时 <code>frame</code> 为 <code>CGRectZero</code>，<code>hidden</code> 属性为 <code>NO</code>（注意这里必须为 <code>NO</code>，不然系统音量提示仍会出现，上面说到的第2点）；要显示时设置其 <code>frame</code> 设置<a href=https://vonglo.cn/posts/Replace-System-Volume-View>...></a></p><br><br><h3><a href=https://vonglo.cn/posts/Replace-System-Volume-View>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://vonglo.cn/posts/Pod-Resource</guid><title>Pod 中资源引入方式对比</title><description></description><link>https://vonglo.cn/posts/Pod-Resource</link><pubDate>Sat, 17 Mar 2018 13:18:00 +0800</pubDate><content:encoded><![CDATA[<p>写这篇博客起因是由于周四在知识小集发了一个 <a href="https://weibo.com/3129068073/G7rJx4Pag" target="_blank">Tip</a>，讲 <code>Pod</code> 里面使用了 <code>.xcassets</code> 会导致 <code>Xcode 9</code> 打出来的包没有 <code>icon</code> 的解决方案。然后和 <a href="https://weibo.com/damonone" target="_blank">@Damonwong</a> 展开了一下讨论。当然这条 Tip 讲得不全对，而且表达得不是很清晰，所以这里专门开一篇文章来讲一下那个 Tip 想要表达的意思，最后也会附上对应的 Demo。也当做之后要写的模块化系列的文章开篇吧。</p><p>首先我们先来给出结论：</p><ul><li><strong><code>podspec</code> 里面写资源时，最好用 <code>s.resource_bundle</code> 而不是 <code>s.resource</code></strong></li><li><strong>只有 <code>podspec</code> 使用 <code>resource</code> 且明确写了 <code>.xcassets</code> 的情况下才会导致 <code>Xcode 9</code> 打出来的包没有 <code>icon</code></strong></li></ul><blockquote><p>环境配置：Xcode 9.2 、Cocoapods 1.4.0 本文所涉及到的资源主要是指 <code>png</code> 格式的图片</p></blockquote><p>下面我们先来了解一下这两种方式的具体情况，以及各自的优劣势，最后通过一个 <code>Demo</code> 来验证我们上面给的结论。</p><h2>resource 和 resourc<a href=https://vonglo.cn/posts/Pod-Resource>...></a></h2><br><br><h3><a href=https://vonglo.cn/posts/Pod-Resource>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://vonglo.cn/posts/2017-Summary</guid><title>亦无岁月可回头</title><description></description><link>https://vonglo.cn/posts/2017-Summary</link><pubDate>Fri, 16 Feb 2018 00:13:00 +0800</pubDate><content:encoded><![CDATA[<p>2018 即将来到(哈哈哈哈哈哈，我说的是农历年)，这篇文章纯当一篇水文，做个2017的年终总结。</p><h3>工作</h3><p>来美图工作已经快4年了（算上实习的话），从一个 CollectionView 都不会用的人，到现在慢慢得能够比较轻松应对现在的工作。</p><p>去年工作上最有成就感的两件事情：</p><ul><li>在业界的几种模块化方式上结合美拍实际情况进行了简单的实践。年后写篇文章分享一下这个过程和思路。</li><li>配合架构同学让美拍直播实现了真正的秒开。</li></ul><blockquote><p>讲真陌陌直播秒开真的很牛逼，现在美拍也能达到这个水平了！</p></blockquote><p>年中的时候，买了几本书，目前只看了其中三本，年后再继续吧。 12月的时候美拍开始996，说真的有点累，每天晚上10点多到家，洗完澡差不多到睡觉时间，希望年后不要再继续了😂还是比较怀念之前有双休的日子。 对于学习的方式也发生了一点变化，以前总是想着要学很多，列了很多待学习项，但是最后都是不了了之，现在慢慢开始往某一个方向去深入了解，其他的做个基本了解就 ok。</p><h3>生活</h3><p>随着毕业季到来，和公司的两个小鲜肉合租，周末偶尔自己做做饭，刚开始兴趣比较大，<a href=https://vonglo.cn/posts/2017-Summary>...></a></p><br><br><h3><a href=https://vonglo.cn/posts/2017-Summary>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://vonglo.cn/posts/Modern-Objective-C</guid><title>Modern Objective-C</title><description></description><link>https://vonglo.cn/posts/Modern-Objective-C</link><pubDate>Fri, 21 Apr 2017 20:51:00 +0800</pubDate><content:encoded><![CDATA[<p>本文主要介绍一些 Objective-C 的一些新特性。</p><h3>从一个 Bug 来说说 Objective-C 中的指定构造器</h3><p>某天测试反馈，iOS8 点击按钮时弹出一个列表视图出现必现崩溃，看了下崩溃日志，是野指针导致导出乱崩，具体是 <code>[xxx collectionView:numberOfItemsInSection:] unrecognized selector send to instance xxxxx</code>。 连上设备调试，发现 <code>setupDataSource</code> 走了两次，由于调用栈非常类似，一开始没注意它调了两次，一直没找到问题所在。后面各种断点上去，发现 <code>setupDataSource</code> 方法被调用了两次，进一步 <code>commonInit</code> 被调用了两次。最后查看初始化代码，才发现调用 <code>convenience init method</code> 时，没有调 <code>designed init method</code>，并且调完之后又再调了一次 <code>commonInit</code>。具体看下代码：</p><pre data-language="objc" class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">PanelView</span>()</span>
<span class="hljs-keyword">@p<a href=https://vonglo.cn/posts/Modern-Objective-C>...></a></span></code></pre><br><br><h3><a href=https://vonglo.cn/posts/Modern-Objective-C>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://vonglo.cn/posts/Useful-Xcode-Plugins</guid><title>Xcode 常用插件</title><description></description><link>https://vonglo.cn/posts/Useful-Xcode-Plugins</link><pubDate>Sat, 17 Sep 2016 20:29:00 +0800</pubDate><content:encoded><![CDATA[<p>工欲善其事，必先利其器。随着 Xcode 的一步步变得强(yong)大(zhong)，许多功能已经被集成到 Xcode 中，但是日常开发还是会遇到很多小问题，影响效率，于是 Xcode plugins 便派上用场了。下面介绍一下自己在开发中常用的插件，排名不分先后，仅按字母排序。</p><blockquote><p>关于 Xcode8 不能使用插件的问题，可以在我上一篇文章<a href="1">让你的 Xcode8 继续使用插件</a>找到解决方案。</p></blockquote><h3><a href="2">Alcatraz</a></h3><p>这个就不用多说了吧，所有插件包管理器，快捷键 <code>cmd + shift + 9</code>。</p><h3><a href="3">ATProperty</a></h3><img class="lazyload" data-src="https://vonglo.cn/oldimages/14740919509236.gif"/><p>平时在属性声明时，总要写一堆的诸如 <code>@property (strong, nonatomic) UIWindow *window;</code>之类的，前面那一长串在属性一多时，写起来挺累的。这个插件正是为了解决这个痛点而存在，快捷键如下：</p><table><thead><tr><th align="left">快捷键</th><th align="left">结果</th></tr></thead><tbody><tr><td align="left">@t</td><td align="left">@property (nonatomic, strong)</td></tr><tr><td align="left">@w</td><td align="left">@property (nonatomic, weak)</td></tr><tr><td align="left">@y</td><td align="left">@property (nonatomic<a href=https://vonglo.cn/posts/Useful-Xcode-Plugins>...></a></td></tr></tbody></table><br><br><h3><a href=https://vonglo.cn/posts/Useful-Xcode-Plugins>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://vonglo.cn/posts/Make-Your-Xcode8-Great-Again</guid><title>让你的 Xcode8 继续使用插件</title><description></description><link>https://vonglo.cn/posts/Make-Your-Xcode8-Great-Again</link><pubDate>Sat, 10 Sep 2016 20:08:00 +0800</pubDate><content:encoded><![CDATA[<p>随着 iOS10 的正式版即将发布，Xcode8 GM 也在发布会后放出，本文不会涉及到 Xcode8 有哪些更新，而是记录了如何让 Xcode8 继续支持 Plugin。</p><h3>Update:</h3><p><strong>2017.4.9</strong></p><p>Xcode 8.3 生成 XcodeGr8 后，XVim 即使用脚本更新也会失效，需要重新编译一次。下载 XVim 到本地后，需要删除删除如下几个文件：</p><blockquote><p>IDEPlaygroundEditor+XVim.h IDEPlaygroundEditor+Xvim.m 同时屏蔽掉 XVim/XVimHookManager.m 里面对上面两个文件的引用和调用</p></blockquote><p>详情参考这个 <a href="issue">issue: Build failure with Xcode 8.3</a></p><p><strong>2016.10.8</strong> 如果你的 XcodeGr8 时不时就转菊花卡死，可以试下这种方式：打开<code>系统偏好设置-&gt;安全性与隐私-&gt;通讯录-&gt;将 Xcode 前面的勾去掉</code>，如下图所示，解决方案来自 <code>Xvim</code> 的这个 <a href="11">issue</a>。</p><p><strong>2016.9.16</strong> 看到 Gi<a href=https://vonglo.cn/posts/Make-Your-Xcode8-Great-Again>...></a></p><br><br><h3><a href=https://vonglo.cn/posts/Make-Your-Xcode8-Great-Again>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://vonglo.cn/posts/Note-for-iOS-Animations-by-Tutorials</guid><title>iOS Animations by Tutorials 2.0 笔记</title><description></description><link>https://vonglo.cn/posts/Note-for-iOS-Animations-by-Tutorials</link><pubDate>Sat, 27 Aug 2016 00:08:00 +0800</pubDate><content:encoded><![CDATA[<p>这本书主要分成七个部分，二十七个章节，涵盖了从底层的 Core Animation 到上层的 UIView 的动画封装，AutoLayout 动画以及 ViewController 之间的转场动画。最后选择了两个开源动画库（<a href="https://github.com/icanzilb/EasyAnimation" target="_blank">Easy Animation</a>、<a href="https://github.com/facebook/pop" target="_blank">pop</a>）进行实践。本篇文章主要是在阅读、学习过程中的一些笔记，留下记录，日后忘记可以再来翻看。</p><h2>Section Ⅰ View Animation</h2><p>这部分主要是关于 UIView 的动画，UIView 层次的动画是一些经过封装的上层 API，简单但是实用。基本都是日常用到的，比如位置、大小、透明度、旋转、关键帧动画等等，所以没啥好记录的。</p><h4>View 之间的过渡转场</h4><p>主要是使用如下两个方法:</p><pre data-language="ObjectiveC" class="hljs"><code>+ (<span class="hljs-keyword">void</span>)transitionWithView:(<span class="hljs-built_in">UIView</span> *)view duration:(<span class="hljs-built_in">NSTimeInterval</span>)duration options:(<span class="hljs-built_in">UIViewAnimationOptions</span>)options animations:(<span class="hljs-keyword">void</span><a href=https://vonglo.cn/posts/Note-for-iOS-Animations-by-Tutorials>...></a></code></pre><br><br><h3><a href=https://vonglo.cn/posts/Note-for-iOS-Animations-by-Tutorials>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://vonglo.cn/posts/Communication-Between-WebView-and-JS</guid><title>WebView 与 JS 的交互</title><description></description><link>https://vonglo.cn/posts/Communication-Between-WebView-and-JS</link><pubDate>Mon, 19 Oct 2015 00:14:00 +0800</pubDate><content:encoded><![CDATA[<p>本文主要分析一些 iOS 中 WebView 与 JavaScript 交互的一些框架。</p><h3>UIWebView 调 JS 方法</h3><p>通过调用如下方法：</p><pre data-language="ObjectiveC" class="hljs"><code>- (<span class="hljs-built_in">NSString</span> *)stringByEvaluatingJavaScriptFromString:(<span class="hljs-built_in">NSString</span> *)script;
</code></pre><p>比如获取网页 title，也可以动态注入 JS，先写一个 JS 函数</p><pre data-language="JavaScript" class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showAlert</span>(<span class="hljs-params"></span>) </span>{  
    alert(<span class="hljs-string">'show alert'</span>);  
} 
</code></pre><p>然后保存为js 文件，最后读取这个文件并注入</p><pre data-language="ObjectiveC" class="hljs"><code><span class="hljs-built_in">NSString</span> *filePath = [[<span class="hljs-built_in">NSBundle</span> mainBundle] pathForResource:<span class="hljs-string">@"test"</span> ofType:<span class="hljs-string">@"js"</span>];  
<span class="hljs-built_in">NSString</span> *jsString = [[<span class="hljs-built_in">NSString</span> alloc] initWithContentsOfFile:filePath];  
[webView stringByEvaluatingJavaScrip<a href=https://vonglo.cn/posts/Communication-Between-WebView-and-JS>...></a></code></pre><br><br><h3><a href=https://vonglo.cn/posts/Communication-Between-WebView-and-JS>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://vonglo.cn/posts/How-to-Create-an-iOS-Book-Open-Animation-part-two-translation</guid><title>如何创建一个翻书动画(Part2)[译]</title><description></description><link>https://vonglo.cn/posts/How-to-Create-an-iOS-Book-Open-Animation-part-two-translation</link><pubDate>Tue, 1 Sep 2015 23:11:00 +0800</pubDate><content:encoded><![CDATA[<p>欢迎回到 iOS 翻书动画教程系列！在该系列的<a href="http://www.raywenderlich.com/94565/how-to-create-an-ios-book-open-animation-part-1" target="_blank">第一部分</a>(<a href="https://vonglo.cn/posts/How-to-Create-an-iOS-Book-Open-Animation-part-one-translation">译文</a>，你已经知道如何创建自定义的 layout 以及如何在 app 中使用阴影效果来创建景深和模拟现实。在这篇教程中，你将学到如何创建一个自定义的转场以及如何使用 pinch 手势来打开书本。</p><blockquote><p>2019.11.21 update 本文中图片和资源相关链接可能已失效，如需查阅，请查看原文 感谢<a href="https://twitter.com/hegedus90" target="_blank">Attila Hegedüs</a>创建了这个棒棒哒示例工程。</p></blockquote><p>原文：<a href="http://www.raywenderlich.com/?p=97690" target="_blank">How to Create an iOS Book Open Animation: Part 2</a></p><h2>开始</h2><p>这篇教程基于<a href="https://vonglo.cn/posts/How-to-Create-an-iOS-Book-Open-Animation-part-one-translation">第一部分</a>。如果你不了解第一部分或者想重新开始，可以下载上一教程的<a href="https://koenig-media.raywenderlich.com/uploads/2015/05/Part-1-Paper-Completed.zip" target="_blank">完整代码</a>。</p><img class="lazyload" data-src="https://vonglo.cn/oldimages/VN2_Start.gif"/><p>在 Xcode 中打开工程。现在你可以选择一本书，然后书本从右滑出(即 push)，这是 UINavigationController 的默认转场行为。但是在这片教程结束的时候，自定义转场看起来像这样：</p><img class="lazyload" data-src="https://vonglo.cn/oldimages/VN_BookOpening.gif"/><p>自定义转场将在书本打开和合上的状态转换中进行丝滑的动画过渡，这种方式非常自然，深得我心。 来吧，骚年，开撸<a href=https://vonglo.cn/posts/How-to-Create-an-iOS-Book-Open-Animation-part-two-translation>...></a></p><br><br><h3><a href=https://vonglo.cn/posts/How-to-Create-an-iOS-Book-Open-Animation-part-two-translation>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://vonglo.cn/posts/How-to-Create-an-iOS-Book-Open-Animation-part-one-translation</guid><title>如何创建一个翻书动画(Part 1)[译]</title><description></description><link>https://vonglo.cn/posts/How-to-Create-an-iOS-Book-Open-Animation-part-one-translation</link><pubDate>Mon, 31 Aug 2015 23:21:00 +0800</pubDate><content:encoded><![CDATA[<p>在这个分两部分的教程系列中，你将开发一个漂亮的 iOS 打开及翻书动画，类似于<a href="https://www.fiftythree.com/paper" target="_blank">Paper by FiftyThree</a>：</p><blockquote><p>2019.11.21 update 本文中图片和资源相关链接可能已失效，如需查阅，请查看原文</p></blockquote><ul><li>第一部分，你将学习如何自定义 UICollectionViewLayout，然后使用景深和阴影来让 app 看起来更加真实。</li><li><a href="http://www.raywenderlich.com/?p=97690" target="_blank">第二部分</a>(<a href="http://t.cn/Ry2rYj5" target="_blank">译文</a>)，你将学习创建自定义的转场动画，然后集成手势来创建自然、简洁的 view 之间的转场。</li></ul><p>原文：<a href="http://www.raywenderlich.com/94565/how-to-create-an-ios-book-open-animation-part-1" target="_blank">How to Create an iOS Book Open Animation: Part 1</a></p><p>本教程主要针对于进阶中的开发者，讲解一些自定义转场以及自定义 collectionView Layout 相关的知识。 如果你之前没有用过 collectionView，那么建议你先看看其他关于 collectionView 的<a href="http://www.raywenderlich.com/tutorials" target="_blank">教程</a>。</p><blockquote><p>感谢<a href="https://twitter.com/hegedus90" target="_blank">Attila Hegedüs</a>创建了这个棒棒哒示例工程。</p></blockquote><h2>开始</h2><p>下载<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2015/05/Starter-Paper1.zip" target="_blank">模板</a>，解压，在 Xcode 中打开。使用模拟器运行程序，将得到<a href=https://vonglo.cn/posts/How-to-Create-an-iOS-Book-Open-Animation-part-one-translation>...></a></p><br><br><h3><a href=https://vonglo.cn/posts/How-to-Create-an-iOS-Book-Open-Animation-part-one-translation>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://vonglo.cn/posts/A-Spinning-Wheel-Layout</guid><title>UICollectionView自定义布局之风火轮[译]</title><description></description><link>https://vonglo.cn/posts/A-Spinning-Wheel-Layout</link><pubDate>Mon, 31 Aug 2015 20:19:00 +0800</pubDate><content:encoded><![CDATA[<p>现在有许多极具创造力的网站，几周前我碰巧浏览到一个名为<a href="http://fff.cmiscm.com/" target="_blank">Form Follows Function</a>的网站，上面有各种交互动画。其中最吸引我的是网站上的导航转轮，转轮由各种交互体验海报组成。</p><p>原文：<a href="http://www.raywenderlich.com/107687/uicollectionview-custom-layout-tutorial-spinning-wheel" target="_blank">UICollectionView Custom Layout Tutorial: A Spinning Wheel</a></p><p>本教程将讲解如何使用自定义的 <code>UICollectionViewFlowLayout</code> 来再现那个导航风火轮。在开始之前，希望你有对 2D 转换、<code>UICollectionView</code> 及其自定义布局的基本知识。如果你对这些还不是很熟悉，推荐你先看看下面几篇教程。</p><ul><li><a href="http://www.raywenderlich.com/78550/beginning-ios-collection-views-swift-part-1" target="_blank">UICollectionView Tutorial Part 1: Getting Started</a></li><li><a href="http://www.raywenderlich.com/78551/beginning-ios-collection-views-swift-part-2" target="_blank">UICollectionView Tutorial Part 2: Reusable Views and Cell Selection</a></li><li><a href="http://www.raywenderlich.com/video-tutorials#collectionview" target="_blank">Video Series: Collection Views</a></li><li><a href="http://www.raywenderlich.com/video-tutorials#CCVL" target="_blank">Video Series: Custom Col<a href=https://vonglo.cn/posts/A-Spinning-Wheel-Layout>...></a></a></li></ul><br><br><h3><a href=https://vonglo.cn/posts/A-Spinning-Wheel-Layout>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://vonglo.cn/posts/Koloda-Second-Version</guid><title>Koloda动画第二版[译]</title><description></description><link>https://vonglo.cn/posts/Koloda-Second-Version</link><pubDate>Sun, 23 Aug 2015 17:31:00 +0800</pubDate><content:encoded><![CDATA[<p>一个月前，我们发布了<a href="https://yalantis.com/blog/how-we-built-tinder-like-koloda-in-swift/" target="_blank">how we developed Tinder-like Koloda in Swift</a>([如何创建一个类似 Tinder 的交互动画[译]](http://0.0.0.0:4000/2015/08/21/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BC%20Tinder%20%E7%9A%84%E4%BA%A4%E4%BA%92%E5%8A%A8%E7%94%BB/))。在开发者与设计师社区这个动画都受到强烈的欢迎，所以我们决定继续改善它。</p><p>原文：<a href="https://yalantis.com/blog/koloda-tinder-like-animation-version-2-prototyping-in-pixate-and-development-in-swift/" target="_blank">Koloda Tinder-Like Animation Version 2.</a></p><p>从我们发布第一个简单的 Koloda 动画后，我们的设计师Dmitry Goncharov坚持要实现他的下一个想法。同样，我们的 iOS 开发工程师，Koloda 动画创建者Eugene Andreyev承诺要让 frame 计算更加自定义化来让更多开发<a href=https://vonglo.cn/posts/Koloda-Second-Version>...></a></p><br><br><h3><a href=https://vonglo.cn/posts/Koloda-Second-Version>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://vonglo.cn/posts/How-We-Built-Tinder-Like-Koloda-Animation-in-Swift-Chinese-Translation</guid><title>如何创建一个类似 Tinder 的交互动画[译]</title><description></description><link>https://vonglo.cn/posts/How-We-Built-Tinder-Like-Koloda-Animation-in-Swift-Chinese-Translation</link><pubDate>Fri, 21 Aug 2015 00:09:00 +0800</pubDate><content:encoded><![CDATA[<p>有时候我认为 Tinder 不仅仅让人们遇见彼此，更多的是它引领了一种交互设计趋势。所以我们非常肯定地说 Tinder 已经完成了他的历史使命，可以安心等待着下一个 Tinder 出现。</p><p>原文:<a href="https://yalantis.com/blog/how-we-built-tinder-like-koloda-in-swift/" target="_blank">How We Built Tinder-Like Koloda Animation in Swift</a></p><p>Tinder 的右滑喜欢，左滑忽略不仅仅在约会（pao）应用中很流行，在购物 App 中也很流行，比如<a href="https://fancy.com/about" target="_blank">Fancy</a>，也是像 Tinder 一样是滑动喜欢的形式。他们之所以才用这种交互形式是因为这种卡片式的交互确实深得用户欢心。卡片上的内容吸引了用户的注意力促使他们去进行一系列操作，进而提高了用户参与度。 还有许多不同种类 App 也是用这种像 Tinder 一样的卡片式滑动交互的例子，比如<a href="https://liveuptop.com/" target="_blank">Uptop</a>，就连谷歌浏览器 iOS 客户端也是用这种卡片形式来管理书签。</p><p>我们把卡片式布局以及基于滑动的交互作为今年的交互设计趋势，我们的<a href="https://yalantis.com/blog/7-up-to-date-mobile-app-design-trends-2015/" target="_blank">这篇文章</a>有相关介绍。之后我们的设计师Dmitry Goncharov创建了一个类似<a href=https://vonglo.cn/posts/How-We-Built-Tinder-Like-Koloda-Animation-in-Swift-Chinese-Translation>...></a></p><br><br><h3><a href=https://vonglo.cn/posts/How-We-Built-Tinder-Like-Koloda-Animation-in-Swift-Chinese-Translation>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://vonglo.cn/posts/AVFoundation-And-GPUImage</guid><title>AVFoundation和 GPUImage初探</title><description></description><link>https://vonglo.cn/posts/AVFoundation-And-GPUImage</link><pubDate>Sun, 24 Aug 2014 00:41:00 +0800</pubDate><content:encoded><![CDATA[<p>最近在做视频相关的东西，然后熟悉了一下AVFoundation框架，以及强大的开源库GPUImage。在这里记录这个过程中遇到的一些问题，以及解决的方法。</p><h3>AVFoundation的一些基本概念</h3><p>根据苹果的官方文档，AVFoundation是用来播放和创建实时的视听媒体数据的框架，同时提供Objective-C接口来操作这些视听数据，比如编辑，旋转，重编码。本文着重讲的是视频的录制和编辑和GPUImage的一些简单使用，其他的都是一笔带过。来看下苹果文档的一个框架图。</p><h4>相关类</h4><ul><li><code>AVAsset</code></li><li><code>AVAssetTrack</code></li><li><code>AVComposition</code></li><li><code>AVVideoComposition</code></li><li><code>AVAudioMix</code></li><li><code>AVMutableAudioMixInputParameter</code></li><li><code>AVMutableVideoCompositionInstrution</code></li><li><code>AVMutableVideoCompositionLayerInstrution</code></li></ul><p>简单的播放可以使用MPMoviePlayerController或者MPMovieViewCo<a href=https://vonglo.cn/posts/AVFoundation-And-GPUImage>...></a></p><br><br><h3><a href=https://vonglo.cn/posts/AVFoundation-And-GPUImage>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://vonglo.cn/posts/Using-Xcode-Efficiently</guid><title>高效利用你的Xcode[译]</title><description></description><link>https://vonglo.cn/posts/Using-Xcode-Efficiently</link><pubDate>Wed, 23 Jul 2014 23:37:00 +0800</pubDate><content:encoded><![CDATA[<p>好莱坞电影里经常看到黑客们手指在键盘上飞速跳跃,同时终端上的代码也随着飞舞。如果你也想像电影里那样,那么你来对地方了。这篇教程将会教你在Xcode编程中更像程序员,你可以称之为魔法、疯狂的技术、好运当头或者黑客。毫无疑问,在学习完本教程之后,不管你怎么认为,都会感觉很酷,同时能更高效地运用Xcode,甚至可以通过这些新发现使你的代码免于毁灭。</p><p><a href="http://www.raywenderlich.com/72021/supercharging-xcode-efficiency" target="_blank">原文地址</a></p><h3>开始</h3><p>要看起来很酷,所以有一些必不可少的因素.下面列出来的是其中一部分</p><ul><li>快速执行任务</li><li>精准</li><li>简洁美观的代码</li></ul><p>要表现地更酷,你可以试着不用鼠标或者触摸板来完成教程中的每一个任务.学习之旅将从学习一些实用的Xcode功能开始,然后通过修复一些在CardTilt中的一些bug来训练。最后你将整理一下你的代码,使整个界面看起来更整洁。在学习该教程时,要记住:它不是教你做一个app,而是教你比以前更有效地利用Xcode来开发app。这篇教程建立在你对Xcode有一个基本的了解的基础上,然后着重于提高你的工作效率。每个人都有自己的编程习惯,本教程并非强制你形成某种<a href=https://vonglo.cn/posts/Using-Xcode-Efficiently>...></a></p><br><br><h3><a href=https://vonglo.cn/posts/Using-Xcode-Efficiently>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://vonglo.cn/posts/Recent-Thoughts</guid><title>最近随想及学期总结</title><description></description><link>https://vonglo.cn/posts/Recent-Thoughts</link><pubDate>Sat, 21 Jun 2014 01:25:00 +0800</pubDate><content:encoded><![CDATA[<p>今天6.21号，学校一年一届的毕业晚会——同歌同行如期进行，这也预示着我下一年也即将滚蛋,外面正进行着很High的泼水节,今年不像前两年那样去混进毕业游行队伍,觉得明年就到自己了,今年就不去凑热闹了.。昨天院里的毕业晚会，看了即将离开的学长学姐的各种有节操没节操的表演，觉得四年过的真的太快。回来的路上，jb说明年毕业晚会你也上去弹唱一首吧，感觉好伤感。</p><p>这学期也马上要结束了，感觉学期初的计划只实现了一半。前期一直在忙着准备找实习，各种充电，从数据结构到算法，从C到Java,从Objective-C到iOS开发。感觉自己需要学的东西太多，而以前积累的知识完全不够。初期的网易终面被刷、去哪儿网笔试跪了、阿里内推电话面试之后没了下文、腾讯笔试没过、华为一面过后莫名其妙地没了下文，一系列的失败被拒让我一度陷入一个迷茫期，同时开始反省自己，然后一步步调整。五月过后，各大互联网公司基本已经结束了实习生的招聘，由于不想跟学校安排的实习，所以报了一个老师的实验室。看着课题是智慧老人系统，看着感觉比较对自己<a href=https://vonglo.cn/posts/Recent-Thoughts>...></a></p><br><br><h3><a href=https://vonglo.cn/posts/Recent-Thoughts>查看全文</a></h3>]]></content:encoded></item><item><guid isPermaLink="true">https://vonglo.cn/posts/Interview-In-NetEase</guid><title>杭州网易行</title><description></description><link>https://vonglo.cn/posts/Interview-In-NetEase</link><pubDate>Wed, 19 Mar 2014 16:12:00 +0800</pubDate><content:encoded><![CDATA[<p>周三接到网易电话，说上次电话面试通过了，让我周末过去杭州总部面试，于是周末就去了趟杭州。这篇文章是关于网易这次面试的相关内容和自己面试后的感想，写出来和大家分享一下。</p><h2>面试过程</h2><p>3.4号接到网易的电话，说预约第二天下午三点进行电话面试，然后自己就开始准备自我介绍什么的。这里有个乌龙事件，之前投了份网易游戏的实习生，原来以为是游戏实习生的面试，几天之后接到网易游戏部的“虽然您很优秀…”的邮件，才知道原来游戏是招至少硕士学历的，这次电话面试并不是网易游戏的面试（后来才想起是之前投的网易iOS开发工程师实习生的职位，真囧~~）。 下面是第二天电话面试的大致内容，记得不是很清楚了，我大致还原一下当时的情景。忽略一些客气语，下面直接进入正题。</p><blockquote><p>面试官（以下以Q代替）：你学习iOS多长时间了？</p></blockquote><p>我（下面以A代替）：十个月的样子。</p><blockquote><p>Q：你了解MRC和ARC吗？</p></blockquote><p>A：对他们都有一定的了解，但用的更多的是ARC，当然也知道MRC的规则及用法，也有做过相关Demo，由于开始学习iOS的时候ARC已经成为一种趋势，所以用<a href=https://vonglo.cn/posts/Interview-In-NetEase>...></a></p><br><br><h3><a href=https://vonglo.cn/posts/Interview-In-NetEase>查看全文</a></h3>]]></content:encoded></item></channel></rss>